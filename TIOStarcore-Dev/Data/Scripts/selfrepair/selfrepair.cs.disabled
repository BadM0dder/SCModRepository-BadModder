using System;
using System.Collections.Generic;
using Sandbox.Game.Entities;
using Sandbox.ModAPI;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.ModAPI;

namespace BlockRegen.Data.Scripts
{
    [MyEntityComponentDescriptor(typeof(MyObjectBuilder_TerminalBlock), false, "Type18_Artillery_Block")]
    public class BlockRegen : MyGameLogicComponent
    {

        /*
        private static readonly HashSet<MyDefinitionId> _blocksNotToRepair =
            new HashSet<MyDefinitionId>(MyDefinitionId.Comparer)
            {
                new MyDefinitionId(typeof(MyObjectBuilder_CubeBlock), "K_Regeneration_Core_Large")
            };
        */

        private const int MaxBlocksHealedPerCycle = 50;
        private const float MinSelfHeal = 0.4f;
        private const float MaxSelfHeal = 1.0f;
        private const float HealRate = 0.1f;
        private const int Spread = 10;

        internal bool Regening;
        internal bool ContainerInited;

        private int _offset;
        private bool _blockUpdates;
        private uint _lastTick;
        private uint _100Tick;

        private MyCubeGrid _attachedGrid;
        internal MyCubeBlock MyCube;
        internal MyCubeGrid MyGrid;
        internal DSUtils DsUtil1 = new DSUtils();

        private readonly Dictionary<IMySlimBlock, int> _damagedBlockIdx = new Dictionary<IMySlimBlock, int>();
        private readonly List<IMySlimBlock> _damagedBlocks = new List<IMySlimBlock>();
        internal readonly DSUtils.UniqueQueue<IMySlimBlock> QueuedBlocks = new DSUtils.UniqueQueue<IMySlimBlock>();

        private MyCubeGrid AttachedGrid
        {
            get
            {
                return _attachedGrid;
            }
            set
            {
                if (_attachedGrid == value)
                {
                    return;
                }

                if (_attachedGrid != null)
                {
                    _attachedGrid.OnBlockIntegrityChanged -= BlockChanged;
                    _attachedGrid.OnBlockAdded -= BlockChanged;
                    _attachedGrid.OnBlockRemoved -= BlockChanged;
                }

                _damagedBlockIdx.Clear();
                _damagedBlocks.Clear();
                _attachedGrid = value;
                if (_attachedGrid != null)
                {
                    ((IMyCubeGrid)_attachedGrid).GetBlocks(null, (x) =>
                    {
                        BlockChanged(x);
                        return false;
                    });
                    _attachedGrid.OnBlockIntegrityChanged += BlockChanged;
                    _attachedGrid.OnBlockAdded += BlockChanged;
                    _attachedGrid.OnBlockRemoved += BlockChanged;
                }
            }
        }

        private void AddBlock(IMySlimBlock block)
        {
            if (_damagedBlockIdx.ContainsKey(block))
                return;
            _damagedBlockIdx.Add(block, _damagedBlocks.Count);
            _damagedBlocks.Add(block);
        }

        private void RemoveBlock(IMySlimBlock block)
        {
            int idx;
            if (!_damagedBlockIdx.TryGetValue(block, out idx))
                return;
            RemoveBlockAt(idx);
            _damagedBlockIdx.Remove(block);
        }

        private void RemoveBlockAt(int idx)
        {
            _damagedBlocks.RemoveAtFast(idx);
            if (idx < _damagedBlocks.Count)
                _damagedBlockIdx[_damagedBlocks[idx]] = idx;
        }

        public override void UpdateOnceBeforeFrame()
        {
            base.UpdateOnceBeforeFrame();
            try
            {

            }
            catch (Exception ex) { Log.Line($"Exception in UpdateOnceBeforeFrame: {ex}"); }
        }

        public override void OnAddedToContainer()
        {
            if (!ContainerInited)
            {
                NeedsUpdate |= MyEntityUpdateEnum.BEFORE_NEXT_FRAME;
                NeedsUpdate |= MyEntityUpdateEnum.EACH_100TH_FRAME;
                MyCube = (MyCubeBlock)Entity;
                ContainerInited = true;
            }
            if (Entity.InScene) OnAddedToScene();
        }

        public override void OnAddedToScene()
        {
            try
            {
                MyGrid = MyCube.CubeGrid;
                Session.Instance.GridsToLogics.Add(MyGrid, this);
                Session.Instance.BlockLogics.Add(this);
                AttachedGrid = MyGrid;
            }
            catch (Exception ex) { Log.Line($"Exception in OnAddedToScene: {ex}"); }
        }

        public override void OnBeforeRemovedFromContainer()
        {
            base.OnBeforeRemovedFromContainer();
            AttachedGrid = null;
        }

        public override void UpdateBeforeSimulation100()
        {
            AttachedGrid = MyGrid;
            _100Tick = (uint)MyAPIGateway.Session.ElapsedPlayTime.TotalMilliseconds / MyEngineConstants.UPDATE_STEP_SIZE_IN_MILLISECONDS;
            if (Regening && !_blockUpdates && _100Tick > _lastTick + 10)
            {
                var i = 0;
                while (i < QueuedBlocks.Count)
                {
                    if (_damagedBlocks.Count >= MaxBlocksHealedPerCycle) break;
                    BlockIntegrity(QueuedBlocks.Dequeue());
                }
                UpdateGen();
                Regening = false;
            }
        }

        public override void UpdateAfterSimulation()
        {
            _blockUpdates = true;
            _offset = (_offset + 1) % Spread;
            var i = _offset;
            while (i < _damagedBlocks.Count)
            {
                //if (i == 0) Log.Line($"d:{_damagedBlocks.Count} - dId:{_damagedBlockIdx.Count} - qu:{QueuedBlocks.Count}");
                var block = _damagedBlocks[i];
                var bIntegrity = block.Integrity;
                var maxIntegrity = block.MaxIntegrity;

                if (bIntegrity > maxIntegrity * MinSelfHeal && bIntegrity < maxIntegrity * MaxSelfHeal)
                {
                    var repair = MyEngineConstants.UPDATE_STEP_SIZE_IN_SECONDS * Spread * HealRate;
                    repair = Math.Min(block.MaxIntegrity - block.Integrity, repair);
                    if (block.OwnerId == 0)
                    {
                        var gridOwnerList = MyGrid.BigOwners;
                        var ownerCnt = gridOwnerList.Count;
                        var gridOwner = 0L;

                        if (gridOwnerList[0] != 0) gridOwner = gridOwnerList[0];
                        else if (ownerCnt > 1) gridOwner = gridOwnerList[1];

                        if (gridOwner != 0) block.IncreaseMountLevel(repair, gridOwner);
                        else
                        {
                            RemoveBlockAt(i);
                            _damagedBlockIdx.Remove(block);
                        }
                    }
                    else block.IncreaseMountLevel(repair, block.OwnerId);
                }
                bIntegrity = block.Integrity;
                maxIntegrity = block.MaxIntegrity;
                if (bIntegrity >= maxIntegrity * MaxSelfHeal)
                {
                    var deformTest = bIntegrity >= maxIntegrity && block.HasDeformation;
                    if (deformTest) block.FixBones(0.0f, 0.0f);

                    if (!deformTest || !block.HasDeformation)
                    {
                        //if (block.Integrity != block.MaxIntegrity || block.HasDeformation) Log.Line($"I:{block.Integrity} - M:{block.MaxIntegrity} - D:{block.HasDeformation}");
                        RemoveBlockAt(i);
                        _damagedBlockIdx.Remove(block);
                    }
                }
                else i += Spread;
            }
            _blockUpdates = false;
            if (_damagedBlocks.Count == 0)
            {
                _lastTick = (uint)MyAPIGateway.Session.ElapsedPlayTime.TotalMilliseconds / MyEngineConstants.UPDATE_STEP_SIZE_IN_MILLISECONDS;
                NeedsUpdate &= ~MyEntityUpdateEnum.EACH_FRAME;
            }
        }

        private void BlockChanged(IMySlimBlock block)
        {
            //if (_blockUpdates || _blocksNotToRepair.Contains(block.BlockDefinition.Id)) return;
            if (_blockUpdates) return;
            if (!BlockIntegrity(block)) RemoveBlock(block);
            UpdateGen();
        }

        public bool BlockIntegrity(IMySlimBlock block)
        {
            var bIntegrity = block.Integrity;
            var maxIntegrity = block.MaxIntegrity;
            if (bIntegrity > maxIntegrity * MinSelfHeal && bIntegrity < maxIntegrity * MaxSelfHeal || bIntegrity >= maxIntegrity && block.HasDeformation)
            {
                AddBlock(block);
                return true;
            }
            return false;
        }

        private void UpdateGen()
        {
            if (_damagedBlocks.Count > 0) NeedsUpdate |= MyEntityUpdateEnum.EACH_FRAME;
            else NeedsUpdate &= ~MyEntityUpdateEnum.EACH_FRAME;
        }

    }
}