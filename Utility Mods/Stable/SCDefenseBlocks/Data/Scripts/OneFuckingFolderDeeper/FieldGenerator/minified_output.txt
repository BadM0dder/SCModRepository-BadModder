using ProtoBuf;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using VRageMath;namespace Starcore.FieldGenerator{[ProtoContract]public class FieldGeneratorSettings{private FieldGenerator Owner;public FieldGeneratorSettings(){}public FieldGeneratorSettings(FieldGenerator owner){Owner=owner;}[ProtoMember(1)]private bool siegeMode;[ProtoMember(2)]private float fieldPower;[ProtoMember(3)]private float maxFieldPower;[ProtoMember(4)]private float minFieldPower;[ProtoMember(5)]private bool siegeCooldownActive;[ProtoMember(6)]private int siegeElapsedTime;[ProtoMember(7)]private int siegeCooldownTime;public bool SiegeMode{get{return siegeMode;}set{siegeMode=value;}}public float FieldPower{get{return fieldPower;}set{fieldPower=MathHelper.Clamp(value,MinFieldPower,MaxFieldPower);}}public float MaxFieldPower{get{return maxFieldPower;}set{maxFieldPower=value;}}public float MinFieldPower{get{return minFieldPower;}set{minFieldPower=value;}}public bool SiegeCooldownActive{get{return siegeCooldownActive;}set{siegeCooldownActive=value;}}public int SiegeElapsedTime{get{return siegeElapsedTime;}set{siegeElapsedTime=value;}}public int SiegeCooldownTime{get{return siegeCooldownTime;}set{siegeCooldownTime=value;}}public void CopyFrom(FieldGeneratorSettings other){siegeMode=other.siegeMode;fieldPower=other.fieldPower;maxFieldPower=other.maxFieldPower;minFieldPower=other.minFieldPower;siegeCooldownActive=other.siegeCooldownActive;siegeElapsedTime=other.siegeElapsedTime;siegeCooldownTime=other.siegeCooldownTime;}}}﻿using System;using System.Text;using System.Linq;using System.Collections.Generic;using Sandbox.ModAPI;using Sandbox.Common.ObjectBuilders;using Sandbox.Game.EntityComponents;using ProtoBuf;using VRage.Game;using VRage.Game.Entity;using VRage.Game.ModAPI;using VRage.Game.ModAPI.Network;using VRage.Sync;using VRage.Network;using VRage.Game.Components;using VRage.ModAPI;using VRage.ObjectBuilders;using VRageMath;using Starcore.FieldGenerator.Networking.Custom;namespace Starcore.FieldGenerator{public class Config{public const bool SimplifiedMode=true;public const float PerModuleAmount=12.5f;public const int MaxModuleCount=4;public const int MaxSiegeTime=150;public const int SiegePowerDraw=900;public const int DamageEventThreshold=6;public const int ResetInterval=3;public const float SizeModifierMax=0.8f;public const int MaxBlockCount=35000;public const float SizeModifierMin=1.2f;public const int MinBlockCount=2500;public const float MaxPowerDraw=500.00f;public const float MinPowerDraw=50.00f;}[MyEntityComponentDescriptor(typeof(MyObjectBuilder_Collector),false,"FieldGen_Core")]public class FieldGenerator:MyGameLogicComponent,IMyEventProxy{private IMyCollector Block;private FieldGeneratorSettings Settings;public readonly Guid SettingsGuid=new Guid("YOUR-GUID-HERE");private MyResourceSinkComponent Sink=null;private readonly bool IsServer=MyAPIGateway.Session.IsServer;private Dictionary<string,IMyModelDummy>_coreDummies=new Dictionary<string,IMyModelDummy>();private HashSet<long>_attachedModuleIds=new HashSet<long>();private int _moduleCount=0;private int _damageEventCounter=0;private float _stabilityChange=0;private int _resetCounter=0;private int initValueDelayTicks=60;private bool valuesInitialized=false;public MySync<bool,SyncDirection.BothWays>SiegeModeSync;public MySync<bool,SyncDirection.BothWays>SiegeCooldownActiveSync;public MySync<float,SyncDirection.BothWays>FieldPowerSync;public MySync<float,SyncDirection.BothWays>MaxFieldPowerSync;public MySync<float,SyncDirection.BothWays>MinFieldPowerSync;public MySync<float,SyncDirection.BothWays>StabilitySync;public MySync<int,SyncDirection.BothWays>SiegeElapsedTimeSync;public MySync<int,SyncDirection.BothWays>SiegeCooldownTimeSync;public bool SiegeMode{get{return _siegeMode;}set{if(_siegeMode!=value){_siegeMode=value;BoolSyncPacket.SyncBoolProperty(Block.EntityId,nameof(SiegeMode),_siegeMode);}}}public bool _siegeMode;public bool SiegeCooldownActive{get{return _siegeCooldownActive;}set{if(_siegeCooldownActive!=value){_siegeCooldownActive=value;BoolSyncPacket.SyncBoolProperty(Block.EntityId,nameof(SiegeCooldownActive),_siegeCooldownActive);}}}public bool _siegeCooldownActive;public int SiegeElapsedTime{get{return _siegeElapsedTime;}set{if(_siegeElapsedTime!=value){_siegeElapsedTime=value;IntSyncPacket.SyncIntProperty(Block.EntityId,nameof(SiegeElapsedTime),_siegeElapsedTime);}}}public int _siegeElapsedTime;public int SiegeCooldownTime{get{return _siegeCooldownTime;}set{if(_siegeCooldownTime!=value){_siegeCooldownTime=value;IntSyncPacket.SyncIntProperty(Block.EntityId,nameof(SiegeCooldownTime),_siegeCooldownTime);}}}public int _siegeCooldownTime;public float FieldPower{get{return _fieldPower;}set{if(_fieldPower!=value){_fieldPower=MathHelper.Clamp(value,MinFieldPower,MaxFieldPower);FloatSyncPacket.SyncFloatProperty(Block.EntityId,nameof(FieldPower),_fieldPower);}}}public float _fieldPower;public float MaxFieldPower{get{return _maxFieldPower;}set{if(_maxFieldPower!=value){_maxFieldPower=value;FloatSyncPacket.SyncFloatProperty(Block.EntityId,nameof(MaxFieldPower),_maxFieldPower);}}}public float _maxFieldPower;public float MinFieldPower{get{return _minFieldPower;}set{if(_minFieldPower!=value){_minFieldPower=value;FloatSyncPacket.SyncFloatProperty(Block.EntityId,nameof(MinFieldPower),_minFieldPower);}}}public float _minFieldPower;public float SizeModifier{get{return _sizeModifier;}set{if(_sizeModifier!=value){_sizeModifier=value;FloatSyncPacket.SyncFloatProperty(Block.EntityId,nameof(SizeModifier),_sizeModifier);}}}public float _sizeModifier;public float Stability{get{return _stability;}set{if(_stability!=value){_stability=value;FloatSyncPacket.SyncFloatProperty(Block.EntityId,nameof(Stability),_stability);}}}public float _stability;private List<IMySlimBlock>_gridBlocks=new List<IMySlimBlock>();private int _gridBlockCount;public MySync<bool,SyncDirection.FromServer>GridStopped=null;private IMyHudNotification notifSiege=null;private IMyHudNotification notifPower=null;public override void Init(MyObjectBuilder_EntityBase objectBuilder){base.Init(objectBuilder);Block=(IMyCollector)Entity;NeedsUpdate|=MyEntityUpdateEnum.BEFORE_NEXT_FRAME;}public override void UpdateOnceBeforeFrame(){base.UpdateOnceBeforeFrame();if(Block?.CubeGrid?.Physics==null)return;FieldGeneratorControls.DoOnce(ModContext);Settings=new FieldGeneratorSettings(this);if(IsServer){Block.Model.GetDummies(_coreDummies);InitExistingUpgrades();}Sink=Block.Components.Get<MyResourceSinkComponent>();Sink.SetRequiredInputFuncByType(MyResourceDistributorComponent.ElectricityId,CalculatePowerDraw);LoadSettings();NeedsUpdate|=MyEntityUpdateEnum.EACH_FRAME;NeedsUpdate|=MyEntityUpdateEnum.EACH_10TH_FRAME;}public override void UpdateAfterSimulation(){base.UpdateAfterSimulation();if(IsServer&&!valuesInitialized){if(initValueDelayTicks>0){initValueDelayTicks--;}else{Stability=100;InitExistingUpgrades();valuesInitialized=true;}}if(!IsServer)return;if(MyAPIGateway.Session.GameplayFrameCounter%60==0){if(Block.IsWorking){Sink.Update();UpdateSiegeState();if(!Config.SimplifiedMode){SizeModifier=CalculateSizeModifier();if(_damageEventCounter>Config.DamageEventThreshold){_stabilityChange=-((1.6666666666667f*SizeModifier)*(FieldPower/50));}else{_stabilityChange=3;}_stability=MathHelper.Clamp(_stability+_stabilityChange,0,100);if(_resetCounter<Config.ResetInterval){_resetCounter++;return;}else if(_resetCounter>=Config.ResetInterval){_resetCounter=0;_damageEventCounter=0;return;}}}else if(!Block.IsWorking){if(FieldPower>0)FieldPower=0;if(SiegeMode){CancelSiegeMode();SiegeMode=false;}}}}public override void UpdateAfterSimulation10(){base.UpdateAfterSimulation10();if(IsClientInShip()||IsClientNearShip()){if(SiegeMode){SetSiegeNotification($"<S.I> Siege Mode Active | {SiegeElapsedTime} / {Config.MaxSiegeTime}",600);}else if(!SiegeMode&&SiegeCooldownActive){SetSiegeNotification($"<S.I> Siege Mode On Cooldown | {SiegeCooldownTime}",600,"Red");}if(!Block.IsWorking){string reason=Block.IsFunctional?"Insufficient Power?":"Block Damaged!";SetPowerNotification($"<S.I> Generator Core is Offline! | {reason}",600,"Red");}}else return;}public override void Close(){base.Close();if(IsServer){Block.CubeGrid.OnBlockAdded-=OnBlockAdded;Block.CubeGrid.OnBlockRemoved-=OnBlockRemoved;}if(!IsServer){GridStopped.ValueChanged-=OnGridStopValueChange;}Block=null;}private void OnBlockAdded(IMySlimBlock block){if(block==null)return;_gridBlockCount++;if(!_gridBlocks.Contains(block))_gridBlocks.Add(block);if(block.FatBlock!=null&&block.FatBlock.BlockDefinition.SubtypeId=="FieldGen_Capacity_Upgrade"){if(IsNeighbour(block)){long entityId=block.FatBlock.EntityId;if(!_attachedModuleIds.Contains(entityId)&&_moduleCount<Config.MaxModuleCount){_attachedModuleIds.Add(entityId);_moduleCount++;CalculateUpgradeAmounts();}}}}private void OnBlockRemoved(IMySlimBlock block){if(block==null)return;_gridBlockCount--;if(_gridBlocks.Contains(block))_gridBlocks.Remove(block);if(block.FatBlock!=null&&block.FatBlock.BlockDefinition.SubtypeId=="FieldGen_Capacity_Upgrade"){long entityId=block.FatBlock.EntityId;if(_attachedModuleIds.Contains(entityId)){_attachedModuleIds.Remove(entityId);_moduleCount--;CalculateUpgradeAmounts();}}}private void HandleResistence(object target,ref MyDamageInformation info){if(Block==null||!Block.IsWorking)return;IMySlimBlock targetBlock=target as IMySlimBlock;if(targetBlock.CubeGrid!=null&&targetBlock!=null){IMyCubeGrid targetGrid=targetBlock.CubeGrid;if(targetGrid.EntityId!=Block.CubeGrid.EntityId)return;if(SiegeMode){info.Amount*=0.1f;return;}if(!Config.SimplifiedMode){_damageEventCounter++;}float roundedModifier=(float)Math.Round(1-((double)FieldPower/100),3);info.Amount*=roundedModifier;return;}}private void OnGridStopValueChange(MySync<bool,SyncDirection.FromServer>obj){if(obj?.Value??false)Block.CubeGrid.Physics.LinearVelocity=Vector3.Zero;}private void UpdateSiegeState(){if(SiegeMode&&!SiegeCooldownActive){if(SiegeElapsedTime+1<=Config.MaxSiegeTime){SiegeElapsedTime++;SiegeBlockEnabler(_gridBlocks,false);if(Block.CubeGrid.Physics.LinearVelocity!=Vector3D.Zero){Block.CubeGrid.Physics.LinearVelocity=Vector3.Zero;if(IsServer&&!GridStopped.Value)GridStopped.Value=true;}}else{EndSiegeMode();SiegeMode=false;return;}}if(!SiegeMode&&!SiegeCooldownActive&&SiegeElapsedTime>0){EndSiegeMode();return;}if(SiegeCooldownActive){if(SiegeCooldownTime>0){SiegeCooldownTime--;}else{SiegeCooldownActive=false;}}}private void SiegeBlockEnabler(List<IMySlimBlock>allTerminalBlocks,bool enabled){foreach(var block in allTerminalBlocks){if(block.FatBlock!=null&&block.FatBlock.BlockDefinition.SubtypeId!="FieldGen_Core"){var entBlock=block as MyEntity;if(entBlock!=null&&FieldGeneratorSession.CoreSysAPI.HasCoreWeapon(entBlock)){FieldGeneratorSession.CoreSysAPI.SetFiringAllowed(entBlock,enabled);var functionalBlock=block.FatBlock as IMyFunctionalBlock;if(functionalBlock!=null){functionalBlock.Enabled=enabled;}}}else continue;}}private void EndSiegeMode(){if(IsServer&&GridStopped.Value)GridStopped.Value=false;SiegeBlockEnabler(_gridBlocks,true);SiegeCooldownTime=(SiegeElapsedTime>5)?(SiegeElapsedTime*2):5;SiegeElapsedTime=0;SiegeCooldownActive=true;}private void CancelSiegeMode(){if(IsServer&&GridStopped.Value)GridStopped.Value=false;SiegeBlockEnabler(_gridBlocks,true);SiegeCooldownTime=0;SiegeElapsedTime=0;}public static T GetLogic<T>(long entityId)where T:MyGameLogicComponent{IMyEntity targetEntity=MyAPIGateway.Entities.GetEntityById(entityId);if(targetEntity==null){Log.Info("GetLogic failed: Entity not found. Entity ID: "+entityId);return null;}IMyTerminalBlock targetBlock=targetEntity as IMyTerminalBlock;if(targetBlock==null){Log.Info("GetLogic failed: Target entity is not a terminal block. Entity ID: "+entityId);return null;}var logic=targetBlock.GameLogic?.GetAs<T>();if(logic==null){Log.Info("GetLogic failed: Logic component not found. Entity ID: "+entityId);}return logic;}private void InitExistingUpgrades(){List<IMySlimBlock>neighbours=new List<IMySlimBlock>();Block.SlimBlock.GetNeighbours(neighbours);foreach(var n in neighbours){if(n?.FatBlock==null||n.FatBlock.BlockDefinition.SubtypeId!="FieldGen_Capacity_Upgrade")continue;if(IsModuleValid(n)){long entityId=n.FatBlock.EntityId;if(!_attachedModuleIds.Contains(entityId)){_attachedModuleIds.Add(entityId);_moduleCount++;}}}CalculateUpgradeAmounts();}private bool IsNeighbour(IMySlimBlock block){List<IMySlimBlock>neighbours=new List<IMySlimBlock>();Block.SlimBlock.GetNeighbours(neighbours);return neighbours.Contains(block);}private bool IsModuleValid(IMySlimBlock neighbor){var neighborDummies=new Dictionary<string,IMyModelDummy>();neighbor.FatBlock.Model.GetDummies(neighborDummies);foreach(var CoreDummy in _coreDummies){Vector3D coreDummyPos=Vector3D.Transform(CoreDummy.Value.Matrix.Translation,Block.WorldMatrix);foreach(var neighborDummy in neighborDummies){Vector3D neighborDummyPos=Vector3D.Transform(neighborDummy.Value.Matrix.Translation,neighbor.FatBlock.WorldMatrix);if(Vector3D.Distance(coreDummyPos,neighborDummyPos)<0.5)return true;}}return false;}private void LoadSettings(){if(Block?.Storage==null)return;string rawData;if(!Block.Storage.TryGetValue(SettingsGuid,out rawData))return;try{var loadedSettings=MyAPIGateway.Utilities.SerializeFromBinary<FieldGeneratorSettings>(Convert.FromBase64String(rawData));if(loadedSettings!=null){Settings.CopyFrom(loadedSettings);}}catch(Exception e){Log.Error($"Failed to load field generator settings: {e}");}}private void SaveSettings(){try{if(Block?.Storage==null)Block.Storage=new MyModStorageComponent();string rawData=Convert.ToBase64String(MyAPIGateway.Utilities.SerializeToBinary(Settings));Block.Storage[SettingsGuid]=rawData;}catch(Exception e){Log.Error($"Failed to save field generator settings: {e}");}}public override bool IsSerialized(){SaveSettings();return base.IsSerialized();}private void CalculateUpgradeAmounts(){Settings.MaxFieldPower=Settings.MinFieldPower+(_moduleCount*Config.PerModuleAmount);if(Settings.FieldPower>Settings.MaxFieldPower){Settings.FieldPower=Settings.MaxFieldPower;}}private float CalculateSizeModifier(){int clampedBlockCount=MathHelper.Clamp(_gridBlockCount,Config.MinBlockCount,Config.MaxBlockCount);float t=(float)(clampedBlockCount-Config.MinBlockCount)/(Config.MaxBlockCount-Config.MinBlockCount);return Config.SizeModifierMin+t*(Config.SizeModifierMax-Config.SizeModifierMin);}private float CalculatePowerDraw(){if(Settings.SiegeMode)return Config.SiegePowerDraw;float maxPossibleFieldPower=Config.PerModuleAmount*Config.MaxModuleCount;float clampedFieldPower=MathHelper.Clamp(Settings.FieldPower,0,maxPossibleFieldPower);float t=clampedFieldPower/maxPossibleFieldPower;return Config.MinPowerDraw+t*(Config.MaxPowerDraw-Config.MinPowerDraw);}private bool IsClientInShip(){if(Block!=null){foreach(var cockpit in Block.CubeGrid.GetFatBlocks<IMyCockpit>()){if(cockpit.Pilot!=null&&cockpit.Pilot.EntityId==MyAPIGateway.Session?.Player?.Character?.EntityId){return true;}else continue;}}return false;}private bool IsClientNearShip(){if(Block!=null){var bound=new BoundingSphereD(Block.CubeGrid.GetPosition(),65);List<IMyEntity>nearEntities=MyAPIGateway.Entities.GetEntitiesInSphere(ref bound);foreach(var entity in nearEntities)if(entity!=null&&entity?.EntityId==MyAPIGateway.Session?.Player?.Character?.EntityId){return true;}else continue;}return false;}public void SetSiegeNotification(string text,int aliveTime=300,string font=MyFontEnum.Green){if(notifSiege==null)notifSiege=MyAPIGateway.Utilities.CreateNotification("",aliveTime,font);notifSiege.Hide();notifSiege.Font=font;notifSiege.Text=text;notifSiege.AliveTime=aliveTime;notifSiege.Show();}public void SetPowerNotification(string text,int aliveTime=300,string font=MyFontEnum.Green){if(notifPower==null)notifPower=MyAPIGateway.Utilities.CreateNotification("",aliveTime,font);notifPower.Hide();notifPower.Font=font;notifPower.Text=text;notifPower.AliveTime=aliveTime;notifPower.Show();}}}﻿using System;using System.Collections.Generic;using System.IO;using System.Text;using ParallelTasks;using Sandbox.ModAPI;using VRage.Game;using VRage.Game.Components;using VRage.Game.ModAPI;using VRage.Utils;namespace Starcore.FieldGenerator{[MySessionComponentDescriptor(MyUpdateOrder.NoUpdate,priority:int.MaxValue)]public class Log:MySessionComponentBase{private static Log instance;private static Handler handler;private static bool unloaded=false;public static readonly string FILE=GenerateTimestampedFileName();private const int DEFAULT_TIME_INFO=3000;private const int DEFAULT_TIME_ERROR=10000;private static string GenerateTimestampedFileName(){string timestamp=DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");return$"[{timestamp}]-FieldGenerator.log";}public const string PRINT_ERROR="<err>";public const string PRINT_MSG="<msg>";public override void LoadData(){instance=this;EnsureHandlerCreated();handler.Init(this);}protected override void UnloadData(){instance=null;if(handler!=null&&handler.AutoClose){Unload();}}private void Unload(){try{if(unloaded)return;unloaded=true;handler?.Close();handler=null;}catch(Exception e){MyLog.Default.WriteLine($"Error in {ModContext.ModName} ({ModContext.ModId}): {e.Message}\n{e.StackTrace}");throw new ModCrashedException(e,ModContext);}}private static void EnsureHandlerCreated(){if(unloaded)throw new Exception("Digi.Log accessed after it was unloaded!");if(handler==null)handler=new Handler();}public static void Close(){instance?.Unload();}public static bool AutoClose{get{EnsureHandlerCreated();return handler.AutoClose;}set{EnsureHandlerCreated();handler.AutoClose=value;}}public static string ModName{get{EnsureHandlerCreated();return handler.ModName;}set{EnsureHandlerCreated();handler.ModName=value;}}public static ulong WorkshopId=>handler?.WorkshopId??0;public static void IncreaseIndent(){EnsureHandlerCreated();handler.IncreaseIndent();}public static void DecreaseIndent(){EnsureHandlerCreated();handler.DecreaseIndent();}public static void ResetIndent(){EnsureHandlerCreated();handler.ResetIndent();}public static void Error(Exception exception,string printText=PRINT_ERROR,int printTimeMs=DEFAULT_TIME_ERROR){EnsureHandlerCreated();handler.Error(exception.ToString(),printText,printTimeMs);}public static void Error(string message,string printText=PRINT_ERROR,int printTimeMs=DEFAULT_TIME_ERROR){EnsureHandlerCreated();handler.Error(message,printText,printTimeMs);}public static void Info(string message,string printText=null,int printTimeMs=DEFAULT_TIME_INFO){EnsureHandlerCreated();handler.Info(message,printText,printTimeMs);}public static bool TaskHasErrors(ParallelTasks.Task task,string taskName){EnsureHandlerCreated();if(task.Exceptions!=null&&task.Exceptions.Length>0){foreach(var e in task.Exceptions){Error($"Error in {taskName} thread!\n{e}");}return true;}return false;}private class Handler{private Log sessionComp;private string modName=string.Empty;private TextWriter writer;private int indent=0;private string errorPrintText;private IMyHudNotification notifyInfo;private IMyHudNotification notifyError;private StringBuilder sb=new StringBuilder(64);private List<string>preInitMessages;public bool AutoClose{get;set;}=true;public ulong WorkshopId{get;private set;}=0;public string ModName{get{return modName;}set{modName=value;ComputeErrorPrintText();}}public Handler(){}public void Init(Log sessionComp){if(writer!=null)return;if(MyAPIGateway.Utilities==null){Error("MyAPIGateway.Utilities is NULL !");return;}this.sessionComp=sessionComp;if(string.IsNullOrWhiteSpace(ModName))ModName=sessionComp.ModContext.ModName;WorkshopId=GetWorkshopID(sessionComp.ModContext.ModId);writer=MyAPIGateway.Utilities.WriteFileInLocalStorage(FILE,typeof(Log));if(preInitMessages!=null){string warning=$"{modName} WARNING: there are log messages before the mod initialized!";Info($"--- pre-init messages ---");foreach(var msg in preInitMessages){Info(msg,warning);}Info("--- end pre-init messages ---");preInitMessages=null;}sb.Clear();sb.Append("Initialized");sb.Append("\nGameMode=").Append(MyAPIGateway.Session.SessionSettings.GameMode);sb.Append("\nOnlineMode=").Append(MyAPIGateway.Session.SessionSettings.OnlineMode);sb.Append("\nServer=").Append(MyAPIGateway.Session.IsServer);sb.Append("\nDS=").Append(MyAPIGateway.Utilities.IsDedicated);sb.Append("\nDefined=");
#if STABLE
sb.Append("STABLE, ");
#endif
#if UNOFFICIAL
sb.Append("UNOFFICIAL, ");
#endif
#if DEBUG
sb.Append("DEBUG, ");
#endif
#if BRANCH_STABLE
sb.Append("BRANCH_STABLE, ");
#endif
#if BRANCH_DEVELOP
sb.Append("BRANCH_DEVELOP, ");
#endif
#if BRANCH_UNKNOWN
sb.Append("BRANCH_UNKNOWN, ");
#endif
Info(sb.ToString());sb.Clear();}public void Close(){if(writer!=null){Info("Unloaded.");writer.Flush();writer.Close();writer=null;}}private void ComputeErrorPrintText(){errorPrintText=$"[ {modName} ERROR, report contents of: %AppData%/SpaceEngineers/Storage/{MyAPIGateway.Utilities.GamePaths.ModScopeName}/{FILE} ]";}public void IncreaseIndent(){indent++;}public void DecreaseIndent(){if(indent>0)indent--;}public void ResetIndent(){indent=0;}public void Error(string message,string printText=PRINT_ERROR,int printTime=DEFAULT_TIME_ERROR){MyLog.Default.WriteLineAndConsole(modName+" error/exception: "+message);LogMessage(message,"ERROR: ");if(printText!=null)ShowHudMessage(ref notifyError,message,printText,printTime,MyFontEnum.Red);}public void Info(string message,string printText=null,int printTime=DEFAULT_TIME_INFO){LogMessage(message);if(printText!=null)ShowHudMessage(ref notifyInfo,message,printText,printTime,MyFontEnum.White);}private void ShowHudMessage(ref IMyHudNotification notify,string message,string printText,int printTime,string font){if(printText==null)return;try{if(MyAPIGateway.Utilities!=null&&!MyAPIGateway.Utilities.IsDedicated){if(printText==PRINT_ERROR)printText=errorPrintText;else if(printText==PRINT_MSG)printText=$"[ {modName} ERROR: {message} ]";if(notify==null){notify=MyAPIGateway.Utilities.CreateNotification(printText,printTime,font);}else{notify.Text=printText;notify.AliveTime=printTime;notify.ResetAliveTime();}notify.Show();}}catch(Exception e){Info("ERROR: Could not send notification to local client: "+e);MyLog.Default.WriteLineAndConsole(modName+" logger error/exception: Could not send notification to local client: "+e);}}private void LogMessage(string message,string prefix=null){try{sb.Clear();sb.Append(DateTime.Now.ToString("[HH:mm:ss] "));if(writer==null)sb.Append("(PRE-INIT) ");for(int i=0;i<indent;i++)sb.Append(' ',4);if(prefix!=null)sb.Append(prefix);sb.Append(message);if(writer==null){if(preInitMessages==null)preInitMessages=new List<string>();preInitMessages.Add(sb.ToString());}else{writer.WriteLine(sb);writer.Flush();}sb.Clear();}catch(Exception e){MyLog.Default.WriteLineAndConsole($"{modName} had an error while logging message = '{message}'\nLogger error: {e.Message}\n{e.StackTrace}");}}private ulong GetWorkshopID(string modId){foreach(var mod in MyAPIGateway.Session.Mods){if(mod.Name==modId)return mod.PublishedFileId;}return 0;}}}}﻿using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using VRage.Game.Components;using CoreSystems.Api;using Starcore.FieldGenerator.Networking;using Sandbox.ModAPI;using Starcore.FieldGenerator.Networking.Custom;namespace Starcore.FieldGenerator{[MySessionComponentDescriptor(MyUpdateOrder.AfterSimulation)]public class FieldGeneratorSession:MySessionComponentBase{public static WcApi CoreSysAPI;public static HeartNetwork Networking=new HeartNetwork();public static PacketQueueManager PacketQueue=new PacketQueueManager();public override void LoadData(){base.LoadData();Networking.Init("FieldGeneratorNetwork");PacketQueue.Init();CoreSysAPI=new WcApi();CoreSysAPI.Load();}public override void UpdateAfterSimulation(){base.UpdateAfterSimulation();if(!PacketQueueManager.I.QueuesWithPackets())return;foreach(long entityID in PacketQueueManager.I.EntitiesWithQueue()){PacketBase packet=PacketQueueManager.I.FirstInQueue(entityID);if(packet!=null){if(HeartNetwork.CheckRateLimit(entityID)){Log.Info($"PacketManager: Queued Packet Found for Entity ID: {entityID}");if(MyAPIGateway.Session.IsServer)HeartNetwork.I.SendToEveryone(packet);else HeartNetwork.I.SendToServer(packet);Log.Info($"PacketManager: Sent Queued Packet for Entity ID: {entityID}, Removing From Queue");PacketQueueManager.I.DequeuePacket(entityID);}}}}protected override void UnloadData(){Networking.Close();PacketQueue.Close();if(CoreSysAPI.IsReady){CoreSysAPI.Unload();CoreSysAPI=null;}}}}﻿using System;using System.Collections.Generic;using System.IO;using System.Text;using Sandbox.Game.Localization;using Sandbox.ModAPI;using Sandbox.ModAPI.Interfaces.Terminal;using VRage.Game;using VRage.Game.Components;using VRage.Game.ModAPI;using VRage.ModAPI;using VRage.Utils;using VRageMath;namespace Starcore.FieldGenerator{public static class FieldGeneratorControls{const string IdPrefix="FieldGenerator_";static bool Done=false;public static void DoOnce(IMyModContext context){try{if(Done)return;Done=true;CreateControls();CreateActions(context);}catch(Exception e){MyLog.Default.WriteLine($"[FieldGenerator] {e}");}}static bool IsVisible(IMyTerminalBlock b){return b?.GameLogic?.GetAs<FieldGenerator>()!=null;}static bool CooldownEnabler(IMyTerminalBlock b){var logic=GetLogic(b);if(logic!=null){return!logic.SiegeCooldownActive;}return false;}static void CreateControls(){var SiegeModeToggle=MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlOnOffSwitch,IMyCollector>(IdPrefix+"SiegeModeToggle");SiegeModeToggle.Title=MyStringId.GetOrCompute("Siege Mode");SiegeModeToggle.Tooltip=MyStringId.GetOrCompute("Toggle Siege Mode");SiegeModeToggle.OnText=MyStringId.GetOrCompute("On");SiegeModeToggle.OffText=MyStringId.GetOrCompute("Off");SiegeModeToggle.Visible=IsVisible;SiegeModeToggle.Enabled=CooldownEnabler;SiegeModeToggle.Getter=(b)=>b.GameLogic.GetAs<FieldGenerator>().SiegeMode;SiegeModeToggle.Setter=(b,v)=>b.GameLogic.GetAs<FieldGenerator>().SiegeMode=v;SiegeModeToggle.SupportsMultipleBlocks=true;MyAPIGateway.TerminalControls.AddControl<IMyCollector>(SiegeModeToggle);var FieldPowerSlider=MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlSlider,IMyCollector>(IdPrefix+"FieldPowerSlider");FieldPowerSlider.Title=MyStringId.GetOrCompute("Integrity Field Power");FieldPowerSlider.Tooltip=MyStringId.GetOrCompute("Set Damage Absorption Percentage");FieldPowerSlider.SetLimits((b)=>GetMinLimit(b),(b)=>GetMaxLimit(b));FieldPowerSlider.Visible=IsVisible;FieldPowerSlider.Enabled=(b)=>{var logic=GetLogic(b);if(logic!=null){return!logic.SiegeMode;}else return true;};FieldPowerSlider.Writer=(b,w)=>{var logic=GetLogic(b);if(logic!=null){float value=logic.FieldPower;w.Append(Math.Round(value,1,MidpointRounding.ToEven)).Append('%');}};FieldPowerSlider.Getter=(b)=>b.GameLogic.GetAs<FieldGenerator>().FieldPower;FieldPowerSlider.Setter=(b,v)=>b.GameLogic.GetAs<FieldGenerator>().FieldPower=(int)Math.Round(v,1);FieldPowerSlider.SupportsMultipleBlocks=true;MyAPIGateway.TerminalControls.AddControl<IMyCollector>(FieldPowerSlider);}static void CreateActions(IMyModContext context){var SiegeToggleAction=MyAPIGateway.TerminalControls.CreateAction<IMyCollector>(IdPrefix+"SiegeToggleAction");SiegeToggleAction.Name=new StringBuilder("Siege Mode");SiegeToggleAction.ValidForGroups=false;SiegeToggleAction.Icon=@"Textures\GUI\Icons\Actions\StationToggle.dds";SiegeToggleAction.Action=(b)=>{var logic=GetLogic(b);if(logic!=null){logic.SiegeMode=!logic.SiegeMode;}};SiegeToggleAction.Writer=(b,sb)=>{var logic=GetLogic(b);if(logic!=null){string boolState=logic.SiegeMode?"Active":"Inactive";sb.Append(boolState);}};SiegeToggleAction.InvalidToolbarTypes=new List<MyToolbarType>(){MyToolbarType.ButtonPanel,MyToolbarType.Character,MyToolbarType.Seat};SiegeToggleAction.Enabled=CooldownEnabler;MyAPIGateway.TerminalControls.AddAction<IMyCollector>(SiegeToggleAction);var IncreasePowerAction=MyAPIGateway.TerminalControls.CreateAction<IMyCollector>(IdPrefix+"IncreasePowerAction");IncreasePowerAction.Name=new StringBuilder("Increase Field Power");IncreasePowerAction.ValidForGroups=false;IncreasePowerAction.Icon=@"Textures\GUI\Icons\Actions\StationToggle.dds";IncreasePowerAction.Action=(b)=>{var logic=GetLogic(b);if(logic!=null){logic.FieldPower+=2.5f;}};IncreasePowerAction.Writer=(b,sb)=>{var logic=GetLogic(b);if(logic!=null){sb.Append($"{logic.FieldPower}%");}};IncreasePowerAction.InvalidToolbarTypes=new List<MyToolbarType>(){MyToolbarType.ButtonPanel,MyToolbarType.Character,MyToolbarType.Seat};IncreasePowerAction.Enabled=(b)=>{var logic=GetLogic(b);if(logic!=null){return!logic.SiegeMode;}else return true;};MyAPIGateway.TerminalControls.AddAction<IMyCollector>(IncreasePowerAction);var DecreasePowerAction=MyAPIGateway.TerminalControls.CreateAction<IMyCollector>(IdPrefix+"DecreasePowerAction");DecreasePowerAction.Name=new StringBuilder("Decrease Field Power");DecreasePowerAction.ValidForGroups=false;DecreasePowerAction.Icon=@"Textures\GUI\Icons\Actions\StationToggle.dds";DecreasePowerAction.Action=(b)=>{var logic=GetLogic(b);if(logic!=null){logic.FieldPower-=2.5f;}};DecreasePowerAction.Writer=(b,sb)=>{var logic=GetLogic(b);if(logic!=null){sb.Append($"{logic.FieldPower}%");}};DecreasePowerAction.InvalidToolbarTypes=new List<MyToolbarType>(){MyToolbarType.ButtonPanel,MyToolbarType.Character,MyToolbarType.Seat};DecreasePowerAction.Enabled=(b)=>{var logic=GetLogic(b);if(logic!=null){return!logic.SiegeMode;}else return true;};MyAPIGateway.TerminalControls.AddAction<IMyCollector>(DecreasePowerAction);}static FieldGenerator GetLogic(IMyTerminalBlock block)=>block?.GameLogic?.GetAs<FieldGenerator>();static float GetMinLimit(IMyTerminalBlock block){var logic=GetLogic(block);if(logic!=null){return logic.MinFieldPower;}return 0;}static float GetMaxLimit(IMyTerminalBlock block){var logic=GetLogic(block);if(logic!=null){return logic.MaxFieldPower;}return 0;}}}﻿using System;using System.Collections;using System.Collections.Generic;using System.Text;using Sandbox.ModAPI;using VRage;using VRage.Utils;using VRage.Collections;using VRage.Game;using VRage.Game.Entity;using VRage.Game.ModAPI;using VRageMath;namespace CoreSystems.Api{public partial class WcApi{private bool _apiInit;private Action<IList<byte[]>>_getAllWeaponDefinitions;private Action<ICollection<MyDefinitionId>>_getCoreWeapons;private Action<ICollection<MyDefinitionId>>_getNpcSafeWeapons;private Action<IDictionary<MyDefinitionId,List<MyTuple<int,MyTuple<MyDefinitionId,string,string,bool>>>>>_getAllWeaponMagazines;private Action<IDictionary<MyDefinitionId,List<MyTuple<int,MyTuple<MyDefinitionId,string,string,bool>>>>>_getAllNpcSafeWeaponMagazines;private Action<ICollection<MyDefinitionId>>_getCoreStaticLaunchers;private Action<ICollection<MyDefinitionId>>_getCoreTurrets;private Action<ICollection<MyDefinitionId>>_getCorePhantoms;private Action<ICollection<MyDefinitionId>>_getCoreRifles;private Action<IList<byte[]>>_getCoreArmors;private Action<long,int,Action<ListReader<MyTuple<ulong,long,int,MyEntity,MyEntity,ListReader<MyTuple<Vector3D,object,float>>>>>>_registerDamageEvent;private Func<long,bool,Func<MyEntity,IMyCharacter,long,int,bool>,bool>_targetFocusHandler;private Func<long,bool,Func<IMyCharacter,long,int,bool>,bool>_hudHandler;private Func<long,bool,Func<Vector3D,Vector3D,int,bool,object,int,int,int,bool>,bool>_shootHandler;private Action<MyEntity,int,Action<int,bool>>_monitorEvents;private Action<MyEntity,int,Action<int,bool>>_unmonitorEvents;private Action<MyEntity,int,Action<long,int,ulong,long,Vector3D,bool>>_addProjectileMonitor;private Action<MyEntity,int,Action<long,int,ulong,long,Vector3D,bool>>_removeProjectileMonitor;private Func<MyEntity,object,int,double,bool>_shootRequest;private Func<ulong,MyTuple<Vector3D,Vector3D,float,float,long,string>>_getProjectileState;private Action<ulong,MyTuple<bool,Vector3D,Vector3D,float>>_setProjectileState;private Action<MyEntity,ICollection<MyTuple<MyEntity,float>>>_getSortedThreats;private Action<MyEntity,ICollection<MyEntity>>_getObstructions;private Func<MyEntity,int,MyEntity>_getAiFocus;private Func<MyEntity,MyEntity,int,bool>_setAiFocus;private Func<MyEntity,long,bool>_releaseAiFocus;private Func<MyEntity,bool>_hasAi;private Func<MyEntity,bool>_hasCoreWeapon;private Func<MyEntity,bool>_toggoleInfiniteResources;private Action<MyEntity>_disableRequiredPower;private Func<MyEntity,long>_getPlayerController;private Func<MyEntity,MyTuple<bool,int,int>>_getProjectilesLockedOn;private Action<MyEntity,ICollection<Vector3D>>_getProjectilesLockedOnPos;private Func<MyDefinitionId,float>_getMaxPower;private Func<MyEntity,float>_getOptimalDps;private Func<MyEntity,float>_getConstructEffectiveDps;private Func<MyEntity,MyTuple<bool,bool>>_isInRange;private Func<MyEntity,int,MyTuple<bool,bool,bool,MyEntity>>_getWeaponTarget;private Action<MyEntity,MyEntity,int>_setWeaponTarget;private Action<MyEntity,bool,int>_fireWeaponOnce;private Action<MyEntity,bool,bool,int>_toggleWeaponFire;private Func<MyEntity,int,bool,bool,bool>_isWeaponReadyToFire;private Func<MyEntity,int,float>_getMaxWeaponRange;private Func<MyEntity,ICollection<string>,int,bool>_getTurretTargetTypes;private Action<MyEntity,ICollection<string>,int>_setTurretTargetTypes;private Action<MyEntity,float>_setBlockTrackingRange;private Func<MyEntity,MyEntity,int,bool>_isTargetAligned;private Func<MyEntity,MyEntity,int,MyTuple<bool,Vector3D?>>_isTargetAlignedExtended;private Func<MyEntity,MyEntity,int,bool>_canShootTarget;private Func<MyEntity,MyEntity,int,Vector3D?>_getPredictedTargetPos;private Func<MyEntity,float>_getHeatLevel;private Func<MyEntity,float>_currentPowerConsumption;private Func<MyEntity,int,string>_getActiveAmmo;private Action<MyEntity,int,string>_setActiveAmmo;private Func<MyEntity,int,Matrix>_getWeaponAzimuthMatrix;private Func<MyEntity,int,Matrix>_getWeaponElevationMatrix;private Func<MyEntity,MyEntity,bool,bool,bool>_isTargetValid;private Func<MyEntity,int,bool>_isWeaponShooting;private Func<MyEntity,int,int>_getShotsFired;private Action<MyEntity,int,List<MyTuple<Vector3D,Vector3D,Vector3D,Vector3D,MatrixD,MatrixD>>>_getMuzzleInfo;private Func<MyEntity,int,MyTuple<Vector3D,Vector3D>>_getWeaponScope;private Func<MyEntity,int,MyTuple<MyDefinitionId,string,string,bool>>_getMagazineMap;private Func<MyEntity,int,MyDefinitionId,bool,bool>_setMagazine;private Func<MyEntity,int,bool>_forceReload;private Action<MyEntity,float>_setRofMultiplier;private Action<MyEntity,float>_setBaseDmgMultiplier;private Action<MyEntity,float>_setAreaDmgMultiplier;private Action<MyEntity,float>_setAreaRadiusMultiplier;private Action<MyEntity,float>_setVelocityMultiplier;private Action<MyEntity,bool>_setFiringAllowed;private Func<MyEntity,float>_getRofMultiplier;private Func<MyEntity,float>_getBaseDmgMultiplier;private Func<MyEntity,float>_getAreaDmgMultiplier;private Func<MyEntity,float>_getAreaRadiusMultiplier;private Func<MyEntity,float>_getVelocityMultiplier;private Func<MyEntity,bool>_getFiringAllowed;public void SetRofMultiplier(MyEntity block,float rof)=>_setRofMultiplier?.Invoke(block,rof);public void SetBaseDmgMultiplier(MyEntity block,float multiplier)=>_setBaseDmgMultiplier?.Invoke(block,multiplier);public void SetAreaDmgMultiplier(MyEntity block,float multiplier)=>_setAreaDmgMultiplier?.Invoke(block,multiplier);public void SetAreaRadiusMultiplier(MyEntity block,float multiplier)=>_setAreaRadiusMultiplier?.Invoke(block,multiplier);public void SetVelocityMultiplier(MyEntity block,float multiplier)=>_setVelocityMultiplier?.Invoke(block,multiplier);public void SetFiringAllowed(MyEntity block,bool isAllowed)=>_setFiringAllowed?.Invoke(block,isAllowed);public void SetWeaponTarget(MyEntity weapon,MyEntity target,int weaponId=0)=>_setWeaponTarget?.Invoke(weapon,target,weaponId);public float GetRofMultiplier(MyEntity block)=>_getRofMultiplier?.Invoke(block)??-2;public float GetBaseDmgMultiplier(MyEntity block)=>_getBaseDmgMultiplier?.Invoke(block)??-2;public float GetAreaDmgMultiplier(MyEntity block)=>_getAreaDmgMultiplier?.Invoke(block)??-2;public float GetAreaRadiusMultiplier(MyEntity block)=>_getAreaRadiusMultiplier?.Invoke(block)??-2;public float GetVelocityMultiplier(MyEntity block)=>_getVelocityMultiplier?.Invoke(block)??-2;public bool GetFiringAllowed(MyEntity block)=>_getFiringAllowed?.Invoke(block)??false;public void FireWeaponOnce(MyEntity weapon,bool allWeapons=true,int weaponId=0)=>_fireWeaponOnce?.Invoke(weapon,allWeapons,weaponId);public void ToggleWeaponFire(MyEntity weapon,bool on,bool allWeapons,int weaponId=0)=>_toggleWeaponFire?.Invoke(weapon,on,allWeapons,weaponId);public bool IsWeaponReadyToFire(MyEntity weapon,int weaponId=0,bool anyWeaponReady=true,bool shootReady=false)=>_isWeaponReadyToFire?.Invoke(weapon,weaponId,anyWeaponReady,shootReady)??false;public float GetMaxWeaponRange(MyEntity weapon,int weaponId)=>_getMaxWeaponRange?.Invoke(weapon,weaponId)??0f;public bool GetTurretTargetTypes(MyEntity weapon,IList<string>collection,int weaponId=0)=>_getTurretTargetTypes?.Invoke(weapon,collection,weaponId)??false;public void SetTurretTargetTypes(MyEntity weapon,IList<string>collection,int weaponId=0)=>_setTurretTargetTypes?.Invoke(weapon,collection,weaponId);public void SetBlockTrackingRange(MyEntity weapon,float range)=>_setBlockTrackingRange?.Invoke(weapon,range);public bool IsTargetAligned(MyEntity weapon,MyEntity targetEnt,int weaponId)=>_isTargetAligned?.Invoke(weapon,targetEnt,weaponId)??false;public MyTuple<bool,Vector3D?>IsTargetAlignedExtended(MyEntity weapon,MyEntity targetEnt,int weaponId)=>_isTargetAlignedExtended?.Invoke(weapon,targetEnt,weaponId)??new MyTuple<bool,Vector3D?>();public bool CanShootTarget(MyEntity weapon,MyEntity targetEnt,int weaponId)=>_canShootTarget?.Invoke(weapon,targetEnt,weaponId)??false;public Vector3D?GetPredictedTargetPosition(MyEntity weapon,MyEntity targetEnt,int weaponId)=>_getPredictedTargetPos?.Invoke(weapon,targetEnt,weaponId)??null;public float GetHeatLevel(MyEntity weapon)=>_getHeatLevel?.Invoke(weapon)??0f;public float GetCurrentPower(MyEntity weapon)=>_currentPowerConsumption?.Invoke(weapon)??0f;public void DisableRequiredPower(MyEntity weapon)=>_disableRequiredPower?.Invoke(weapon);public bool HasCoreWeapon(MyEntity weapon)=>_hasCoreWeapon?.Invoke(weapon)??false;public string GetActiveAmmo(MyEntity weapon,int weaponId)=>_getActiveAmmo?.Invoke(weapon,weaponId)??null;public void SetActiveAmmo(MyEntity weapon,int weaponId,string ammoType)=>_setActiveAmmo?.Invoke(weapon,weaponId,ammoType);public long GetPlayerController(MyEntity weapon)=>_getPlayerController?.Invoke(weapon)??-1;public Matrix GetWeaponAzimuthMatrix(MyEntity weapon,int weaponId)=>_getWeaponAzimuthMatrix?.Invoke(weapon,weaponId)??Matrix.Zero;public Matrix GetWeaponElevationMatrix(MyEntity weapon,int weaponId)=>_getWeaponElevationMatrix?.Invoke(weapon,weaponId)??Matrix.Zero;public bool IsTargetValid(MyEntity weapon,MyEntity target,bool onlyThreats,bool checkRelations)=>_isTargetValid?.Invoke(weapon,target,onlyThreats,checkRelations)??false;public void GetAllWeaponDefinitions(IList<byte[]>collection)=>_getAllWeaponDefinitions?.Invoke(collection);public void GetAllCoreWeapons(ICollection<MyDefinitionId>collection)=>_getCoreWeapons?.Invoke(collection);public void GetNpcSafeWeapons(ICollection<MyDefinitionId>collection)=>_getNpcSafeWeapons?.Invoke(collection);public void GetAllCoreStaticLaunchers(ICollection<MyDefinitionId>collection)=>_getCoreStaticLaunchers?.Invoke(collection);public void GetAllWeaponMagazines(IDictionary<MyDefinitionId,List<MyTuple<int,MyTuple<MyDefinitionId,string,string,bool>>>>collection)=>_getAllWeaponMagazines?.Invoke(collection);public void GetAllNpcSafeWeaponMagazines(IDictionary<MyDefinitionId,List<MyTuple<int,MyTuple<MyDefinitionId,string,string,bool>>>>collection)=>_getAllNpcSafeWeaponMagazines?.Invoke(collection);public void GetAllCoreTurrets(ICollection<MyDefinitionId>collection)=>_getCoreTurrets?.Invoke(collection);public void GetAllCorePhantoms(ICollection<MyDefinitionId>collection)=>_getCorePhantoms?.Invoke(collection);public void GetAllCoreRifles(ICollection<MyDefinitionId>collection)=>_getCoreRifles?.Invoke(collection);public void GetAllCoreArmors(IList<byte[]>collection)=>_getCoreArmors?.Invoke(collection);public MyTuple<bool,int,int>GetProjectilesLockedOn(MyEntity victim)=>_getProjectilesLockedOn?.Invoke(victim)??new MyTuple<bool,int,int>();public void GetProjectilesLockedOnPos(MyEntity victim,ICollection<Vector3D>collection)=>_getProjectilesLockedOnPos?.Invoke(victim,collection);public void GetSortedThreats(MyEntity shooter,ICollection<MyTuple<MyEntity,float>>collection)=>_getSortedThreats?.Invoke(shooter,collection);public void GetObstructions(MyEntity shooter,ICollection<MyEntity>collection)=>_getObstructions?.Invoke(shooter,collection);public MyEntity GetAiFocus(MyEntity shooter,int priority=0)=>_getAiFocus?.Invoke(shooter,priority);public bool SetAiFocus(MyEntity shooter,MyEntity target,int priority=0)=>_setAiFocus?.Invoke(shooter,target,priority)??false;public bool ReleaseAiFocus(MyEntity shooter,long playerId)=>_releaseAiFocus?.Invoke(shooter,playerId)??false;public MyTuple<bool,bool,bool,MyEntity>GetWeaponTarget(MyEntity weapon,int weaponId=0)=>_getWeaponTarget?.Invoke(weapon,weaponId)??new MyTuple<bool,bool,bool,MyEntity>();public float GetMaxPower(MyDefinitionId weaponDef)=>_getMaxPower?.Invoke(weaponDef)??0f;public bool HasAi(MyEntity entity)=>_hasAi?.Invoke(entity)??false;public float GetOptimalDps(MyEntity entity)=>_getOptimalDps?.Invoke(entity)??0f;public MyTuple<Vector3D,Vector3D,float,float,long,string>GetProjectileState(ulong projectileId)=>_getProjectileState?.Invoke(projectileId)??new MyTuple<Vector3D,Vector3D,float,float,long,string>();public float GetConstructEffectiveDps(MyEntity entity)=>_getConstructEffectiveDps?.Invoke(entity)??0f;public MyTuple<Vector3D,Vector3D>GetWeaponScope(MyEntity weapon,int weaponId)=>_getWeaponScope?.Invoke(weapon,weaponId)??new MyTuple<Vector3D,Vector3D>();public void AddProjectileCallback(MyEntity entity,int weaponId,Action<long,int,ulong,long,Vector3D,bool>action)=>_addProjectileMonitor?.Invoke(entity,weaponId,action);public void RemoveProjectileCallback(MyEntity entity,int weaponId,Action<long,int,ulong,long,Vector3D,bool>action)=>_removeProjectileMonitor?.Invoke(entity,weaponId,action);public MyTuple<bool,bool>IsInRange(MyEntity entity)=>_isInRange?.Invoke(entity)??new MyTuple<bool,bool>();public void SetProjectileState(ulong projectileId,MyTuple<bool,Vector3D,Vector3D,float>values)=>_setProjectileState?.Invoke(projectileId,values);internal bool IsWeaponShooting(MyEntity weaponBlock,int weaponId)=>_isWeaponShooting?.Invoke(weaponBlock,weaponId)??false;internal int GetShotsFired(MyEntity weaponBlock,int weaponId)=>_getShotsFired?.Invoke(weaponBlock,weaponId)??-1;internal void GetMuzzleInfo(MyEntity weaponBlock,int weaponId,List<MyTuple<Vector3D,Vector3D,Vector3D,Vector3D,MatrixD,MatrixD>>output)=>_getMuzzleInfo?.Invoke(weaponBlock,weaponId,output);public bool ToggleInfiniteResources(MyEntity entity)=>_toggoleInfiniteResources?.Invoke(entity)??false;public void MonitorEvents(MyEntity entity,int partId,Action<int,bool>action)=>_monitorEvents?.Invoke(entity,partId,action);public void UnMonitorEvents(MyEntity entity,int partId,Action<int,bool>action)=>_unmonitorEvents?.Invoke(entity,partId,action);public void RegisterDamageEvent(long modId,int type,Action<ListReader<MyTuple<ulong,long,int,MyEntity,MyEntity,ListReader<MyTuple<Vector3D,object,float>>>>>callback){_registerDamageEvent?.Invoke(modId,type,callback);}public void TargetFocushandler(long handledEntityId,bool unregister){_targetFocusHandler(handledEntityId,unregister,TargetFocusCallback);}private bool TargetFocusCallback(MyEntity target,IMyCharacter requestingCharacter,long handledEntityId,int modeCode){var mode=(ChangeMode)modeCode;return true;}public enum ChangeMode{Add,Release,Lock,}public void Hudhandler(long handledEntityId,bool unregister){_hudHandler?.Invoke(handledEntityId,unregister,HudCallback);}private bool HudCallback(IMyCharacter requestingCharacter,long handledEntityId,int modeCode){var mode=(HudMode)modeCode;return true;}internal enum HudMode{Selector,Reload,TargetInfo,Lead,Drone,PainterMarks,}public bool ShootRequest(MyEntity weaponEntity,object target,int weaponId=0,double additionalDeviateShotAngle=0)=>_shootRequest?.Invoke(weaponEntity,target,weaponId,additionalDeviateShotAngle)??false;public void ShootRequestHandler(long handledEntityId,bool unregister,Func<Vector3D,Vector3D,int,bool,object,int,int,int,bool>callback){_shootHandler?.Invoke(handledEntityId,unregister,callback);}private bool ShootCallBack(Vector3D scopePos,Vector3D scopeDirection,int requestState,bool hasLos,object target,int currentAmmo,int remainingMags,int requestStage){var stage=(EventTriggers)requestStage;var state=(ShootState)requestState;var targetAsEntity=target as MyEntity;var targetAsProjectileId=target as ulong???0;var targetAsPosition=target as Vector3D???Vector3D.Zero;return true;}public enum ShootState{EventStart,EventEnd,Preceding,Canceled,}public enum EventTriggers{Reloading,Firing,Tracking,Overheated,TurnOn,TurnOff,BurstReload,NoMagsToLoad,PreFire,EmptyOnGameLoad,StopFiring,StopTracking,LockDelay,Init,Homing,TargetAligned,WhileOn,TargetRanged100,TargetRanged75,TargetRanged50,TargetRanged25,}public MyTuple<MyDefinitionId,string,string,bool>GetMagazineMap(MyEntity weapon,int weaponId){return _getMagazineMap?.Invoke(weapon,weaponId)??new MyTuple<MyDefinitionId,string,string,bool>();}public bool SetMagazine(MyEntity weapon,int weaponId,MyDefinitionId id,bool forceReload){return _setMagazine?.Invoke(weapon,weaponId,id,forceReload)??false;}public bool ForceReload(MyEntity weapon,int weaponId){return _forceReload?.Invoke(weapon,weaponId)??false;}private const long Channel=67549756549;private bool _getWeaponDefinitions;private bool _isRegistered;private Action _readyCallback;public bool IsReady{get;private set;}public readonly List<WcApiDef.WeaponDefinition>WeaponDefinitions=new List<WcApiDef.WeaponDefinition>();public void Load(Action readyCallback=null,bool getWeaponDefinitions=false){if(_isRegistered)throw new Exception($"{GetType().Name}.Load() should not be called multiple times!");_readyCallback=readyCallback;_getWeaponDefinitions=getWeaponDefinitions;_isRegistered=true;MyAPIGateway.Utilities.RegisterMessageHandler(Channel,HandleMessage);MyAPIGateway.Utilities.SendModMessage(Channel,"ApiEndpointRequest");}public void Unload(){MyAPIGateway.Utilities.UnregisterMessageHandler(Channel,HandleMessage);ApiAssign(null);_isRegistered=false;_apiInit=false;IsReady=false;}private void HandleMessage(object obj){if(_apiInit||obj is string)return;var dict=obj as IReadOnlyDictionary<string,Delegate>;if(dict==null)return;ApiAssign(dict,_getWeaponDefinitions);IsReady=true;_readyCallback?.Invoke();}public void ApiAssign(IReadOnlyDictionary<string,Delegate>delegates,bool getWeaponDefinitions=false){_apiInit=(delegates!=null);try{AssignMethod(delegates,"SetRofMultiplier",ref _setRofMultiplier);AssignMethod(delegates,"SetBaseDmgMultiplier",ref _setBaseDmgMultiplier);AssignMethod(delegates,"SetAreaDmgMultiplier",ref _setAreaDmgMultiplier);AssignMethod(delegates,"SetAreaRadiusMultiplier",ref _setAreaRadiusMultiplier);AssignMethod(delegates,"SetVelocityMultiplier",ref _setVelocityMultiplier);AssignMethod(delegates,"SetFiringAllowed",ref _setFiringAllowed);AssignMethod(delegates,"GetRofMultiplier",ref _getRofMultiplier);AssignMethod(delegates,"GetBaseDmgMultiplier",ref _getBaseDmgMultiplier);AssignMethod(delegates,"GetAreaDmgMultiplier",ref _getAreaDmgMultiplier);AssignMethod(delegates,"GetAreaRadiusMultiplier",ref _getAreaRadiusMultiplier);AssignMethod(delegates,"GetVelocityMultiplier",ref _getVelocityMultiplier);AssignMethod(delegates,"GetFiringAllowed",ref _getFiringAllowed);}catch(Exception e){MyLog.Default.WriteLineAndConsole($"{e}");}AssignMethod(delegates,"GetAllWeaponDefinitions",ref _getAllWeaponDefinitions);AssignMethod(delegates,"GetCoreWeapons",ref _getCoreWeapons);AssignMethod(delegates,"GetNpcSafeWeapons",ref _getNpcSafeWeapons);AssignMethod(delegates,"GetAllWeaponMagazines",ref _getAllWeaponMagazines);AssignMethod(delegates,"GetAllNpcSafeWeaponMagazines",ref _getAllNpcSafeWeaponMagazines);AssignMethod(delegates,"GetCoreStaticLaunchers",ref _getCoreStaticLaunchers);AssignMethod(delegates,"GetCoreTurrets",ref _getCoreTurrets);AssignMethod(delegates,"GetCorePhantoms",ref _getCorePhantoms);AssignMethod(delegates,"GetCoreRifles",ref _getCoreRifles);AssignMethod(delegates,"GetCoreArmors",ref _getCoreArmors);AssignMethod(delegates,"GetBlockWeaponMap",ref _getBlockWeaponMap);AssignMethod(delegates,"GetSortedThreatsBase",ref _getSortedThreats);AssignMethod(delegates,"GetObstructionsBase",ref _getObstructions);AssignMethod(delegates,"GetMaxPower",ref _getMaxPower);AssignMethod(delegates,"GetProjectilesLockedOnBase",ref _getProjectilesLockedOn);AssignMethod(delegates,"GetProjectilesLockedOnPos",ref _getProjectilesLockedOnPos);AssignMethod(delegates,"GetAiFocusBase",ref _getAiFocus);AssignMethod(delegates,"SetAiFocusBase",ref _setAiFocus);AssignMethod(delegates,"ReleaseAiFocusBase",ref _releaseAiFocus);AssignMethod(delegates,"HasGridAiBase",ref _hasAi);AssignMethod(delegates,"GetOptimalDpsBase",ref _getOptimalDps);AssignMethod(delegates,"GetConstructEffectiveDpsBase",ref _getConstructEffectiveDps);AssignMethod(delegates,"IsInRangeBase",ref _isInRange);AssignMethod(delegates,"GetProjectileState",ref _getProjectileState);AssignMethod(delegates,"SetProjectileState",ref _setProjectileState);AssignMethod(delegates,"AddMonitorProjectile",ref _addProjectileMonitor);AssignMethod(delegates,"RemoveMonitorProjectile",ref _removeProjectileMonitor);AssignMethod(delegates,"TargetFocusHandler",ref _targetFocusHandler);AssignMethod(delegates,"HudHandler",ref _hudHandler);AssignMethod(delegates,"ShootHandler",ref _shootHandler);AssignMethod(delegates,"ShootRequest",ref _shootRequest);AssignMethod(delegates,"GetWeaponTargetBase",ref _getWeaponTarget);AssignMethod(delegates,"SetWeaponTargetBase",ref _setWeaponTarget);AssignMethod(delegates,"FireWeaponOnceBase",ref _fireWeaponOnce);AssignMethod(delegates,"ToggleWeaponFireBase",ref _toggleWeaponFire);AssignMethod(delegates,"IsWeaponReadyToFireBase",ref _isWeaponReadyToFire);AssignMethod(delegates,"GetMaxWeaponRangeBase",ref _getMaxWeaponRange);AssignMethod(delegates,"GetTurretTargetTypesBase",ref _getTurretTargetTypes);AssignMethod(delegates,"SetTurretTargetTypesBase",ref _setTurretTargetTypes);AssignMethod(delegates,"SetBlockTrackingRangeBase",ref _setBlockTrackingRange);AssignMethod(delegates,"IsTargetAlignedBase",ref _isTargetAligned);AssignMethod(delegates,"IsTargetAlignedExtendedBase",ref _isTargetAlignedExtended);AssignMethod(delegates,"CanShootTargetBase",ref _canShootTarget);AssignMethod(delegates,"GetPredictedTargetPositionBase",ref _getPredictedTargetPos);AssignMethod(delegates,"GetHeatLevelBase",ref _getHeatLevel);AssignMethod(delegates,"GetCurrentPowerBase",ref _currentPowerConsumption);AssignMethod(delegates,"DisableRequiredPowerBase",ref _disableRequiredPower);AssignMethod(delegates,"HasCoreWeaponBase",ref _hasCoreWeapon);AssignMethod(delegates,"GetActiveAmmoBase",ref _getActiveAmmo);AssignMethod(delegates,"SetActiveAmmoBase",ref _setActiveAmmo);AssignMethod(delegates,"GetPlayerControllerBase",ref _getPlayerController);AssignMethod(delegates,"GetWeaponAzimuthMatrixBase",ref _getWeaponAzimuthMatrix);AssignMethod(delegates,"GetWeaponElevationMatrixBase",ref _getWeaponElevationMatrix);AssignMethod(delegates,"IsTargetValidBase",ref _isTargetValid);AssignMethod(delegates,"GetWeaponScopeBase",ref _getWeaponScope);AssignMethod(delegates,"IsWeaponShootingBase",ref _isWeaponShooting);AssignMethod(delegates,"GetShotsFiredBase",ref _getShotsFired);AssignMethod(delegates,"GetMuzzleInfoBase",ref _getMuzzleInfo);AssignMethod(delegates,"ToggleInfiniteAmmoBase",ref _toggoleInfiniteResources);AssignMethod(delegates,"RegisterEventMonitor",ref _monitorEvents);AssignMethod(delegates,"UnRegisterEventMonitor",ref _unmonitorEvents);AssignMethod(delegates,"GetMagazineMap",ref _getMagazineMap);AssignMethod(delegates,"SetMagazine",ref _setMagazine);AssignMethod(delegates,"ForceReload",ref _forceReload);AssignMethod(delegates,"DamageHandler",ref _registerDamageEvent);if(getWeaponDefinitions){var byteArrays=new List<byte[]>();GetAllWeaponDefinitions(byteArrays);foreach(var byteArray in byteArrays)WeaponDefinitions.Add(MyAPIGateway.Utilities.SerializeFromBinary<WcApiDef.WeaponDefinition>(byteArray));}}private void AssignMethod<T>(IReadOnlyDictionary<string,Delegate>delegates,string name,ref T field)where T:class{if(delegates==null){field=null;return;}Delegate del;if(!delegates.TryGetValue(name,out del))throw new Exception($"{GetType().Name} :: Couldn't find {name} delegate of type {typeof(T)}");field=del as T;if(field==null)throw new Exception($"{GetType().Name} :: Delegate {name} is not type {typeof(T)}, instead it's: {del.GetType()}");}public class DamageHandlerHelper{public void YourCallBackFunction(List<ProjectileDamageEvent>list){}public void RegisterForDamage(long modId,EventType type){_wcApi.RegisterDamageEvent(modId,(int)type,DefaultCallBack);}private void DefaultCallBack(ListReader<MyTuple<ulong,long,int,MyEntity,MyEntity,ListReader<MyTuple<Vector3D,object,float>>>>listReader){YourCallBackFunction(ProcessEvents(listReader));CleanUpEvents();}private readonly List<ProjectileDamageEvent>_convertedObjects=new List<ProjectileDamageEvent>();private readonly Stack<List<ProjectileDamageEvent.ProHit>>_hitPool=new Stack<List<ProjectileDamageEvent.ProHit>>(256);private List<ProjectileDamageEvent>ProcessEvents(ListReader<MyTuple<ulong,long,int,MyEntity,MyEntity,ListReader<MyTuple<Vector3D,object,float>>>>projectiles){foreach(var p in projectiles){var hits=_hitPool.Count>0?_hitPool.Pop():new List<ProjectileDamageEvent.ProHit>();foreach(var hitObj in p.Item6){hits.Add(new ProjectileDamageEvent.ProHit{HitPosition=hitObj.Item1,ObjectHit=hitObj.Item2,Damage=hitObj.Item3});}_convertedObjects.Add(new ProjectileDamageEvent{ProId=p.Item1,PlayerId=p.Item2,WeaponId=p.Item3,WeaponEntity=p.Item4,WeaponParent=p.Item5,ObjectsHit=hits});}return _convertedObjects;}private void CleanUpEvents(){foreach(var p in _convertedObjects){p.ObjectsHit.Clear();_hitPool.Push(p.ObjectsHit);}_convertedObjects.Clear();}public struct ProjectileDamageEvent{public ulong ProId;public long PlayerId;public int WeaponId;public MyEntity WeaponEntity;public MyEntity WeaponParent;public List<ProHit>ObjectsHit;public struct ProHit{public Vector3D HitPosition;public object ObjectHit;public float Damage;}}private readonly WcApi _wcApi;public DamageHandlerHelper(WcApi wcApi){_wcApi=wcApi;}public enum EventType{Unregister,SystemWideDamageEvents,}}}}﻿using System;using System.Collections;using System.Collections.Generic;using System.Text;using Sandbox.ModAPI;namespace CoreSystems.Api{public partial class WcApi{private Func<IMyTerminalBlock,IDictionary<string,int>,bool>_getBlockWeaponMap;public bool GetBlockWeaponMap(IMyTerminalBlock weaponBlock,IDictionary<string,int>collection)=>_getBlockWeaponMap?.Invoke(weaponBlock,collection)??false;}}﻿using System;using System.Collections;using System.Collections.Generic;using System.Text;using ProtoBuf;using VRageMath;namespace CoreSystems.Api{public static class WcApiDef{[ProtoContract]public class ContainerDefinition{[ProtoMember(1)]internal WeaponDefinition[]WeaponDefs;[ProtoMember(2)]internal ArmorDefinition[]ArmorDefs;[ProtoMember(3)]internal UpgradeDefinition[]UpgradeDefs;[ProtoMember(4)]internal SupportDefinition[]SupportDefs;}[ProtoContract]public class ConsumeableDef{[ProtoMember(1)]internal string ItemName;[ProtoMember(2)]internal string InventoryItem;[ProtoMember(3)]internal int ItemsNeeded;[ProtoMember(4)]internal bool Hybrid;[ProtoMember(5)]internal float EnergyCost;[ProtoMember(6)]internal float Strength;}[ProtoContract]public class UpgradeDefinition{[ProtoMember(1)]internal ModelAssignmentsDef Assignments;[ProtoMember(2)]internal HardPointDef HardPoint;[ProtoMember(3)]internal WeaponDefinition.AnimationDef Animations;[ProtoMember(4)]internal string ModPath;[ProtoMember(5)]internal ConsumeableDef[]Consumable;[ProtoContract]public struct ModelAssignmentsDef{[ProtoMember(1)]internal MountPointDef[]MountPoints;[ProtoContract]public struct MountPointDef{[ProtoMember(1)]internal string SubtypeId;[ProtoMember(2)]internal float DurabilityMod;[ProtoMember(3)]internal string IconName;}}[ProtoContract]public struct HardPointDef{[ProtoMember(1)]internal string PartName;[ProtoMember(2)]internal HardwareDef HardWare;[ProtoMember(3)]internal UiDef Ui;[ProtoMember(4)]internal OtherDef Other;[ProtoContract]public struct UiDef{[ProtoMember(1)]internal bool StrengthModifier;}[ProtoContract]public struct HardwareDef{public enum HardwareType{Default,}[ProtoMember(1)]internal float InventorySize;[ProtoMember(2)]internal HardwareType Type;[ProtoMember(3)]internal int BlockDistance;}[ProtoContract]public struct OtherDef{[ProtoMember(1)]internal int ConstructPartCap;[ProtoMember(2)]internal int EnergyPriority;[ProtoMember(3)]internal bool Debug;[ProtoMember(4)]internal double RestrictionRadius;[ProtoMember(5)]internal bool CheckInflatedBox;[ProtoMember(6)]internal bool CheckForAnySupport;[ProtoMember(7)]internal bool StayCharged;}}}[ProtoContract]public class SupportDefinition{[ProtoMember(1)]internal ModelAssignmentsDef Assignments;[ProtoMember(2)]internal HardPointDef HardPoint;[ProtoMember(3)]internal WeaponDefinition.AnimationDef Animations;[ProtoMember(4)]internal string ModPath;[ProtoMember(5)]internal ConsumeableDef[]Consumable;[ProtoMember(6)]internal SupportEffect Effect;[ProtoContract]public struct ModelAssignmentsDef{[ProtoMember(1)]internal MountPointDef[]MountPoints;[ProtoContract]public struct MountPointDef{[ProtoMember(1)]internal string SubtypeId;[ProtoMember(2)]internal float DurabilityMod;[ProtoMember(3)]internal string IconName;}}[ProtoContract]public struct HardPointDef{[ProtoMember(1)]internal string PartName;[ProtoMember(2)]internal HardwareDef HardWare;[ProtoMember(3)]internal UiDef Ui;[ProtoMember(4)]internal OtherDef Other;[ProtoContract]public struct UiDef{[ProtoMember(1)]internal bool ProtectionControl;}[ProtoContract]public struct HardwareDef{[ProtoMember(1)]internal float InventorySize;}[ProtoContract]public struct OtherDef{[ProtoMember(1)]internal int ConstructPartCap;[ProtoMember(2)]internal int EnergyPriority;[ProtoMember(3)]internal bool Debug;[ProtoMember(4)]internal double RestrictionRadius;[ProtoMember(5)]internal bool CheckInflatedBox;[ProtoMember(6)]internal bool CheckForAnySupport;[ProtoMember(7)]internal bool StayCharged;}}[ProtoContract]public struct SupportEffect{public enum AffectedBlocks{Armor,ArmorPlus,PlusFunctional,All,}public enum Protections{KineticProt,EnergeticProt,GenericProt,Regenerate,Structural,}[ProtoMember(1)]internal Protections Protection;[ProtoMember(2)]internal AffectedBlocks Affected;[ProtoMember(3)]internal int BlockRange;[ProtoMember(4)]internal int MaxPoints;[ProtoMember(5)]internal int PointsPerCharge;[ProtoMember(6)]internal int UsablePerSecond;[ProtoMember(7)]internal int UsablePerMinute;[ProtoMember(8)]internal float Overflow;[ProtoMember(9)]internal float Effectiveness;[ProtoMember(10)]internal float ProtectionMin;[ProtoMember(11)]internal float ProtectionMax;}}[ProtoContract]public class ArmorDefinition{internal enum ArmorType{Light,Heavy,NonArmor,}[ProtoMember(1)]internal string[]SubtypeIds;[ProtoMember(2)]internal ArmorType Kind;[ProtoMember(3)]internal double KineticResistance;[ProtoMember(4)]internal double EnergeticResistance;}[ProtoContract]public class WeaponDefinition{[ProtoMember(1)]internal ModelAssignmentsDef Assignments;[ProtoMember(2)]internal TargetingDef Targeting;[ProtoMember(3)]internal AnimationDef Animations;[ProtoMember(4)]internal HardPointDef HardPoint;[ProtoMember(5)]internal AmmoDef[]Ammos;[ProtoMember(6)]internal string ModPath;[ProtoMember(7)]internal Dictionary<string,UpgradeValues[]>Upgrades;[ProtoContract]public struct ModelAssignmentsDef{[ProtoMember(1)]internal MountPointDef[]MountPoints;[ProtoMember(2)]internal string[]Muzzles;[ProtoMember(3)]internal string Ejector;[ProtoMember(4)]internal string Scope;[ProtoContract]public struct MountPointDef{[ProtoMember(1)]internal string SubtypeId;[ProtoMember(2)]internal string SpinPartId;[ProtoMember(3)]internal string MuzzlePartId;[ProtoMember(4)]internal string AzimuthPartId;[ProtoMember(5)]internal string ElevationPartId;[ProtoMember(6)]internal float DurabilityMod;[ProtoMember(7)]internal string IconName;}}[ProtoContract]public struct TargetingDef{public enum Threat{Projectiles,Characters,Grids,Neutrals,Meteors,Other,ScanNeutralGrid,ScanFriendlyGrid,ScanFriendlyCharacter,ScanRoid,ScanPlanet,ScanEnemyCharacter,ScanEnemyGrid,ScanNeutralCharacter,ScanUnOwnedGrid,ScanOwnersGrid}public enum BlockTypes{Any,Offense,Utility,Power,Production,Thrust,Jumping,Steering}[ProtoMember(1)]internal int TopTargets;[ProtoMember(2)]internal int TopBlocks;[ProtoMember(3)]internal double StopTrackingSpeed;[ProtoMember(4)]internal float MinimumDiameter;[ProtoMember(5)]internal float MaximumDiameter;[ProtoMember(6)]internal bool ClosestFirst;[ProtoMember(7)]internal BlockTypes[]SubSystems;[ProtoMember(8)]internal Threat[]Threats;[ProtoMember(9)]internal float MaxTargetDistance;[ProtoMember(10)]internal float MinTargetDistance;[ProtoMember(11)]internal bool IgnoreDumbProjectiles;[ProtoMember(12)]internal bool LockedSmartOnly;[ProtoMember(13)]internal bool UniqueTargetPerWeapon;[ProtoMember(14)]internal int MaxTrackingTime;[ProtoMember(15)]internal bool ShootBlanks;[ProtoMember(19)]internal CommunicationDef Communications;[ProtoMember(20)]internal bool FocusOnly;[ProtoMember(21)]internal bool EvictUniqueTargets;[ProtoMember(22)]internal int CycleTargets;[ProtoMember(23)]internal int CycleBlocks;[ProtoContract]public struct CommunicationDef{public enum Comms{NoComms,BroadCast,Relay,Jamming,RelayAndBroadCast,}public enum SecurityMode{Public,Private,Secure,}[ProtoMember(1)]internal bool StoreTargets;[ProtoMember(2)]internal int StorageLimit;[ProtoMember(3)]internal string StorageLocation;[ProtoMember(4)]internal Comms Mode;[ProtoMember(5)]internal SecurityMode Security;[ProtoMember(6)]internal string BroadCastChannel;[ProtoMember(7)]internal double BroadCastRange;[ProtoMember(8)]internal double JammingStrength;[ProtoMember(9)]internal string RelayChannel;[ProtoMember(10)]internal double RelayRange;[ProtoMember(11)]internal bool TargetPersists;[ProtoMember(12)]internal bool StoreLimitPerBlock;[ProtoMember(13)]internal int MaxConnections;}}[ProtoContract]public struct AnimationDef{[ProtoMember(1)]internal PartAnimationSetDef[]AnimationSets;[ProtoMember(2)]internal PartEmissive[]Emissives;[ProtoMember(3)]internal string[]HeatingEmissiveParts;[ProtoMember(4)]internal Dictionary<PartAnimationSetDef.EventTriggers,EventParticle[]>EventParticles;[ProtoContract(IgnoreListHandling=true)]public struct PartAnimationSetDef{public enum EventTriggers{Reloading,Firing,Tracking,Overheated,TurnOn,TurnOff,BurstReload,NoMagsToLoad,PreFire,EmptyOnGameLoad,StopFiring,StopTracking,LockDelay,}public enum ResetConditions{None,Home,Off,On,Reloaded}[ProtoMember(1)]internal string[]SubpartId;[ProtoMember(2)]internal string BarrelId;[ProtoMember(3)]internal uint StartupFireDelay;[ProtoMember(4)]internal Dictionary<EventTriggers,uint>AnimationDelays;[ProtoMember(5)]internal EventTriggers[]Reverse;[ProtoMember(6)]internal EventTriggers[]Loop;[ProtoMember(7)]internal Dictionary<EventTriggers,RelMove[]>EventMoveSets;[ProtoMember(8)]internal EventTriggers[]TriggerOnce;[ProtoMember(9)]internal EventTriggers[]ResetEmissives;[ProtoMember(10)]internal ResetConditions Resets;}[ProtoContract]public struct PartEmissive{[ProtoMember(1)]internal string EmissiveName;[ProtoMember(2)]internal string[]EmissivePartNames;[ProtoMember(3)]internal bool CycleEmissivesParts;[ProtoMember(4)]internal bool LeavePreviousOn;[ProtoMember(5)]internal Vector4[]Colors;[ProtoMember(6)]internal float[]IntensityRange;}[ProtoContract]public struct EventParticle{[ProtoMember(1)]internal string[]EmptyNames;[ProtoMember(2)]internal string[]MuzzleNames;[ProtoMember(3)]internal ParticleDef Particle;[ProtoMember(4)]internal uint StartDelay;[ProtoMember(5)]internal uint LoopDelay;[ProtoMember(6)]internal bool ForceStop;}[ProtoContract]internal struct RelMove{public enum MoveType{Linear,ExpoDecay,ExpoGrowth,Delay,Show,Hide,}[ProtoMember(1)]internal MoveType MovementType;[ProtoMember(2)]internal XYZ[]LinearPoints;[ProtoMember(3)]internal XYZ Rotation;[ProtoMember(4)]internal XYZ RotAroundCenter;[ProtoMember(5)]internal uint TicksToMove;[ProtoMember(6)]internal string CenterEmpty;[ProtoMember(7)]internal bool Fade;[ProtoMember(8)]internal string EmissiveName;[ProtoContract]internal struct XYZ{[ProtoMember(1)]internal double x;[ProtoMember(2)]internal double y;[ProtoMember(3)]internal double z;}}}[ProtoContract]public struct UpgradeValues{[ProtoMember(1)]internal string[]Ammo;[ProtoMember(2)]internal Dependency[]Dependencies;[ProtoMember(3)]internal int RateOfFireMod;[ProtoMember(4)]internal int BarrelsPerShotMod;[ProtoMember(5)]internal int ReloadMod;[ProtoMember(6)]internal int MaxHeatMod;[ProtoMember(7)]internal int HeatSinkRateMod;[ProtoMember(8)]internal int ShotsInBurstMod;[ProtoMember(9)]internal int DelayAfterBurstMod;[ProtoMember(10)]internal int AmmoPriority;[ProtoContract]public struct Dependency{internal string SubtypeId;internal int Quanity;}}[ProtoContract]public struct HardPointDef{public enum Prediction{Off,Basic,Accurate,Advanced,}[ProtoMember(1)]internal string PartName;[ProtoMember(2)]internal int DelayCeaseFire;[ProtoMember(3)]internal float DeviateShotAngle;[ProtoMember(4)]internal double AimingTolerance;[ProtoMember(5)]internal Prediction AimLeadingPrediction;[ProtoMember(6)]internal LoadingDef Loading;[ProtoMember(7)]internal AiDef Ai;[ProtoMember(8)]internal HardwareDef HardWare;[ProtoMember(9)]internal UiDef Ui;[ProtoMember(10)]internal HardPointAudioDef Audio;[ProtoMember(11)]internal HardPointParticleDef Graphics;[ProtoMember(12)]internal OtherDef Other;[ProtoMember(13)]internal bool AddToleranceToTracking;[ProtoMember(14)]internal bool CanShootSubmerged;[ProtoMember(15)]internal bool NpcSafe;[ProtoMember(16)]internal bool ScanTrackOnly;[ProtoContract]public struct LoadingDef{[ProtoMember(1)]internal int ReloadTime;[ProtoMember(2)]internal int RateOfFire;[ProtoMember(3)]internal int BarrelsPerShot;[ProtoMember(4)]internal int SkipBarrels;[ProtoMember(5)]internal int TrajectilesPerBarrel;[ProtoMember(6)]internal int HeatPerShot;[ProtoMember(7)]internal int MaxHeat;[ProtoMember(8)]internal int HeatSinkRate;[ProtoMember(9)]internal float Cooldown;[ProtoMember(10)]internal int DelayUntilFire;[ProtoMember(11)]internal int ShotsInBurst;[ProtoMember(12)]internal int DelayAfterBurst;[ProtoMember(13)]internal bool DegradeRof;[ProtoMember(14)]internal int BarrelSpinRate;[ProtoMember(15)]internal bool FireFull;[ProtoMember(16)]internal bool GiveUpAfter;[ProtoMember(17)]internal bool DeterministicSpin;[ProtoMember(18)]internal bool SpinFree;[ProtoMember(19)]internal bool StayCharged;[ProtoMember(20)]internal int MagsToLoad;[ProtoMember(21)]internal int MaxActiveProjectiles;[ProtoMember(22)]internal int MaxReloads;[ProtoMember(23)]internal bool GoHomeToReload;[ProtoMember(24)]internal bool DropTargetUntilLoaded;}[ProtoContract]public struct UiDef{[ProtoMember(1)]internal bool RateOfFire;[ProtoMember(2)]internal bool DamageModifier;[ProtoMember(3)]internal bool ToggleGuidance;[ProtoMember(4)]internal bool EnableOverload;[ProtoMember(5)]internal bool AlternateUi;[ProtoMember(6)]internal bool DisableStatus;}[ProtoContract]public struct AiDef{[ProtoMember(1)]internal bool TrackTargets;[ProtoMember(2)]internal bool TurretAttached;[ProtoMember(3)]internal bool TurretController;[ProtoMember(4)]internal bool PrimaryTracking;[ProtoMember(5)]internal bool LockOnFocus;[ProtoMember(6)]internal bool SuppressFire;[ProtoMember(7)]internal bool OverrideLeads;[ProtoMember(8)]internal int DefaultLeadGroup;[ProtoMember(9)]internal bool TargetGridCenter;}[ProtoContract]public struct HardwareDef{public enum HardwareType{BlockWeapon=0,HandWeapon=1,Phantom=6,}[ProtoMember(1)]internal float RotateRate;[ProtoMember(2)]internal float ElevateRate;[ProtoMember(3)]internal Vector3D Offset;[ProtoMember(4)]internal bool FixedOffset;[ProtoMember(5)]internal int MaxAzimuth;[ProtoMember(6)]internal int MinAzimuth;[ProtoMember(7)]internal int MaxElevation;[ProtoMember(8)]internal int MinElevation;[ProtoMember(9)]internal float InventorySize;[ProtoMember(10)]internal HardwareType Type;[ProtoMember(11)]internal int HomeAzimuth;[ProtoMember(12)]internal int HomeElevation;[ProtoMember(13)]internal CriticalDef CriticalReaction;[ProtoMember(14)]internal float IdlePower;[ProtoContract]public struct CriticalDef{[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal int DefaultArmedTimer;[ProtoMember(3)]internal bool PreArmed;[ProtoMember(4)]internal bool TerminalControls;[ProtoMember(5)]internal string AmmoRound;}}[ProtoContract]public struct HardPointAudioDef{[ProtoMember(1)]internal string ReloadSound;[ProtoMember(2)]internal string NoAmmoSound;[ProtoMember(3)]internal string HardPointRotationSound;[ProtoMember(4)]internal string BarrelRotationSound;[ProtoMember(5)]internal string FiringSound;[ProtoMember(6)]internal bool FiringSoundPerShot;[ProtoMember(7)]internal string PreFiringSound;[ProtoMember(8)]internal uint FireSoundEndDelay;[ProtoMember(9)]internal bool FireSoundNoBurst;}[ProtoContract]public struct OtherDef{[ProtoMember(1)]internal int ConstructPartCap;[ProtoMember(2)]internal int EnergyPriority;[ProtoMember(3)]internal int RotateBarrelAxis;[ProtoMember(4)]internal bool MuzzleCheck;[ProtoMember(5)]internal bool Debug;[ProtoMember(6)]internal double RestrictionRadius;[ProtoMember(7)]internal bool CheckInflatedBox;[ProtoMember(8)]internal bool CheckForAnyWeapon;[ProtoMember(9)]internal bool DisableLosCheck;[ProtoMember(10)]internal bool NoVoxelLosCheck;}[ProtoContract]public struct HardPointParticleDef{[ProtoMember(1)]internal ParticleDef Effect1;[ProtoMember(2)]internal ParticleDef Effect2;}}[ProtoContract]public class AmmoDef{[ProtoMember(1)]internal string AmmoMagazine;[ProtoMember(2)]internal string AmmoRound;[ProtoMember(3)]internal bool HybridRound;[ProtoMember(4)]internal float EnergyCost;[ProtoMember(5)]internal float BaseDamage;[ProtoMember(6)]internal float Mass;[ProtoMember(7)]internal float Health;[ProtoMember(8)]internal float BackKickForce;[ProtoMember(9)]internal DamageScaleDef DamageScales;[ProtoMember(10)]internal ShapeDef Shape;[ProtoMember(11)]internal ObjectsHitDef ObjectsHit;[ProtoMember(12)]internal TrajectoryDef Trajectory;[ProtoMember(13)]internal AreaDamageDef AreaEffect;[ProtoMember(14)]internal BeamDef Beams;[ProtoMember(15)]internal FragmentDef Fragment;[ProtoMember(16)]internal GraphicDef AmmoGraphics;[ProtoMember(17)]internal AmmoAudioDef AmmoAudio;[ProtoMember(18)]internal bool HardPointUsable;[ProtoMember(19)]internal PatternDef Pattern;[ProtoMember(20)]internal int EnergyMagazineSize;[ProtoMember(21)]internal float DecayPerShot;[ProtoMember(22)]internal EjectionDef Ejection;[ProtoMember(23)]internal bool IgnoreWater;[ProtoMember(24)]internal AreaOfDamageDef AreaOfDamage;[ProtoMember(25)]internal EwarDef Ewar;[ProtoMember(26)]internal bool IgnoreVoxels;[ProtoMember(27)]internal bool Synchronize;[ProtoMember(28)]internal double HeatModifier;[ProtoMember(29)]internal bool NpcSafe;[ProtoMember(30)]internal SynchronizeDef Sync;[ProtoMember(31)]internal bool NoGridOrArmorScaling;[ProtoContract]public struct SynchronizeDef{[ProtoMember(1)]internal bool Full;[ProtoMember(2)]internal bool PointDefense;[ProtoMember(3)]internal bool OnHitDeath;}[ProtoContract]public struct DamageScaleDef{[ProtoMember(1)]internal float MaxIntegrity;[ProtoMember(2)]internal bool DamageVoxels;[ProtoMember(3)]internal float Characters;[ProtoMember(4)]internal bool SelfDamage;[ProtoMember(5)]internal GridSizeDef Grids;[ProtoMember(6)]internal ArmorDef Armor;[ProtoMember(7)]internal CustomScalesDef Custom;[ProtoMember(8)]internal ShieldDef Shields;[ProtoMember(9)]internal FallOffDef FallOff;[ProtoMember(10)]internal double HealthHitModifier;[ProtoMember(11)]internal double VoxelHitModifier;[ProtoMember(12)]internal DamageTypes DamageType;[ProtoMember(13)]internal DeformDef Deform;[ProtoContract]public struct FallOffDef{[ProtoMember(1)]internal float Distance;[ProtoMember(2)]internal float MinMultipler;}[ProtoContract]public struct GridSizeDef{[ProtoMember(1)]internal float Large;[ProtoMember(2)]internal float Small;}[ProtoContract]public struct ArmorDef{[ProtoMember(1)]internal float Armor;[ProtoMember(2)]internal float Heavy;[ProtoMember(3)]internal float Light;[ProtoMember(4)]internal float NonArmor;}[ProtoContract]public struct CustomScalesDef{internal enum SkipMode{NoSkip,Inclusive,Exclusive,}[ProtoMember(1)]internal CustomBlocksDef[]Types;[ProtoMember(2)]internal bool IgnoreAllOthers;[ProtoMember(3)]internal SkipMode SkipOthers;}[ProtoContract]public struct DamageTypes{internal enum Damage{Energy,Kinetic,}[ProtoMember(1)]internal Damage Base;[ProtoMember(2)]internal Damage AreaEffect;[ProtoMember(3)]internal Damage Detonation;[ProtoMember(4)]internal Damage Shield;}[ProtoContract]public struct ShieldDef{internal enum ShieldType{Default,Heal,Bypass,EmpRetired,}[ProtoMember(1)]internal float Modifier;[ProtoMember(2)]internal ShieldType Type;[ProtoMember(3)]internal float BypassModifier;[ProtoMember(4)]internal double HeatModifier;}[ProtoContract]public struct DeformDef{internal enum DeformTypes{HitBlock,AllDamagedBlocks,NoDeform,}[ProtoMember(1)]internal DeformTypes DeformType;[ProtoMember(2)]internal int DeformDelay;}}[ProtoContract]public struct ShapeDef{public enum Shapes{LineShape,SphereShape,}[ProtoMember(1)]internal Shapes Shape;[ProtoMember(2)]internal double Diameter;}[ProtoContract]public struct ObjectsHitDef{[ProtoMember(1)]internal int MaxObjectsHit;[ProtoMember(2)]internal bool CountBlocks;}[ProtoContract]public struct CustomBlocksDef{[ProtoMember(1)]internal string SubTypeId;[ProtoMember(2)]internal float Modifier;}[ProtoContract]public struct GraphicDef{[ProtoMember(1)]internal bool ShieldHitDraw;[ProtoMember(2)]internal float VisualProbability;[ProtoMember(3)]internal string ModelName;[ProtoMember(4)]internal AmmoParticleDef Particles;[ProtoMember(5)]internal LineDef Lines;[ProtoMember(6)]internal DecalDef Decals;[ProtoContract]public struct AmmoParticleDef{[ProtoMember(1)]internal ParticleDef Ammo;[ProtoMember(2)]internal ParticleDef Hit;[ProtoMember(3)]internal ParticleDef Eject;}[ProtoContract]public struct LineDef{internal enum Texture{Normal,Cycle,Chaos,Wave,}public enum FactionColor{DontUse,Foreground,Background,}[ProtoMember(1)]internal TracerBaseDef Tracer;[ProtoMember(2)]internal string TracerMaterial;[ProtoMember(3)]internal Randomize ColorVariance;[ProtoMember(4)]internal Randomize WidthVariance;[ProtoMember(5)]internal TrailDef Trail;[ProtoMember(6)]internal OffsetEffectDef OffsetEffect;[ProtoMember(7)]internal bool DropParentVelocity;[ProtoContract]public struct OffsetEffectDef{[ProtoMember(1)]internal double MaxOffset;[ProtoMember(2)]internal double MinLength;[ProtoMember(3)]internal double MaxLength;}[ProtoContract]public struct TracerBaseDef{[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal float Length;[ProtoMember(3)]internal float Width;[ProtoMember(4)]internal Vector4 Color;[ProtoMember(5)]internal uint VisualFadeStart;[ProtoMember(6)]internal uint VisualFadeEnd;[ProtoMember(7)]internal SegmentDef Segmentation;[ProtoMember(8)]internal string[]Textures;[ProtoMember(9)]internal Texture TextureMode;[ProtoMember(10)]internal bool AlwaysDraw;[ProtoMember(11)]internal FactionColor FactionColor;[ProtoContract]public struct SegmentDef{[ProtoMember(1)]internal string Material;[ProtoMember(2)]internal double SegmentLength;[ProtoMember(3)]internal double SegmentGap;[ProtoMember(4)]internal double Speed;[ProtoMember(5)]internal Vector4 Color;[ProtoMember(6)]internal double WidthMultiplier;[ProtoMember(7)]internal bool Reverse;[ProtoMember(8)]internal bool UseLineVariance;[ProtoMember(9)]internal Randomize ColorVariance;[ProtoMember(10)]internal Randomize WidthVariance;[ProtoMember(11)]internal string[]Textures;[ProtoMember(12)]internal bool Enable;[ProtoMember(13)]internal FactionColor FactionColor;}}[ProtoContract]public struct TrailDef{[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal string Material;[ProtoMember(3)]internal int DecayTime;[ProtoMember(4)]internal Vector4 Color;[ProtoMember(5)]internal bool Back;[ProtoMember(6)]internal float CustomWidth;[ProtoMember(7)]internal bool UseWidthVariance;[ProtoMember(8)]internal bool UseColorFade;[ProtoMember(9)]internal string[]Textures;[ProtoMember(10)]internal Texture TextureMode;[ProtoMember(11)]internal bool AlwaysDraw;[ProtoMember(12)]internal FactionColor FactionColor;}}[ProtoContract]public struct DecalDef{[ProtoMember(1)]internal int MaxAge;[ProtoMember(2)]internal TextureMapDef[]Map;[ProtoContract]public struct TextureMapDef{[ProtoMember(1)]internal string HitMaterial;[ProtoMember(2)]internal string DecalMaterial;}}}[ProtoContract]public struct BeamDef{[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal bool ConvergeBeams;[ProtoMember(3)]internal bool VirtualBeams;[ProtoMember(4)]internal bool RotateRealBeam;[ProtoMember(5)]internal bool OneParticle;[ProtoMember(6)]internal bool FakeVoxelHits;}[ProtoContract]public struct FragmentDef{[ProtoMember(1)]internal string AmmoRound;[ProtoMember(2)]internal int Fragments;[ProtoMember(3)]internal float Radial;[ProtoMember(4)]internal float BackwardDegrees;[ProtoMember(5)]internal float Degrees;[ProtoMember(6)]internal bool Reverse;[ProtoMember(7)]internal bool IgnoreArming;[ProtoMember(8)]internal bool DropVelocity;[ProtoMember(9)]internal float Offset;[ProtoMember(10)]internal int MaxChildren;[ProtoMember(11)]internal TimedSpawnDef TimedSpawns;[ProtoMember(12)]internal bool FireSound;[ProtoMember(13)]internal Vector3D AdvOffset;[ProtoMember(14)]internal bool ArmWhenHit;[ProtoContract]public struct TimedSpawnDef{public enum PointTypes{Direct,Lead,Predict,}[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal int Interval;[ProtoMember(3)]internal int StartTime;[ProtoMember(4)]internal int MaxSpawns;[ProtoMember(5)]internal double Proximity;[ProtoMember(6)]internal bool ParentDies;[ProtoMember(7)]internal bool PointAtTarget;[ProtoMember(8)]internal int GroupSize;[ProtoMember(9)]internal int GroupDelay;[ProtoMember(10)]internal PointTypes PointType;}}[ProtoContract]public struct PatternDef{public enum PatternModes{Never,Weapon,Fragment,Both,}[ProtoMember(1)]internal string[]Patterns;[ProtoMember(2)]internal bool Enable;[ProtoMember(3)]internal float TriggerChance;[ProtoMember(4)]internal bool SkipParent;[ProtoMember(5)]internal bool Random;[ProtoMember(6)]internal int RandomMin;[ProtoMember(7)]internal int RandomMax;[ProtoMember(8)]internal int PatternSteps;[ProtoMember(9)]internal PatternModes Mode;}[ProtoContract]public struct EjectionDef{public enum SpawnType{Item,Particle,}[ProtoMember(1)]internal float Speed;[ProtoMember(2)]internal float SpawnChance;[ProtoMember(3)]internal SpawnType Type;[ProtoMember(4)]internal ComponentDef CompDef;[ProtoContract]public struct ComponentDef{[ProtoMember(1)]internal string ItemName;[ProtoMember(2)]internal int ItemLifeTime;[ProtoMember(3)]internal int Delay;}}[ProtoContract]public struct AreaOfDamageDef{public enum Falloff{Legacy,NoFalloff,Linear,Curve,InvCurve,Squeeze,Pooled,Exponential,}public enum AoeShape{Round,Diamond,}[ProtoMember(1)]internal ByBlockHitDef ByBlockHit;[ProtoMember(2)]internal EndOfLifeDef EndOfLife;[ProtoContract]public struct ByBlockHitDef{[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal double Radius;[ProtoMember(3)]internal float Damage;[ProtoMember(4)]internal float Depth;[ProtoMember(5)]internal float MaxAbsorb;[ProtoMember(6)]internal Falloff Falloff;[ProtoMember(7)]internal AoeShape Shape;}[ProtoContract]public struct EndOfLifeDef{[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal double Radius;[ProtoMember(3)]internal float Damage;[ProtoMember(4)]internal float Depth;[ProtoMember(5)]internal float MaxAbsorb;[ProtoMember(6)]internal Falloff Falloff;[ProtoMember(7)]internal bool ArmOnlyOnHit;[ProtoMember(8)]internal int MinArmingTime;[ProtoMember(9)]internal bool NoVisuals;[ProtoMember(10)]internal bool NoSound;[ProtoMember(11)]internal float ParticleScale;[ProtoMember(12)]internal string CustomParticle;[ProtoMember(13)]internal string CustomSound;[ProtoMember(14)]internal AoeShape Shape;}}[ProtoContract]public struct EwarDef{public enum EwarType{AntiSmart,JumpNull,EnergySink,Anchor,Emp,Offense,Nav,Dot,Push,Pull,Tractor,}public enum EwarMode{Effect,Field,}[ProtoMember(1)]internal bool Enable;[ProtoMember(2)]internal EwarType Type;[ProtoMember(3)]internal EwarMode Mode;[ProtoMember(4)]internal float Strength;[ProtoMember(5)]internal double Radius;[ProtoMember(6)]internal int Duration;[ProtoMember(7)]internal bool StackDuration;[ProtoMember(8)]internal bool Depletable;[ProtoMember(9)]internal int MaxStacks;[ProtoMember(10)]internal bool NoHitParticle;[ProtoMember(11)]internal PushPullDef Force;[ProtoMember(12)]internal FieldDef Field;[ProtoContract]public struct FieldDef{[ProtoMember(1)]internal int Interval;[ProtoMember(2)]internal int PulseChance;[ProtoMember(3)]internal int GrowTime;[ProtoMember(4)]internal bool HideModel;[ProtoMember(5)]internal bool ShowParticle;[ProtoMember(6)]internal double TriggerRange;[ProtoMember(7)]internal ParticleDef Particle;}[ProtoContract]public struct PushPullDef{public enum Force{ProjectileLastPosition,ProjectileOrigin,HitPosition,TargetCenter,TargetCenterOfMass,}[ProtoMember(1)]internal Force ForceFrom;[ProtoMember(2)]internal Force ForceTo;[ProtoMember(3)]internal Force Position;[ProtoMember(4)]internal bool DisableRelativeMass;[ProtoMember(5)]internal double TractorRange;[ProtoMember(6)]internal bool ShooterFeelsForce;}}[ProtoContract]public struct AreaDamageDef{public enum AreaEffectType{Disabled,Explosive,Radiant,AntiSmart,JumpNullField,EnergySinkField,AnchorField,EmpField,OffenseField,NavField,DotField,PushField,PullField,TractorField,}[ProtoMember(1)]internal double AreaEffectRadius;[ProtoMember(2)]internal float AreaEffectDamage;[ProtoMember(3)]internal AreaEffectType AreaEffect;[ProtoMember(4)]internal PulseDef Pulse;[ProtoMember(5)]internal DetonateDef Detonation;[ProtoMember(6)]internal ExplosionDef Explosions;[ProtoMember(7)]internal EwarFieldsDef EwarFields;[ProtoMember(8)]internal AreaInfluence Base;[ProtoContract]public struct AreaInfluence{[ProtoMember(1)]internal double Radius;[ProtoMember(2)]internal float EffectStrength;}[ProtoContract]public struct PulseDef{[ProtoMember(1)]internal int Interval;[ProtoMember(2)]internal int PulseChance;[ProtoMember(3)]internal int GrowTime;[ProtoMember(4)]internal bool HideModel;[ProtoMember(5)]internal bool ShowParticle;[ProtoMember(6)]internal ParticleDef Particle;}[ProtoContract]public struct EwarFieldsDef{[ProtoMember(1)]internal int Duration;[ProtoMember(2)]internal bool StackDuration;[ProtoMember(3)]internal bool Depletable;[ProtoMember(4)]internal double TriggerRange;[ProtoMember(5)]internal int MaxStacks;[ProtoMember(6)]internal PushPullDef Force;[ProtoMember(7)]internal bool DisableParticleEffect;[ProtoContract]public struct PushPullDef{public enum Force{ProjectileLastPosition,ProjectileOrigin,HitPosition,TargetCenter,TargetCenterOfMass,}[ProtoMember(1)]internal Force ForceFrom;[ProtoMember(2)]internal Force ForceTo;[ProtoMember(3)]internal Force Position;[ProtoMember(4)]internal bool DisableRelativeMass;[ProtoMember(5)]internal double TractorRange;[ProtoMember(6)]internal bool ShooterFeelsForce;}}[ProtoContract]public struct DetonateDef{[ProtoMember(1)]internal bool DetonateOnEnd;[ProtoMember(2)]internal bool ArmOnlyOnHit;[ProtoMember(3)]internal float DetonationRadius;[ProtoMember(4)]internal float DetonationDamage;[ProtoMember(5)]internal int MinArmingTime;}[ProtoContract]public struct ExplosionDef{[ProtoMember(1)]internal bool NoVisuals;[ProtoMember(2)]internal bool NoSound;[ProtoMember(3)]internal float Scale;[ProtoMember(4)]internal string CustomParticle;[ProtoMember(5)]internal string CustomSound;[ProtoMember(6)]internal bool NoShrapnel;[ProtoMember(7)]internal bool NoDeformation;}}[ProtoContract]public struct AmmoAudioDef{[ProtoMember(1)]internal string TravelSound;[ProtoMember(2)]internal string HitSound;[ProtoMember(3)]internal float HitPlayChance;[ProtoMember(4)]internal bool HitPlayShield;[ProtoMember(5)]internal string VoxelHitSound;[ProtoMember(6)]internal string PlayerHitSound;[ProtoMember(7)]internal string FloatingHitSound;[ProtoMember(8)]internal string ShieldHitSound;[ProtoMember(9)]internal string ShotSound;}[ProtoContract]public struct TrajectoryDef{internal enum GuidanceType{None,Remote,TravelTo,Smart,DetectTravelTo,DetectSmart,DetectFixed,DroneAdvanced,}[ProtoMember(1)]internal float MaxTrajectory;[ProtoMember(2)]internal float AccelPerSec;[ProtoMember(3)]internal float DesiredSpeed;[ProtoMember(4)]internal float TargetLossDegree;[ProtoMember(5)]internal int TargetLossTime;[ProtoMember(6)]internal int MaxLifeTime;[ProtoMember(7)]internal int DeaccelTime;[ProtoMember(8)]internal Randomize SpeedVariance;[ProtoMember(9)]internal Randomize RangeVariance;[ProtoMember(10)]internal GuidanceType Guidance;[ProtoMember(11)]internal SmartsDef Smarts;[ProtoMember(12)]internal MinesDef Mines;[ProtoMember(13)]internal float GravityMultiplier;[ProtoMember(14)]internal uint MaxTrajectoryTime;[ProtoMember(15)]internal ApproachDef[]Approaches;[ProtoMember(16)]internal double TotalAcceleration;[ProtoContract]public struct SmartsDef{[ProtoMember(1)]internal double Inaccuracy;[ProtoMember(2)]internal double Aggressiveness;[ProtoMember(3)]internal double MaxLateralThrust;[ProtoMember(4)]internal double TrackingDelay;[ProtoMember(5)]internal int MaxChaseTime;[ProtoMember(6)]internal bool OverideTarget;[ProtoMember(7)]internal int MaxTargets;[ProtoMember(8)]internal bool NoTargetExpire;[ProtoMember(9)]internal bool Roam;[ProtoMember(10)]internal bool KeepAliveAfterTargetLoss;[ProtoMember(11)]internal float OffsetRatio;[ProtoMember(12)]internal int OffsetTime;[ProtoMember(13)]internal bool CheckFutureIntersection;[ProtoMember(14)]internal double NavAcceleration;[ProtoMember(15)]internal bool AccelClearance;[ProtoMember(16)]internal double SteeringLimit;[ProtoMember(17)]internal bool FocusOnly;[ProtoMember(18)]internal double OffsetMinRange;[ProtoMember(19)]internal bool FocusEviction;[ProtoMember(20)]internal double ScanRange;[ProtoMember(21)]internal bool NoSteering;[ProtoMember(22)]internal double FutureIntersectionRange;[ProtoMember(23)]internal double MinTurnSpeed;[ProtoMember(24)]internal bool NoTargetApproach;[ProtoMember(25)]internal bool AltNavigation;}[ProtoContract]public struct ApproachDef{public enum ReInitCondition{Wait,MoveToPrevious,MoveToNext,ForceRestart,}public enum Conditions{Ignore,Spawn,DistanceFromPositionC,Lifetime,DesiredElevation,MinTravelRequired,MaxTravelRequired,Deadtime,DistanceToPositionC,NextTimedSpawn,RelativeLifetime,RelativeDeadtime,SinceTimedSpawn,RelativeSpawns,EnemyTargetLoss,RelativeHealthLost,HealthRemaining,DistanceFromPositionB,DistanceToPositionB,DistanceFromTarget,DistanceToTarget,DistanceFromEndTrajectory,DistanceToEndTrajectory,}public enum UpRelativeTo{UpRelativeToBlock,UpRelativeToGravity,UpTargetDirection,UpTargetVelocity,UpStoredStartDontUse,UpStoredEndDontUse,UpStoredStartPosition,UpStoredEndPosition,UpStoredStartLocalPosition,UpStoredEndLocalPosition,UpRelativeToShooter,UpOriginDirection,UpElevationDirection,}public enum FwdRelativeTo{ForwardElevationDirection,ForwardRelativeToBlock,ForwardRelativeToGravity,ForwardTargetDirection,ForwardTargetVelocity,ForwardStoredStartDontUse,ForwardStoredEndDontUse,ForwardStoredStartPosition,ForwardStoredEndPosition,ForwardStoredStartLocalPosition,ForwardStoredEndLocalPosition,ForwardRelativeToShooter,ForwardOriginDirection,}public enum RelativeTo{Origin,Shooter,Target,Surface,MidPoint,PositionA,Nothing,StoredStartDontUse,StoredEndDontUse,StoredStartPosition,StoredEndPosition,StoredStartLocalPosition,StoredEndLocalPosition,}public enum ConditionOperators{StartEnd_And,StartEnd_Or,StartAnd_EndOr,StartOr_EndAnd,}public enum StageEvents{DoNothing,EndProjectile,EndProjectileOnRestart,StoreDontUse,StorePositionDontUse,Refund,StorePositionA,StorePositionB,StorePositionC,}[ProtoContract]public struct WeightedIdListDef{[ProtoMember(1)]public int ApproachId;[ProtoMember(2)]public Randomize Weight;[ProtoMember(3)]public double End1WeightMod;[ProtoMember(4)]public double End2WeightMod;[ProtoMember(5)]public int MaxRuns;[ProtoMember(6)]public double End3WeightMod;}[ProtoMember(1)]internal ReInitCondition RestartCondition;[ProtoMember(2)]internal Conditions StartCondition1;[ProtoMember(3)]internal Conditions EndCondition1;[ProtoMember(4)]internal UpRelativeTo Up;[ProtoMember(5)]internal RelativeTo PositionB;[ProtoMember(6)]internal double AngleOffset;[ProtoMember(7)]internal double Start1Value;[ProtoMember(8)]internal double End1Value;[ProtoMember(9)]internal double LeadDistance;[ProtoMember(10)]internal double DesiredElevation;[ProtoMember(11)]internal double AccelMulti;[ProtoMember(12)]internal double SpeedCapMulti;[ProtoMember(13)]internal bool AdjustPositionC;[ProtoMember(14)]internal bool CanExpireOnceStarted;[ProtoMember(15)]internal ParticleDef AlternateParticle;[ProtoMember(16)]internal string AlternateSound;[ProtoMember(17)]internal string AlternateModel;[ProtoMember(18)]internal int OnRestartRevertTo;[ProtoMember(19)]internal ParticleDef StartParticle;[ProtoMember(20)]internal bool AdjustPositionB;[ProtoMember(21)]internal bool AdjustUp;[ProtoMember(22)]internal bool PushLeadByTravelDistance;[ProtoMember(23)]internal double TrackingDistance;[ProtoMember(24)]internal Conditions StartCondition2;[ProtoMember(25)]internal double Start2Value;[ProtoMember(26)]internal Conditions EndCondition2;[ProtoMember(27)]internal double End2Value;[ProtoMember(28)]internal RelativeTo Elevation;[ProtoMember(29)]internal double ElevationTolerance;[ProtoMember(30)]internal ConditionOperators Operators;[ProtoMember(31)]internal StageEvents StartEvent;[ProtoMember(32)]internal StageEvents EndEvent;[ProtoMember(33)]internal double TotalAccelMulti;[ProtoMember(34)]internal double DeAccelMulti;[ProtoMember(35)]internal bool Orbit;[ProtoMember(36)]internal double OrbitRadius;[ProtoMember(37)]internal int OffsetTime;[ProtoMember(38)]internal double OffsetMinRadius;[ProtoMember(39)]internal bool NoTimedSpawns;[ProtoMember(40)]internal double OffsetMaxRadius;[ProtoMember(41)]internal bool ForceRestart;[ProtoMember(42)]internal RelativeTo PositionC;[ProtoMember(43)]internal bool DisableAvoidance;[ProtoMember(44)]internal int StoredStartId;[ProtoMember(45)]internal int StoredEndId;[ProtoMember(46)]internal WeightedIdListDef[]RestartList;[ProtoMember(47)]internal RelativeTo StoredStartType;[ProtoMember(48)]internal RelativeTo StoredEndType;[ProtoMember(49)]internal bool LeadRotateElevatePositionB;[ProtoMember(50)]internal bool LeadRotateElevatePositionC;[ProtoMember(51)]internal bool NoElevationLead;[ProtoMember(52)]internal bool IgnoreAntiSmart;[ProtoMember(53)]internal double HeatRefund;[ProtoMember(54)]internal Randomize AngleVariance;[ProtoMember(55)]internal bool ReloadRefund;[ProtoMember(56)]internal int ModelRotateTime;[ProtoMember(57)]internal FwdRelativeTo Forward;[ProtoMember(58)]internal bool AdjustForward;[ProtoMember(59)]internal bool ToggleIngoreVoxels;[ProtoMember(60)]internal bool SelfAvoidance;[ProtoMember(61)]internal bool TargetAvoidance;[ProtoMember(62)]internal bool SelfPhasing;[ProtoMember(63)]internal bool TrajectoryRelativeToB;[ProtoMember(64)]internal Conditions EndCondition3;[ProtoMember(65)]internal double End3Value;[ProtoMember(66)]internal bool SwapNavigationType;[ProtoMember(67)]internal bool ElevationRelativeToC;}[ProtoContract]public struct MinesDef{[ProtoMember(1)]internal double DetectRadius;[ProtoMember(2)]internal double DeCloakRadius;[ProtoMember(3)]internal int FieldTime;[ProtoMember(4)]internal bool Cloak;[ProtoMember(5)]internal bool Persist;}}[ProtoContract]public struct Randomize{[ProtoMember(1)]internal float Start;[ProtoMember(2)]internal float End;}}[ProtoContract]public struct ParticleOptionDef{[ProtoMember(1)]internal float Scale;[ProtoMember(2)]internal float MaxDistance;[ProtoMember(3)]internal float MaxDuration;[ProtoMember(4)]internal bool Loop;[ProtoMember(5)]internal bool Restart;[ProtoMember(6)]internal float HitPlayChance;}[ProtoContract]public struct ParticleDef{[ProtoMember(1)]internal string Name;[ProtoMember(2)]internal Vector4 Color;[ProtoMember(3)]internal Vector3D Offset;[ProtoMember(4)]internal ParticleOptionDef Extras;[ProtoMember(5)]internal bool ApplyToShield;[ProtoMember(6)]internal bool DisableCameraCulling;}}}}﻿namespace Starcore.FieldGenerator{public abstract class ComponentBase{public string ComponentId;public virtual void Init(string id){ComponentId=id;}public abstract void Close();public abstract void UpdateTick();}}﻿using System;using System.Collections.Generic;using System.Linq;using Sandbox.ModAPI;using VRage.Game.ModAPI;namespace Starcore.FieldGenerator.Networking{public class HeartNetwork:ComponentBase{public static HeartNetwork I;private int _networkLoadUpdate;public int NetworkLoadTicks=240;private readonly List<IMyPlayer>TempPlayers=new List<IMyPlayer>();public Dictionary<Type,int>TypeNetworkLoad=new Dictionary<Type,int>();public ushort NetworkId{get;private set;}public int TotalNetworkLoad{get;private set;}private Dictionary<long,DateTime>_rateLimiter=new Dictionary<long,DateTime>();public override void Init(string id){base.Init(id);I=this;NetworkId=20877;MyAPIGateway.Multiplayer.RegisterSecureMessageHandler(NetworkId,ReceivedPacket);foreach(var type in PacketBase.PacketTypes)TypeNetworkLoad.Add(type,0);}public override void UpdateTick(){_networkLoadUpdate--;if(_networkLoadUpdate<=0){_networkLoadUpdate=NetworkLoadTicks;TotalNetworkLoad=0;foreach(var networkLoadArray in TypeNetworkLoad.Keys.ToArray()){TotalNetworkLoad+=TypeNetworkLoad[networkLoadArray];TypeNetworkLoad[networkLoadArray]=0;}TotalNetworkLoad/=NetworkLoadTicks/60;ctr++;if(ctr%4==0){Log.Info($"Network Load: {TotalNetworkLoad}");}}}public override void Close(){MyAPIGateway.Multiplayer.UnregisterSecureMessageHandler(NetworkId,ReceivedPacket);I=null;}public static bool CheckRateLimit(long id,double delayMs=5000/60d){if(I==null)throw new Exception("Null HeartNetwork.I!");DateTime originalTime;DateTime nowTime=DateTime.Now;if(!I._rateLimiter.TryGetValue(id,out originalTime)||(nowTime-originalTime).TotalMilliseconds>=delayMs){I._rateLimiter[id]=nowTime;return true;}return false;}public KeyValuePair<Type,int>HighestNetworkLoad(){Type highest=null;foreach(var networkLoadArray in TypeNetworkLoad)if(highest==null||networkLoadArray.Value>TypeNetworkLoad[highest])highest=networkLoadArray.Key;return new KeyValuePair<Type,int>(highest,TypeNetworkLoad[highest]);}public void SendToPlayer(PacketBase packet,ulong playerSteamId,byte[]serialized=null){RelayToClient(packet,playerSteamId,MyAPIGateway.Session?.Player?.SteamUserId??0,serialized);}public void SendToEveryone(PacketBase packet,byte[]serialized=null){RelayToClients(packet,MyAPIGateway.Session?.Player?.SteamUserId??0,serialized);}public void SendToServer(PacketBase packet,byte[]serialized=null){RelayToServer(packet,MyAPIGateway.Session?.Player?.SteamUserId??0,serialized);}private int ctr=0;private void ReceivedPacket(ushort channelId,byte[]serialized,ulong senderSteamId,bool isSenderServer){try{var packet=MyAPIGateway.Utilities.SerializeFromBinary<PacketBase>(serialized);TypeNetworkLoad[packet.GetType()]+=serialized.Length;HandlePacket(packet,senderSteamId);}catch(Exception ex){Log.Error(ex,"[RepairModule] Error in HeatNetwork Sync! See Log for more Details!");}}private void HandlePacket(PacketBase packet,ulong senderSteamId){packet.Received(senderSteamId);}private void RelayToClients(PacketBase packet,ulong senderSteamId=0,byte[]serialized=null){if(!MyAPIGateway.Multiplayer.IsServer)return;TempPlayers.Clear();MyAPIGateway.Players.GetPlayers(TempPlayers);foreach(var p in TempPlayers){if(p.SteamUserId==MyAPIGateway.Multiplayer.ServerId||p.SteamUserId==senderSteamId)continue;if(serialized==null)serialized=MyAPIGateway.Utilities.SerializeToBinary(packet);MyAPIGateway.Multiplayer.SendMessageTo(NetworkId,serialized,p.SteamUserId);}TempPlayers.Clear();}private void RelayToClient(PacketBase packet,ulong playerSteamId,ulong senderSteamId,byte[]serialized=null){if(playerSteamId==MyAPIGateway.Multiplayer.ServerId||playerSteamId==senderSteamId)return;if(serialized==null)serialized=MyAPIGateway.Utilities.SerializeToBinary(packet);MyAPIGateway.Multiplayer.SendMessageTo(NetworkId,serialized,playerSteamId);}private void RelayToServer(PacketBase packet,ulong senderSteamId=0,byte[]serialized=null){if(senderSteamId==MyAPIGateway.Multiplayer.ServerId)return;if(serialized==null)serialized=MyAPIGateway.Utilities.SerializeToBinary(packet);MyAPIGateway.Multiplayer.SendMessageToServer(NetworkId,serialized);}}}﻿using System;using ProtoBuf;using Starcore.FieldGenerator.Networking.Custom;namespace Starcore.FieldGenerator.Networking{[ProtoContract(UseProtoMembersOnly=true)][ProtoInclude(1,typeof(BoolSyncPacket))][ProtoInclude(2,typeof(IntSyncPacket))][ProtoInclude(3,typeof(FloatSyncPacket))]public abstract class PacketBase{public static readonly Type[]PacketTypes={typeof(PacketBase),typeof(BoolSyncPacket),typeof(IntSyncPacket),typeof(FloatSyncPacket),};public abstract void Received(ulong SenderSteamId);}}﻿using System;using System.Collections.Generic;using System.Linq;using System.Text;using ProtoBuf;using Starcore.FieldGenerator.Networking.Custom;namespace Starcore.FieldGenerator.Networking{public class PacketQueueManager{public static PacketQueueManager I;private Dictionary<long,LinkedList<PacketBase>>packetQueues=new Dictionary<long,LinkedList<PacketBase>>();private List<long>entityIds=new List<long>();public void Init(){I=this;}public void Close(){I=null;}public bool QueuesWithPackets(){return entityIds.Count>0;}public void EnqueuePacket(PacketBase packet){long entityId=GetEntityId(packet);if(!packetQueues.ContainsKey(entityId)){packetQueues[entityId]=new LinkedList<PacketBase>();entityIds.Add(entityId);}string propertyName=GetPropertyName(packet);RemoveStalePackets(packetQueues[entityId],propertyName);packetQueues[entityId].AddLast(packet);}public void DequeuePacket(long entityID){if(packetQueues.ContainsKey(entityID)&&packetQueues[entityID].Count>0){packetQueues[entityID].RemoveFirst();}if(!EntityHasPackets(entityID)){entityIds.Remove(entityID);}}public IEnumerable<long>EntitiesWithQueue(){foreach(var entry in packetQueues){if(entry.Value.Count>0)yield return entry.Key;}}public PacketBase FirstInQueue(long entityID){if(packetQueues.ContainsKey(entityID)&&packetQueues[entityID].Count>0){return packetQueues[entityID].First.Value;}return null;}private void RemoveStalePackets(LinkedList<PacketBase>list,string propertyName){var currentNode=list.First;while(currentNode!=null){var nextNode=currentNode.Next;if(GetPropertyName(currentNode.Value)==propertyName){list.Remove(currentNode);}currentNode=nextNode;}}private bool EntityHasPackets(long entityID){return packetQueues.ContainsKey(entityID)||packetQueues[entityID].Count!=0;}private long GetEntityId(PacketBase packet){if(packet.GetType()==typeof(FloatSyncPacket))return((FloatSyncPacket)packet).entityId;if(packet.GetType()==typeof(IntSyncPacket))return((IntSyncPacket)packet).entityId;if(packet.GetType()==typeof(BoolSyncPacket))return((BoolSyncPacket)packet).entityId;return 0;}private string GetPropertyName(PacketBase packet){if(packet.GetType()==typeof(FloatSyncPacket))return((FloatSyncPacket)packet).propertyName;if(packet.GetType()==typeof(IntSyncPacket))return((IntSyncPacket)packet).propertyName;if(packet.GetType()==typeof(BoolSyncPacket))return((BoolSyncPacket)packet).propertyName;return string.Empty;}}}﻿using System;using ProtoBuf;using Sandbox.ModAPI;namespace Starcore.FieldGenerator.Networking.Custom{[ProtoContract]public class BoolSyncPacket:PacketBase{[ProtoMember(21)]public string propertyName;[ProtoMember(22)]private bool value;[ProtoMember(23)]public long entityId;public override void Received(ulong SenderSteamId){Log.Info($"Received Bool Sync: {propertyName} = {value}");var fieldGenerator=FieldGenerator.GetLogic<FieldGenerator>(entityId);if(fieldGenerator!=null){switch(propertyName){case nameof(FieldGenerator.SiegeMode):fieldGenerator.SiegeMode=value;break;case nameof(FieldGenerator.SiegeCooldownActive):fieldGenerator.SiegeCooldownActive=value;break;}if(MyAPIGateway.Session.IsServer){HeartNetwork.I.SendToEveryone(this);}}else{Log.Info($"Received method failed: FieldGenerator is null. Entity ID: {entityId}");}}public static void SyncBoolProperty(long entityId,string propertyName,bool value){try{var packet=new BoolSyncPacket{entityId=entityId,propertyName=propertyName,value=value};Log.Info($"Bool-Type Packet Added to Queue: {propertyName} = {value}");PacketQueueManager.I.EnqueuePacket(packet);}catch(Exception ex){Log.Error(ex);}}}}﻿using System;using System.Collections.Generic;using ProtoBuf;using Sandbox.ModAPI;namespace Starcore.FieldGenerator.Networking.Custom{[ProtoContract]public class FloatSyncPacket:PacketBase{[ProtoMember(31)]public string propertyName;[ProtoMember(32)]private float value;[ProtoMember(33)]public long entityId;public override void Received(ulong SenderSteamId){Log.Info($"Received Float Sync: {propertyName} = {value}");var fieldGenerator=FieldGenerator.GetLogic<FieldGenerator>(entityId);if(fieldGenerator!=null){switch(propertyName){case nameof(FieldGenerator.FieldPower):fieldGenerator.FieldPower=value;break;case nameof(FieldGenerator.MaxFieldPower):fieldGenerator.MaxFieldPower=value;break;case nameof(FieldGenerator.MinFieldPower):fieldGenerator.MinFieldPower=value;break;case nameof(FieldGenerator.SizeModifier):fieldGenerator.SizeModifier=value;break;case nameof(FieldGenerator.Stability):fieldGenerator.Stability=value;break;}if(MyAPIGateway.Session.IsServer){HeartNetwork.I.SendToEveryone(this);}}else{Log.Info($"Received method failed: FieldGenerator is null. Entity ID: {entityId}");}}public static void SyncFloatProperty(long entityId,string propertyName,float value){try{var packet=new FloatSyncPacket{entityId=entityId,propertyName=propertyName,value=value};Log.Info($"Float-Type Packet Added to Queue: {propertyName} = {value}");PacketQueueManager.I.EnqueuePacket(packet);}catch(Exception ex){Log.Error(ex);}}}}﻿using System;using ProtoBuf;using Sandbox.ModAPI;namespace Starcore.FieldGenerator.Networking.Custom{[ProtoContract]public class IntSyncPacket:PacketBase{[ProtoMember(41)]public string propertyName;[ProtoMember(42)]private int value;[ProtoMember(43)]public long entityId;public override void Received(ulong SenderSteamId){Log.Info($"Received Int Sync: {propertyName} = {value}");var fieldGenerator=FieldGenerator.GetLogic<FieldGenerator>(entityId);if(fieldGenerator!=null){switch(propertyName){case nameof(FieldGenerator.SiegeElapsedTime):fieldGenerator.SiegeElapsedTime=value;break;case nameof(FieldGenerator.SiegeCooldownTime):fieldGenerator.SiegeCooldownTime=value;break;}if(MyAPIGateway.Session.IsServer){HeartNetwork.I.SendToEveryone(this);}}else{Log.Info($"Received method failed: FieldGenerator is null. Entity ID: {entityId}");}}public static void SyncIntProperty(long entityId,string propertyName,int value){try{var packet=new IntSyncPacket{entityId=entityId,propertyName=propertyName,value=value};Log.Info($"Int-Type Packet Added to Queue: {propertyName} = {value}");PacketQueueManager.I.EnqueuePacket(packet);}catch(Exception ex){Log.Error(ex);}}}}﻿
