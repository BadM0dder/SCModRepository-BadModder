using System.Collections.Generic;
using VRageMath;
using static MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication.DefinitionDefs;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies
{
    internal partial class ModularDefinition
    {
        // You can declare functions in here, and they are shared between all other ModularDefinition files.

        // This is the important bit.
        private PhysicalDefinition Modular_Fusion => new PhysicalDefinition
        {
            // Unique name of the definition.
            Name = "Modular_Fusion",

            OnInit = () => { S_FusionManager.I.Definition = this; },

            // Triggers whenever a new part is added to an assembly.
            OnPartAdd = S_FusionManager.I.OnPartAdd,

            // Triggers whenever a part is removed from an assembly.
            OnPartRemove = S_FusionManager.I.OnPartRemove,

            // Triggers whenever a part is destroyed, simultaneously with OnPartRemove
            OnPartDestroy = (PhysicalAssemblyId, BlockEntity, IsBaseBlock) =>
            {
                // You can remove this function, and any others if need be.
            },

            // The most important block in an assembly. Connection checking starts here.
            BaseBlock = null,

            // All SubtypeIds that can be part of this assembly.
            AllowedBlocks = new[]
            {
                "Caster_FocusLens",
                "Caster_Accelerator_0",
                "Caster_Accelerator_90",
                "Caster_CentralPipe_0",
                "Caster_CentralPipe_90",
                "Caster_CentralPipe_T",
                "Caster_Feeder",
                //"Caster_Controller",
                "Caster_Reactor"
            },

            // Allowed connection directions & whitelists, measured in blocks.
            // If an allowed SubtypeId is not included here, connections are allowed on all sides.
            // If the connection type whitelist is empty, all allowed subtypes may connect on that side.
            AllowedConnections = new Dictionary<string, Dictionary<Vector3I, string[]>>
            {
                {
                    // Note - Offsets line up with BuildInfo block orientation.
                    // Note - Offsets are measured from the center of the block; in this case, the Caster_FocusLens is a 3x3 that has connections on the back in a plus shape.
                    "Caster_FocusLens", new Dictionary<Vector3I, string[]>
                    {
                        {
                            new Vector3I(1, 0, 2), new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                "Caster_Reactor",
                                "Caster_Controller"
                            }
                        },
                        {
                            new Vector3I(-1, 0, 2), new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                "Caster_Reactor",
                                "Caster_Controller"
                            }
                        },
                        {
                            new Vector3I(0, 1, 2), new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                "Caster_Reactor",
                                "Caster_Controller"
                            }
                        },
                        {
                            new Vector3I(0, -1, 2), new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                "Caster_Reactor",
                                "Caster_Controller"
                            }
                        }
                    }
                },
                {
                    "Caster_Reactor", new Dictionary<Vector3I, string[]>
                    {
                        {
                            new Vector3I(0, 2, 0), new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                "Caster_FocusLens",
                                //"Caster_Controller",
                                "Caster_Reactor"
                            }
                        },
                        {
                            new Vector3I(0, -2, 0), new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                "Caster_FocusLens",
                                //"Caster_Controller",
                                "Caster_Reactor"
                            }
                        }
                    }
                },
                {
                    "Caster_Accelerator_0", new Dictionary<Vector3I, string[]>
                    {
                        {
                            Vector3I.Forward, new[]
                            {
                                "Caster_Accelerator_0",
                                "Caster_Accelerator_90",
                                "Caster_Feeder"
                            }
                        },
                        {
                            Vector3I.Backward, new[]
                            {
                                "Caster_Accelerator_0",
                                "Caster_Accelerator_90",
                                "Caster_Feeder"
                            }
                        }
                    }
                },
                {
                    "Caster_Accelerator_90", new Dictionary<Vector3I, string[]>
                    {
                        {
                            Vector3I.Forward, new[]
                            {
                                "Caster_Accelerator_0",
                                "Caster_Accelerator_90",
                                "Caster_Feeder"
                            }
                        },
                        {
                            Vector3I.Right, new[]
                            {
                                "Caster_Accelerator_0",
                                "Caster_Accelerator_90",
                                "Caster_Feeder"
                            }
                        }
                    }
                },
                {
                    "Caster_CentralPipe_0", new Dictionary<Vector3I, string[]>
                    {
                        {
                            Vector3I.Forward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        },
                        {
                            Vector3I.Backward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        }
                    }
                },
                {
                    "Caster_CentralPipe_90", new Dictionary<Vector3I, string[]>
                    {
                        {
                            Vector3I.Forward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        },
                        {
                            Vector3I.Right, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        }
                    }
                },
                {
                    "Caster_CentralPipe_T", new Dictionary<Vector3I, string[]>
                    {
                        {
                            Vector3I.Forward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        },
                        {
                            Vector3I.Right, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        },
                        {
                            Vector3I.Backward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        }
                    }
                },
                {
                    "Caster_Feeder", new Dictionary<Vector3I, string[]>
                    {
                        {
                            Vector3I.Forward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        },
                        {
                            Vector3I.Backward, new[]
                            {
                                "Caster_CentralPipe_0",
                                "Caster_CentralPipe_90",
                                "Caster_CentralPipe_T",
                                "Caster_Feeder",
                                //"Caster_Controller",
                                "Caster_FocusLens",
                                "Caster_Reactor"
                            }
                        },

                        {
                            Vector3I.Up, new[]
                            {
                                "Caster_Accelerator_0",
                                "Caster_Accelerator_90",
                                "Caster_Feeder"
                            }
                        },
                        {
                            Vector3I.Down, new[]
                            {
                                "Caster_Accelerator_0",
                                "Caster_Accelerator_90",
                                "Caster_Feeder"
                            }
                        }
                    }
                }
                //{
                //    "Caster_Controller", new Dictionary<Vector3I, string[]>
                //    {
                //        {
                //            Vector3I.Backward, new[]
                //            {
                //                "Caster_CentralPipe_0",
                //                "Caster_CentralPipe_90",
                //                "Caster_CentralPipe_T",
                //                "Caster_Feeder",
                //                "Caster_Reactor"
                //            }
                //        }
                //    }
                //}
            }
        };
    }
}﻿namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies
{
    // turns out whoever wrote the CoreSystems definition handler is REALLY SMART. hats off to you
    internal partial class ModularDefinition
    {
        internal ModularDefinition()
        {
            // it's just like assemblycore, insert definitions here

            LoadDefinitions(Modular_Fusion);
        }
    }
}﻿using System;
using System.Collections.Generic;
using ProtoBuf;
using Sandbox.ModAPI;
using VRage.Game.Components;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies
{
    [MySessionComponentDescriptor(MyUpdateOrder.AfterSimulation)]
    public class SyncMultipliers : MySessionComponentBase
    {
        private const int Channel = 8775;
        private static SyncMultipliers Instance;
        private readonly Dictionary<IMyReactor, float> mReactorList = new Dictionary<IMyReactor, float>();
        private readonly Dictionary<IMyThrust, float> mThrustList = new Dictionary<IMyThrust, float>();

        private bool needsUpdate;

        public override void LoadData()
        {
            Instance = this;
            if (!MyAPIGateway.Multiplayer.MultiplayerActive)
                return;

            MyAPIGateway.Multiplayer.RegisterSecureMessageHandler(Channel, HandleMessage);

            if (!MyAPIGateway.Session.IsServer)
                needsUpdate = true;
        }

        public override void UpdateAfterSimulation()
        {
            if (needsUpdate && MyAPIGateway.Session != null && MyAPIGateway.Multiplayer != null &&
                MyAPIGateway.Session.Player != null)
            {
                MyAPIGateway.Multiplayer.SendMessageToServer(Channel,
                    MyAPIGateway.Utilities.SerializeToBinary(new SerializableMultiplier(-1, 0, 0,
                        MyAPIGateway.Session.Player.SteamUserId)));
                needsUpdate = false;
            }
        }

        private void HandleMessage(ushort handlerId, byte[] package, ulong senderId, bool fromServer)
        {
            var sm = MyAPIGateway.Utilities.SerializeFromBinary<SerializableMultiplier>(package);
            if (sm == null)
                return;
            switch (sm.type)
            {
                case 0:
                    if (MyAPIGateway.Session.IsServer)
                        break;
                    var react = MyAPIGateway.Entities.GetEntityById(sm.entityid) as IMyReactor;
                    if (react != null)
                        ReactorOutput(react, sm.value);
                    else
                        needsUpdate = true;
                    break;
                case 1:
                    if (MyAPIGateway.Session.IsServer)
                        break;
                    var thrust = MyAPIGateway.Entities.GetEntityById(sm.entityid) as IMyThrust;
                    if (thrust != null)
                        ThrusterOutput(thrust, sm.value);
                    else
                        needsUpdate = true;
                    break;
                case -1:
                    if (!MyAPIGateway.Session.IsServer)
                        break;
                    foreach (var reactor in mReactorList)
                        MyAPIGateway.Multiplayer.SendMessageTo(Channel,
                            MyAPIGateway.Utilities.SerializeToBinary(
                                new SerializableMultiplier(0, reactor.Value, reactor.Key.EntityId)), sm.playerid);
                    foreach (var thruster in mThrustList)
                        MyAPIGateway.Multiplayer.SendMessageTo(Channel,
                            MyAPIGateway.Utilities.SerializeToBinary(
                                new SerializableMultiplier(1, thruster.Value, thruster.Key.EntityId)), sm.playerid);
                    break;
            }
        }

        protected override void UnloadData()
        {
            Instance = null;
            if (!MyAPIGateway.Multiplayer.MultiplayerActive)
                return;
            MyAPIGateway.Multiplayer.UnregisterSecureMessageHandler(Channel, HandleMessage);
        }

        public static void ReactorOutput(IMyReactor reactor, float output)
        {
            if (Math.Abs(reactor.MaxOutput - output) < 0.1f)
                return;

            if (MyAPIGateway.Session.IsServer)
            {
                MyAPIGateway.Multiplayer.SendMessageToOthers(Channel,
                    MyAPIGateway.Utilities.SerializeToBinary(new SerializableMultiplier(0, output, reactor.EntityId)));
                if (Instance.mReactorList.ContainsKey(reactor))
                {
                    Instance.mReactorList[reactor] = output;
                }
                else
                {
                    Instance.mReactorList.Add(reactor, output);
                    reactor.OnClose += ent => { Instance.mReactorList.Remove(reactor); };
                }
            }

            reactor.PowerOutputMultiplier = output / (reactor.MaxOutput / reactor.PowerOutputMultiplier);
        }

        public static void ThrusterOutput(IMyThrust thrust, float output)
        {
            if (Math.Abs(thrust.MaxThrust - output) < 1.0f)
                return;

            if (MyAPIGateway.Session.IsServer)
            {
                MyAPIGateway.Multiplayer.SendMessageToOthers(Channel,
                    MyAPIGateway.Utilities.SerializeToBinary(new SerializableMultiplier(0, output, thrust.EntityId)));
                if (Instance.mThrustList.ContainsKey(thrust))
                {
                    Instance.mThrustList[thrust] = output;
                }
                else
                {
                    Instance.mThrustList.Add(thrust, output);
                    thrust.OnClose += ent => { Instance.mThrustList.Remove(thrust); };
                }
            }

            thrust.ThrustMultiplier = output / (thrust.MaxThrust / thrust.ThrustMultiplier);
        }

        [ProtoContract]
        private class SerializableMultiplier
        {
            public SerializableMultiplier()
            {
            }

            public SerializableMultiplier(int type, float value, long entityid)
            {
                this.type = type;
                this.value = value;
                this.entityid = entityid;
            }

            public SerializableMultiplier(int type, float value, long entityid, ulong playerid)
            {
                this.type = type;
                this.value = value;
                this.entityid = entityid;
                this.playerid = playerid;
            }

            [ProtoMember(1)] public int type { get; }
            [ProtoMember(2)] public float value { get; }
            [ProtoMember(3)] public long entityid { get; }
            [ProtoMember(4)] public ulong playerid { get; }
        }
    }
}﻿using System.Collections.Generic;
using System.Linq;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.FusionParts;
using Sandbox.ModAPI;
using VRage.Game.Entity;
using VRage.Game.ModAPI;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies
{
    internal class S_FusionManager
    {
        public static S_FusionManager I = new S_FusionManager();
        public ModularDefinition Definition;
        public Dictionary<int, S_FusionSystem> FusionSystems = new Dictionary<int, S_FusionSystem>();
        private static ModularDefinitionAPI ModularAPI => ModularDefinition.ModularAPI;


        public void Load()
        {
            I = this;
            ModularAPI.OnReady += () => ModularAPI.AddOnAssemblyClose(assemblyId => FusionSystems.Remove(assemblyId));
        }

        public void Unload()
        {
            I = null;
        }

        private int _ticks = 0;
        public void UpdateTick()
        {
            foreach (var fusionSystem in FusionSystems.Values)
                fusionSystem.UpdateTick();

            if (_ticks % 100 == 0)
                Update100();

            _ticks++;
        }

        private void Update100()
        {
            int[] systems = ModularAPI.GetAllAssemblies();
            foreach (var fusionSystem in FusionSystems.Values.ToList())
            {
                // Remove invalid systems
                if (!systems.Contains(fusionSystem.PhysicalAssemblyId))
                {
                    FusionSystems.Remove(fusionSystem.PhysicalAssemblyId);
                }
            }
        }

        public void OnPartAdd(int PhysicalAssemblyId, MyEntity NewBlockEntity, bool IsBaseBlock)
        {
            if (!FusionSystems.ContainsKey(PhysicalAssemblyId))
                FusionSystems.Add(PhysicalAssemblyId, new S_FusionSystem(PhysicalAssemblyId));

            FusionSystems[PhysicalAssemblyId].AddPart((IMyCubeBlock)NewBlockEntity);
        }

        public void OnPartRemove(int PhysicalAssemblyId, MyEntity BlockEntity, bool IsBaseBlock)
        {
            if (!FusionSystems.ContainsKey(PhysicalAssemblyId))
                return;
            
            // Remove if the connection is broken.
            if (!IsBaseBlock)
                FusionSystems[PhysicalAssemblyId].RemovePart((IMyCubeBlock)BlockEntity);

            // TODO: OnAssemblyRemoved
        }
    }
}
﻿using System;
using System.Linq;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.HudHelpers;
using RichHudFramework.Client;
using RichHudFramework.UI.Client;
using Sandbox.Game;
using Sandbox.ModAPI;
using VRage.Game.Components;
using VRage.Utils;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies
{
    /// <summary>
    ///     Semi-independent script for managing the player HUD.
    /// </summary>
    [MySessionComponentDescriptor(MyUpdateOrder.AfterSimulation)]
    public class S_FusionPlayerHud : MySessionComponentBase
    {
        public static S_FusionPlayerHud I;
        private static ModularDefinitionAPI ModularAPI => ModularDefinition.ModularAPI;
        private static S_FusionManager FusionManager => S_FusionManager.I;

        private ConsumptionBar ConsumptionBar = null;
        private int _ticks = 0;

        #region Base Methods

        public override void LoadData()
        {
            I = this;
            FusionManager.Load();
            
            RichHudClient.Init("FusionSystems", () => { }, () => { });
        }

        protected override void UnloadData()
        {
            FusionManager.Unload();
            I = null;

            //RichHudClient.Reset();
        }

        public override void UpdateAfterSimulation()
        {
            _ticks++;
            try
            {
                if (ConsumptionBar == null && RichHudClient.Registered)
                {
                    ConsumptionBar = new ConsumptionBar(HudMain.HighDpiRoot)
                    {
                        Visible = true,
                    };
                }

                FusionManager.UpdateTick();
                ConsumptionBar?.Update();

                if (ModularAPI.IsDebug())
                {
                    MyVisualScriptLogicProvider.SetQuestlogLocal(true,
                        $"Fusion Systems ({FusionManager.FusionSystems.Count})");

                    // Limits the number of displayed systems to 6
                    var displayedCount = 0;
                    foreach (var system in FusionManager.FusionSystems.Values.ToList())
                    {
                        if (displayedCount > 6 || system.Arms.Count == 0)
                            continue;

                        MyVisualScriptLogicProvider.AddQuestlogDetailLocal(
                            $"[{system.PhysicalAssemblyId}] Power: {Math.Round(system.PowerStored / system.MaxPowerStored * 100f)}% ({Math.Round(system.MaxPowerStored)} @ {Math.Round(system.PowerGeneration * 60, 1)}/s) | Loops: {system.Arms.Count} | Blocks: {system.BlockCount}",
                            false, false);
                        displayedCount++;
                    }
                }
                else
                {
                    MyVisualScriptLogicProvider.SetQuestlogLocal(false, "Fusion Systems");
                }
            }
            catch (Exception ex)
            {
                MyLog.Default.WriteLineAndConsole(ex.ToString());
            }
        }

        #endregion
    }
}﻿using System;
using System.Collections.Generic;
using Sandbox.ModAPI;
using VRage.Game.Entity;
using VRage.Game.ModAPI;
using VRage.Utils;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    Communication
{
    public class ModularDefinitionAPI
    {
        /// <summary>
        ///     Returns the IMyCubeGrid of a given IMyCubeBlock's EntityId.
        /// </summary>
        /// <param name="blockId"></param>
        /// <returns></returns>
        public IMyCubeGrid GridFromBlockId(long blockId)
        {
            var entity = MyAPIGateway.Entities.GetEntityById(blockId);
            if (entity is IMyCubeBlock)
                return ((IMyCubeBlock)entity).CubeGrid;
            return null;
        }


        #region API calls

        private Func<MyEntity[]> _getAllParts;
        private Func<int[]> _getAllAssemblies;
        private Func<int, MyEntity[]> _getMemberParts;
        private Func<MyEntity, bool, MyEntity[]> _getConnectedBlocks;
        private Func<int, MyEntity> _getBasePart;
        private Func<bool> _isDebug;
        private Func<MyEntity, int> _getContainingAssembly;
        private Func<int, IMyCubeGrid> _getAssemblyGrid;
        private Action<Action<int>> _addOnAssemblyClose;
        private Action<Action<int>> _removeOnAssemblyClose;

        /// <summary>
        ///     Gets all AssemblyParts in the world. Returns an array of all AssemblyParts.
        /// </summary>
        public MyEntity[] GetAllParts()
        {
            return _getAllParts?.Invoke();
        }

        /// <summary>
        ///     Gets all PhysicalAssembly ids in the world. Returns an empty list on fail.
        ///     <para>
        ///         Arg1 is assembly id
        ///     </para>
        /// </summary>
        public int[] GetAllAssemblies()
        {
            return _getAllAssemblies?.Invoke();
        }

        /// <summary>
        ///     Gets all member parts of a assembly. Returns an empty list on fail.
        ///     <para>
        ///         Arg1 is EntityId
        ///     </para>
        /// </summary>
        public MyEntity[] GetMemberParts(int assemblyId)
        {
            return _getMemberParts?.Invoke(assemblyId);
        }

        /// <summary>
        ///     Gets all connected parts to a block. Returns an empty list on fail.
        ///     <para>
        ///         <paramref name="useCached" />: Set this to 'false' if used in OnPartAdd.
        ///     </para>
        /// </summary>
        public MyEntity[] GetConnectedBlocks(MyEntity partBlockId, bool useCached = true)
        {
            return _getConnectedBlocks?.Invoke(partBlockId, useCached);
        }

        /// <summary>
        ///     Gets the base part of a PhysicalAssembly. Returns null if assembly does not exist.
        /// </summary>
        public MyEntity GetBasePart(int assemblyId)
        {
            return _getBasePart?.Invoke(assemblyId);
        }

        /// <summary>
        ///     Returns true if debug mode is enabled.
        /// </summary>
        /// <returns></returns>
        public bool IsDebug()
        {
            return _isDebug?.Invoke() ?? false;
        }

        public int GetContainingAssembly(MyEntity blockPart)
        {
            return _getContainingAssembly?.Invoke(blockPart) ?? -1;
        }

        public IMyCubeGrid GetAssemblyGrid(int assemblyId)
        {
            return _getAssemblyGrid?.Invoke(assemblyId) ?? null;
        }

        public void AddOnAssemblyClose(Action<int> action)
        {
            _addOnAssemblyClose?.Invoke(action);
        }

        public void RemoveOnAssemblyClose(Action<int> action)
        {
            _removeOnAssemblyClose?.Invoke(action);
        }


        public Action OnReady;
        public bool IsReady;
        private bool _isRegistered;
        private bool _apiInit;
        private readonly long ApiChannel = 8774;
        private IReadOnlyDictionary<string, Delegate> methodMap;

        public void ApiAssign()
        {
            _apiInit = methodMap != null;
            SetApiMethod("GetAllParts", ref _getAllParts);
            SetApiMethod("GetAllAssemblies", ref _getAllAssemblies);
            SetApiMethod("GetMemberParts", ref _getMemberParts);
            SetApiMethod("GetConnectedBlocks", ref _getConnectedBlocks);
            SetApiMethod("GetBasePart", ref _getBasePart);
            SetApiMethod("IsDebug", ref _isDebug);
            SetApiMethod("GetContainingAssembly", ref _getContainingAssembly);
            SetApiMethod("GetAssemblyGrid", ref _getAssemblyGrid);
            SetApiMethod("AddOnAssemblyClose", ref _addOnAssemblyClose);
            SetApiMethod("RemoveOnAssemblyClose", ref _removeOnAssemblyClose);

            if (_apiInit)
                MyLog.Default.WriteLineAndConsole("ModularDefinitions: ModularDefinitionsAPI loaded!");
            else
                MyLog.Default.WriteLineAndConsole("ModularDefinitions: ModularDefinitionsAPI cleared.");

            methodMap = null;
            OnReady?.Invoke();
        }

        private void SetApiMethod<T>(string name, ref T method) where T : class
        {
            if (methodMap == null)
            {
                method = null;
                return;
            }

            if (!methodMap.ContainsKey(name))
                throw new Exception("Method Map does not contain method " + name);
            Delegate del = methodMap[name];
            if (del.GetType() != typeof(T))
                throw new Exception($"Method {name} type mismatch! [MapMethod: {del.GetType().Name} | ApiMethod: {typeof(T).Name}]");
            method = methodMap[name] as T;
        }

        public void LoadData()
        {
            if (_isRegistered)
                throw new Exception($"{GetType().Name}.Load() should not be called multiple times!");

            _isRegistered = true;
            MyAPIGateway.Utilities.RegisterMessageHandler(ApiChannel, HandleMessage);
            MyAPIGateway.Utilities.SendModMessage(ApiChannel, "ApiEndpointRequest");
            MyLog.Default.WriteLineAndConsole("ModularDefinitions: ModularDefinitionsAPI inited.");
        }

        public void UnloadData()
        {
            MyAPIGateway.Utilities.UnregisterMessageHandler(ApiChannel, HandleMessage);

            ApiAssign();

            _isRegistered = false;
            _apiInit = false;
            IsReady = false;
            MyLog.Default.WriteLineAndConsole("ModularDefinitions: ModularDefinitionsAPI unloaded.");
        }

        private void HandleMessage(object obj)
        {
            try
            {
                if (_apiInit ||
                    obj is string) // the sent "ApiEndpointRequest" will also be received here, explicitly ignoring that
                {
                    MyLog.Default.WriteLineAndConsole(
                        $"ModularDefinitions: ModularDefinitionsAPI ignored message {obj as string}!");
                    return;
                }

                var dict = obj as Dictionary<string, Delegate>;

                if (dict == null)
                {
                    MyLog.Default.WriteLineAndConsole(
                        "ModularDefinitions: ModularDefinitionsAPI ERR: Recieved null dictionary!");
                    return;
                }

                methodMap = dict;
                ApiAssign();
                methodMap = null;
                IsReady = true;
            }
            catch (Exception ex)
            {
                MyLog.Default.WriteLineAndConsole("Exception in ModularAssemblies Client Mod DefinitionAPI! " + ex);
                MyAPIGateway.Utilities.ShowMessage("Fusion Systems", "Exception in ModularAssemblies Client Mod DefinitionAPI! " + ex);
            }
        }

        #endregion
    }
}﻿using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using static MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication.DefinitionDefs;

// ReSharper disable once CheckNamespace
namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies
{
    internal partial class ModularDefinition
    {
        internal static ModularDefinitionAPI ModularAPI = new ModularDefinitionAPI();
        internal DefinitionContainer Container = new DefinitionContainer();

        internal void LoadDefinitions(params PhysicalDefinition[] defs)
        {
            Container.PhysicalDefs = defs;
        }

        /// <summary>
        ///     Load all definitions for DefinitionSender
        /// </summary>
        /// <param name="baseDefs"></param>
        internal static DefinitionContainer GetBaseDefinitions()
        {
            return new ModularDefinition().Container;
        }
    }
}﻿using System;
using System.Collections.Generic;
using ProtoBuf;
using VRage.Game.Entity;
using VRageMath;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    Communication
{
    public class DefinitionDefs
    {
        [ProtoContract]
        public class DefinitionContainer
        {
            [ProtoMember(1)] internal PhysicalDefinition[] PhysicalDefs;
        }

        [ProtoContract]
        public class PhysicalDefinition
        {
            /// <summary>
            ///     The name of this definition. Must be unique!
            /// </summary>
            [ProtoMember(1)]
            public string Name { get; set; }

            /// <summary>
            ///     Triggered whenever the definition is first loaded.
            /// </summary>
            public Action OnInit { get; set; }

            /// <summary>
            ///     Called when a valid part is placed.
            ///     <para>
            ///         Arg1 is PhysicalAssemblyId, Arg2 is BlockEntity, Arg3 is IsBaseBlock
            ///     </para>
            /// </summary>
            public Action<int, MyEntity, bool> OnPartAdd { get; set; }

            /// <summary>
            ///     Called when a valid part is removed.
            ///     <para>
            ///         Arg1 is PhysicalAssemblyId, Arg2 is BlockEntity, Arg3 is IsBaseBlock
            ///     </para>
            /// </summary>
            public Action<int, MyEntity, bool> OnPartRemove { get; set; }

            /// <summary>
            ///     Called when a component part is destroyed. Note - OnPartRemove is called simultaneously.
            ///     <para>
            ///         Arg1 is PhysicalAssemblyId, Arg2 is BlockEntity, Arg3 is IsBaseBlock
            ///     </para>
            /// </summary>
            public Action<int, MyEntity, bool> OnPartDestroy { get; set; }

            /// <summary>
            ///     All allowed SubtypeIds. The mod will likely misbehave if two mods allow the same blocks, so please be cautious.
            /// </summary>
            [ProtoMember(2)]
            public string[] AllowedBlocks { get; set; }

            /// <summary>
            ///     Allowed connection directions. Measured in blocks. If an allowed SubtypeId is not included here, connections are
            ///     allowed on all sides. If the connection type whitelist is empty, all allowed subtypes may connect on that side.
            /// </summary>
            [ProtoMember(3)]
            public Dictionary<string, Dictionary<Vector3I, string[]>> AllowedConnections { get; set; }

            /// <summary>
            ///     The primary block of a PhysicalAssembly. Make sure this is an AssemblyCore block OR null.
            /// </summary>
            [ProtoMember(4)]
            public string BaseBlock { get; set; }
        }

        [ProtoContract]
        public class FunctionCall
        {
            public enum ActionType
            {
                OnPartAdd,
                OnPartRemove,
                OnPartDestroy,
                GetAllParts,
                GetAllAssemblies,
                GetMemberParts,
                GetConnectedBlocks
            }

            [ProtoMember(1)] public string DefinitionName { get; set; }
            [ProtoMember(2)] public int PhysicalAssemblyId { get; set; }
            [ProtoMember(3)] public ActionType ActionId { get; set; }
            [ProtoMember(4)] public SerializedObjectArray Values { get; set; }
        }

        [ProtoContract]
        public class SerializedObjectArray // This is awful so don't use it.
        {
            [ProtoMember(7)] internal bool[] BoolValues = Array.Empty<bool>();
            [ProtoMember(8)] internal double[] DoubleValues = Array.Empty<double>();
            [ProtoMember(6)] internal float[] FloatValues = Array.Empty<float>();

            [ProtoMember(1)] internal int[] IntValues = Array.Empty<int>();
            [ProtoMember(3)] internal long[] LongValues = Array.Empty<long>();
            [ProtoMember(2)] internal string[] StringValues = Array.Empty<string>();
            [ProtoMember(4)] internal ulong[] UlongValues = Array.Empty<ulong>();
            [ProtoMember(5)] internal Vector3D[] VectorValues = Array.Empty<Vector3D>();

            public SerializedObjectArray()
            {
            }

            public SerializedObjectArray(params object[] array)
            {
                var intValuesL = new List<int>();
                var stringValuesL = new List<string>();
                var longValuesL = new List<long>();
                var ulongValuesL = new List<ulong>();
                var vectorValuesL = new List<Vector3D>();
                var floatValuesL = new List<float>();
                var boolValuesL = new List<bool>();
                var doubleValuesL = new List<double>();

                foreach (var value in array)
                {
                    var type = value.GetType();
                    if (type == typeof(int))
                        intValuesL.Add((int)value);
                    else if (type == typeof(string))
                        stringValuesL.Add((string)value);
                    else if (type == typeof(long))
                        longValuesL.Add((long)value);
                    else if (type == typeof(ulong))
                        ulongValuesL.Add((ulong)value);
                    else if (type == typeof(Vector3D))
                        vectorValuesL.Add((Vector3D)value);
                    else if (type == typeof(float))
                        floatValuesL.Add((float)value);
                    else if (type == typeof(bool))
                        boolValuesL.Add((bool)value);
                    else if (type == typeof(double))
                        doubleValuesL.Add((double)value);
                }

                IntValues = intValuesL.ToArray();
                StringValues = stringValuesL.ToArray();
                LongValues = longValuesL.ToArray();
                UlongValues = ulongValuesL.ToArray();
                VectorValues = vectorValuesL.ToArray();
                FloatValues = floatValuesL.ToArray();
                BoolValues = boolValuesL.ToArray();
                DoubleValues = doubleValuesL.ToArray();

                //MyLog.Default.WriteLineAndConsole($"ModularDefinitions.DefinitionDefs: {array.Length} values packaged.");
            }

            public object[] Values()
            {
                var values = new List<object>();

                foreach (var value in IntValues)
                    values.Add(value);
                foreach (var value in StringValues)
                    values.Add(value);
                foreach (var value in LongValues)
                    values.Add(value);
                foreach (var value in UlongValues)
                    values.Add(value);
                foreach (var value in VectorValues)
                    values.Add(value);
                foreach (var value in FloatValues)
                    values.Add(value);
                foreach (var value in BoolValues)
                    values.Add(value);
                foreach (var value in DoubleValues)
                    values.Add(value);

                //MyLog.Default.WriteLineAndConsole($"ModularDefinitions.DefinitionDefs: {values.Count} values recieved.");
                return values.ToArray();
            }
        }
    }
}﻿using System;
using Sandbox.ModAPI;
using VRage.Game.Components;
using VRage.Game.Entity;
using VRage.Utils;
using static MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication.DefinitionDefs;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    Communication
{
    [MySessionComponentDescriptor(MyUpdateOrder.Simulation)]
    internal class ModularDefinitionSender : MySessionComponentBase
    {
        private const int DefinitionMessageId = 8772;
        private const int InboundMessageId = 8771;
        private const int OutboundMessageId = 8773;
        internal byte[] Storage;

        internal DefinitionContainer StoredDef;

        public override void LoadData()
        {
            MyLog.Default.WriteLineAndConsole(
                $"{ModContext.ModName}.ModularDefinition: Init new ModularAssembliesDefinition");
            MyAPIGateway.Utilities.RegisterMessageHandler(InboundMessageId, InputHandler);

            // Init
            StoredDef = ModularDefinition.GetBaseDefinitions();
            Storage = MyAPIGateway.Utilities.SerializeToBinary(StoredDef);

            ModularDefinition.ModularAPI.LoadData();

            // Send message in case this loads after the main mod
            MyAPIGateway.Utilities.SendModMessage(DefinitionMessageId, Storage);
            MyLog.Default.WriteLineAndConsole(
                $"{ModContext.ModName}.ModularDefinition: Packaged and sent definitions, now going to sleep.");
        }

        protected override void UnloadData()
        {
            MyAPIGateway.Utilities.UnregisterMessageHandler(InboundMessageId, InputHandler);
            Array.Clear(Storage, 0, Storage.Length);
            Storage = null;
            ModularDefinition.ModularAPI.UnloadData();
        }

        private void InputHandler(object o)
        {
            var message = o as byte[];

            if (o is bool && (bool)o)
            {
                MyAPIGateway.Utilities.SendModMessage(DefinitionMessageId, Storage);
                MyLog.Default.WriteLineAndConsole(
                    $"{ModContext.ModName}.ModularDefinition: Sent definitions & returning to sleep.");
            }
            else
            {
                try
                {
                    var call = MyAPIGateway.Utilities.SerializeFromBinary<FunctionCall>(message);

                    if (call == null)
                    {
                        MyLog.Default.WriteLineAndConsole(
                            $"{ModContext.ModName}.ModularDefinition: Invalid FunctionCall!");
                        return;
                    }

                    PhysicalDefinition defToCall = null;
                    foreach (var definition in StoredDef.PhysicalDefs)
                        if (call.DefinitionName == definition.Name)
                            defToCall = definition;

                    if (defToCall == null)
                        //MyLog.Default.WriteLineAndConsole($$"{ModContext.ModName}.ModularDefinition: Function call [{call.DefinitionName}] not addressed to this.");
                        return;

                    // TODO: Remove
                    //object[] Values = call.Values.Values();
                    try
                    {
                        switch (call.ActionId)
                        {
                            case FunctionCall.ActionType.OnPartAdd:
                                // TODO: OnPartUpdate? With ConnectedParts?
                                defToCall.OnPartAdd?.Invoke(call.PhysicalAssemblyId,
                                    (MyEntity)MyAPIGateway.Entities.GetEntityById(call.Values.LongValues[0]),
                                    call.Values.BoolValues[0]);
                                break;
                            case FunctionCall.ActionType.OnPartRemove:
                                defToCall.OnPartRemove?.Invoke(call.PhysicalAssemblyId,
                                    (MyEntity)MyAPIGateway.Entities.GetEntityById(call.Values.LongValues[0]),
                                    call.Values.BoolValues[0]);
                                break;
                            case FunctionCall.ActionType.OnPartDestroy:
                                defToCall.OnPartDestroy?.Invoke(call.PhysicalAssemblyId,
                                    (MyEntity)MyAPIGateway.Entities.GetEntityById(call.Values.LongValues[0]),
                                    call.Values.BoolValues[0]);
                                break;
                        }
                    }
                    catch (Exception ex)
                    {
                        MyAPIGateway.Utilities.SendMessage(
                            $"ERROR in definition [{call.DefinitionName}]'s {call.ActionId}!\nCheck logs for stack trace.");
                        MyLog.Default.WriteLineAndConsole(
                            $"ERROR in definition [{call.DefinitionName}]'s {call.ActionId}!\nCheck logs for stack trace.");
                        throw ex;
                    }
                }
                catch (Exception ex)
                {
                    MyLog.Default.WriteLineAndConsole(
                        $"{ModContext.ModName}.ModularDefinition: Exception in InputHandler: {ex}\n{ex.StackTrace}");
                }
            }
        }

        private void SendFunc(FunctionCall call)
        {
            MyAPIGateway.Utilities.SendModMessage(OutboundMessageId, MyAPIGateway.Utilities.SerializeToBinary(call));
            //MyLog.Default.WriteLineAndConsole($$"{ModContext.ModName}.ModularDefinition: Sending function call [id {call.ActionId}].");
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Sandbox.ModAPI;
using VRage;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.Utils;
using VRageMath;
using static VRageRender.MyBillboard;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    DebugDraw
{
    [MySessionComponentDescriptor(MyUpdateOrder.NoUpdate)]
    public class DebugDraw : MySessionComponentBase
    {
        protected const float OnTopColorMul = 0.5f;

        private const float DepthRatioF = 0.01f;
        // i'm gonna kiss digi on the 

        private static DebugDraw Instance;
        protected static readonly MyStringId MaterialDot = MyStringId.GetOrCompute("WhiteDot");
        protected static readonly MyStringId MaterialSquare = MyStringId.GetOrCompute("Square");

        private readonly Dictionary<Vector3I, MyTuple<long, Color, IMyCubeGrid>> QueuedGridPoints =
            new Dictionary<Vector3I, MyTuple<long, Color, IMyCubeGrid>>();

        private readonly Dictionary<MyTuple<Vector3D, Vector3D>, MyTuple<long, Color>> QueuedLinePoints =
            new Dictionary<MyTuple<Vector3D, Vector3D>, MyTuple<long, Color>>();

        private readonly Dictionary<Vector3D, MyTuple<long, Color>> QueuedPoints =
            new Dictionary<Vector3D, MyTuple<long, Color>>();

        public override void LoadData()
        {
            if (!MyAPIGateway.Utilities.IsDedicated)
                Instance = this;
        }

        protected override void UnloadData()
        {
            Instance = null;
        }

        public static void AddPoint(Vector3D globalPos, Color color, float duration)
        {
            if (Instance == null)
                return;


            if (Instance.QueuedPoints.ContainsKey(globalPos))
                Instance.QueuedPoints[globalPos] =
                    new MyTuple<long, Color>(DateTime.UtcNow.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color);
            else
                Instance.QueuedPoints.Add(globalPos,
                    new MyTuple<long, Color>(DateTime.UtcNow.Ticks + (long)(duration * TimeSpan.TicksPerSecond),
                        color));
        }

        public static void AddGPS(string name, Vector3D position, float duration)
        {
            var gps = MyAPIGateway.Session.GPS.Create(name, string.Empty, position, true, true);
            gps.DiscardAt =
                MyAPIGateway.Session.ElapsedPlayTime.Add(new TimeSpan((long)(duration * TimeSpan.TicksPerSecond)));
            MyAPIGateway.Session.GPS.AddLocalGps(gps);
        }

        public static void AddGridGPS(string name, Vector3I gridPosition, IMyCubeGrid grid, float duration)
        {
            AddGPS(name, GridToGlobal(gridPosition, grid), duration);
        }

        public static void AddGridPoint(Vector3I blockPos, IMyCubeGrid grid, Color color, float duration)
        {
            if (Instance == null)
                return;

            if (Instance.QueuedGridPoints.ContainsKey(blockPos))
                Instance.QueuedGridPoints[blockPos] =
                    new MyTuple<long, Color, IMyCubeGrid>(
                        DateTime.UtcNow.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color, grid);
            else
                Instance.QueuedGridPoints.Add(blockPos,
                    new MyTuple<long, Color, IMyCubeGrid>(
                        DateTime.UtcNow.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color, grid));
        }

        public static void AddLine(Vector3D origin, Vector3D destination, Color color, float duration)
        {
            if (Instance == null)
                return;


            var key = new MyTuple<Vector3D, Vector3D>(origin, destination);
            if (Instance.QueuedLinePoints.ContainsKey(key))
                Instance.QueuedLinePoints[key] =
                    new MyTuple<long, Color>(DateTime.UtcNow.Ticks + (long)(duration * TimeSpan.TicksPerSecond), color);
            else
                Instance.QueuedLinePoints.Add(key,
                    new MyTuple<long, Color>(DateTime.UtcNow.Ticks + (long)(duration * TimeSpan.TicksPerSecond),
                        color));
        }

        public override void Draw()
        {
            try
            {
                foreach (var key in QueuedPoints.Keys.ToList())
                {
                    DrawPoint0(key, QueuedPoints[key].Item2);

                    if (DateTime.UtcNow.Ticks > QueuedPoints[key].Item1)
                        QueuedPoints.Remove(key);
                }

                foreach (var key in QueuedGridPoints.Keys.ToList())
                {
                    DrawGridPoint0(key, QueuedGridPoints[key].Item3, QueuedGridPoints[key].Item2);

                    if (DateTime.UtcNow.Ticks > QueuedGridPoints[key].Item1)
                        QueuedGridPoints.Remove(key);
                }

                foreach (var key in QueuedLinePoints.Keys.ToList())
                {
                    DrawLine0(key.Item1, key.Item2, QueuedLinePoints[key].Item2);

                    if (DateTime.UtcNow.Ticks > QueuedLinePoints[key].Item1)
                        QueuedLinePoints.Remove(key);
                }
            }
            catch
            {
            } // Icky no error logging
        }

        private void DrawPoint0(Vector3D globalPos, Color color)
        {
            //MyTransparentGeometry.AddPointBillboard(MaterialDot, color, globalPos, 1.25f, 0, blendType: BlendTypeEnum.PostPP);
            var depthScale = ToAlwaysOnTop(ref globalPos);
            MyTransparentGeometry.AddPointBillboard(MaterialDot, color * OnTopColorMul, globalPos, 0.35f * depthScale, 0,
                blendType: BlendTypeEnum.LDR);
        }

        private void DrawGridPoint0(Vector3I blockPos, IMyCubeGrid grid, Color color)
        {
            DrawPoint0(GridToGlobal(blockPos, grid), color);
        }

        private void DrawLine0(Vector3D origin, Vector3D destination, Color color)
        {
            var length = (float)(destination - origin).Length();
            var direction = (destination - origin) / length;

            MyTransparentGeometry.AddLineBillboard(MaterialSquare, color, origin, direction, length, 0.35f);

            var depthScale = ToAlwaysOnTop(ref origin);
            direction *= depthScale;

            MyTransparentGeometry.AddLineBillboard(MaterialSquare, color * OnTopColorMul, origin, direction, length,
                0.5f * depthScale);
        }

        public static Vector3D GridToGlobal(Vector3I position, IMyCubeGrid grid)
        {
            return Vector3D.Rotate((Vector3D)position * 2.5f, grid.WorldMatrix) + grid.GetPosition();
        }

        protected static float ToAlwaysOnTop(ref Vector3D position)
        {
            var camMatrix = MyAPIGateway.Session.Camera.WorldMatrix;
            position = camMatrix.Translation + (position - camMatrix.Translation) * DepthRatioF;

            return DepthRatioF;
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using ProtoBuf;
using Sandbox.Game.EntityComponents;
using Sandbox.ModAPI;
using Sandbox.ModAPI.Interfaces.Terminal;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.Game.ModAPI.Network;
using VRage.ModAPI;
using VRage.Network;
using VRage.ObjectBuilders;
using VRage.Sync;
using VRage.Utils;
using static VRage.Game.MyObjectBuilder_BehaviorTreeDecoratorNode;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.FusionParts
{
    public abstract class FusionPart<T> : MyGameLogicComponent, IMyEventProxy
        where T : IMyCubeBlock
    {
        // TODO organize variables
        public static readonly Guid SettingsGUID = new Guid("36a45185-2e80-461c-9f1c-e2140a47a4df");

        /// <summary>
        ///     List of all types that have inited controls.
        /// </summary>
        private static readonly List<string> _haveControlsInited = new List<string>();

        internal readonly StringBuilder InfoText = new StringBuilder("Output: 0/0\nInput: 0/0\nEfficiency: N/A");
        internal T Block;

        internal float BufferPowerGeneration;
        public float MaxPowerConsumption;

        internal S_FusionSystem MemberSystem;
        public MySync<bool, SyncDirection.BothWays> OverrideEnabled;
        public MySync<float, SyncDirection.BothWays> OverridePowerUsageSync;

        public float PowerConsumption;

        public MySync<float, SyncDirection.BothWays> PowerUsageSync;
        internal FusionPartSettings Settings = new FusionPartSettings();
        internal static ModularDefinitionAPI ModularAPI => ModularDefinition.ModularAPI;

        /// <summary>
        ///     Block subtypes allowed.
        /// </summary>
        internal abstract string BlockSubtype { get; }

        /// <summary>
        ///     Human-readable name for this part type.
        /// </summary>
        internal abstract string ReadableName { get; }

        internal long LastShutdown = 0;

        #region Controls

        private void CreateControls()
        {
            /* TERMINAL */
            {
                var boostPowerToggle =
                    MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlOnOffSwitch, T>(
                        $"FusionSystems.{ReadableName}BoostPowerToggle");
                boostPowerToggle.Title = MyStringId.GetOrCompute("Override Fusion Power");
                boostPowerToggle.Tooltip =
                    MyStringId.GetOrCompute("Toggles Power Override - a temporary override on Fusion Power draw.");
                boostPowerToggle.Getter = block =>
                    block.GameLogic.GetAs<FusionPart<T>>()?.OverrideEnabled.Value ?? false;
                boostPowerToggle.Setter = (block, value) =>
                {
                    var logic = block.GameLogic.GetAs<FusionPart<T>>();
                    // Only allow value to be set if 2 seconds of power is stored
                    if (!value || logic.MemberSystem?.PowerStored > MemberSystem?.PowerConsumption * 60)
                        logic.OverrideEnabled.Value = value;
                };

                boostPowerToggle.OnText = MyStringId.GetOrCompute("On");
                boostPowerToggle.OffText = MyStringId.GetOrCompute("Off");

                boostPowerToggle.Visible = block => block.BlockDefinition.SubtypeName == BlockSubtype;
                boostPowerToggle.SupportsMultipleBlocks = true;
                boostPowerToggle.Enabled = block => true;

                MyAPIGateway.TerminalControls.AddControl<T>(boostPowerToggle);
            }
            {
                var powerUsageSlider =
                    MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlSlider, T>(
                        $"FusionSystems.{ReadableName}PowerUsage");
                powerUsageSlider.Title = MyStringId.GetOrCompute("Fusion Power Usage");
                powerUsageSlider.Tooltip =
                    MyStringId.GetOrCompute($"Fusion Power generation this {ReadableName} should use.");
                powerUsageSlider.SetLimits(0.01f, 0.99f);
                powerUsageSlider.Getter = block =>
                    block.GameLogic.GetAs<FusionPart<T>>()?.PowerUsageSync.Value ?? 0;
                powerUsageSlider.Setter = (block, value) =>
                    block.GameLogic.GetAs<FusionPart<T>>().PowerUsageSync.Value = value;

                powerUsageSlider.Writer = (block, builder) =>
                    builder?.Append(Math.Round(block.GameLogic.GetAs<FusionPart<T>>()?.PowerUsageSync.Value * 100 ?? 0))
                        .Append('%');

                powerUsageSlider.Visible = block => block.BlockDefinition.SubtypeName == BlockSubtype;
                powerUsageSlider.SupportsMultipleBlocks = true;
                powerUsageSlider.Enabled = block => true;

                MyAPIGateway.TerminalControls.AddControl<T>(powerUsageSlider);
            }
            {
                var boostPowerUsageSlider =
                    MyAPIGateway.TerminalControls.CreateControl<IMyTerminalControlSlider, T>(
                        $"FusionSystems.{ReadableName}BoostPowerUsage");
                boostPowerUsageSlider.Title = MyStringId.GetOrCompute("Override Power Usage");
                boostPowerUsageSlider.Tooltip =
                    MyStringId.GetOrCompute(
                        $"Fusion Power generation this {ReadableName} should use when Override is enabled.");
                boostPowerUsageSlider.SetLimits(0.01f, 4.0f);
                boostPowerUsageSlider.Getter = block =>
                    block.GameLogic.GetAs<FusionPart<T>>()?.OverridePowerUsageSync.Value ?? 0;
                boostPowerUsageSlider.Setter = (block, value) =>
                    block.GameLogic.GetAs<FusionPart<T>>().OverridePowerUsageSync.Value = value;

                boostPowerUsageSlider.Writer = (block, builder) =>
                    builder?.Append(
                            Math.Round(block.GameLogic.GetAs<FusionPart<T>>()?.OverridePowerUsageSync.Value * 100 ?? 0))
                        .Append('%');

                boostPowerUsageSlider.Visible = block => block.BlockDefinition.SubtypeName == BlockSubtype;
                boostPowerUsageSlider.SupportsMultipleBlocks = true;
                boostPowerUsageSlider.Enabled = block => true;

                MyAPIGateway.TerminalControls.AddControl<T>(boostPowerUsageSlider);
            }

            /* ACTIONS */
            {
                var boostPowerAction = MyAPIGateway.TerminalControls.CreateAction<T>($"FusionSystems.{ReadableName}BoostPowerAction");
                boostPowerAction.Name = new StringBuilder("Override Fusion Power");
                boostPowerAction.Action = block =>
                {
                    var logic = block.GameLogic.GetAs<FusionPart<T>>();
                    // Only allow value to be set if 2 seconds of power is stored
                    if (logic.OverrideEnabled.Value || logic.MemberSystem?.PowerStored > MemberSystem?.PowerConsumption * 60)
                        logic.OverrideEnabled.Value = !logic.OverrideEnabled.Value;
                };
                boostPowerAction.Writer = (b, sb) =>
                {
                    var logic = b?.GameLogic?.GetAs<FusionPart<T>>();
                    if (logic != null)
                    {
                        sb.Append(logic.OverrideEnabled.Value ? "OVR   On" : "OVR  Off");
                    }
                };
                boostPowerAction.Icon = @"Textures\GUI\Icons\Actions\Toggle.dds";
                boostPowerAction.Enabled = block => block.BlockDefinition.SubtypeName == BlockSubtype;
                MyAPIGateway.TerminalControls.AddAction<T>(boostPowerAction);
            }

            MyAPIGateway.TerminalControls.CustomControlGetter += AssignDetailedInfoGetter;

            _haveControlsInited.Add(ReadableName);
        }

        private void AssignDetailedInfoGetter(IMyTerminalBlock block, List<IMyTerminalControl> controls)
        {
            if (block?.BlockDefinition.SubtypeName != BlockSubtype)
                return;
            block.RefreshCustomInfo();
            block.SetDetailedInfoDirty();
        }

        private void AppendingCustomInfo(IMyTerminalBlock block, StringBuilder stringBuilder)
        {
            stringBuilder.Insert(0, InfoText.ToString());
        }

        public abstract void UpdatePower(float PowerGeneration, float OutputPerFusionPower);

        #endregion

        #region Base Methods

        public override void Init(MyObjectBuilder_EntityBase objectBuilder)
        {
            base.Init(objectBuilder);
            NeedsUpdate = MyEntityUpdateEnum.BEFORE_NEXT_FRAME;
        }

        public override void UpdateOnceBeforeFrame()
        {
            base.UpdateOnceBeforeFrame();
            Block = (T)Entity;

            if (Block.CubeGrid?.Physics == null)
                return; // ignore ghost/projected grids

            LoadSettings();
            Settings.PowerUsage = PowerUsageSync.Value;
            PowerUsageSync.ValueChanged += value =>
                Settings.PowerUsage = value.Value;

            Settings.OverridePowerUsage = OverridePowerUsageSync.Value;
            OverridePowerUsageSync.ValueChanged += value =>
                Settings.OverridePowerUsage = value.Value;
            SaveSettings();

            if (!_haveControlsInited.Contains(ReadableName))
                CreateControls();

            ((IMyTerminalBlock)Block).AppendingCustomInfo += AppendingCustomInfo;

            NeedsUpdate |= MyEntityUpdateEnum.EACH_FRAME;
        }

        #endregion

        #region Settings

        internal void SaveSettings()
        {
            if (Block == null)
                return; // called too soon or after it was already closed, ignore

            if (Settings == null)
                throw new NullReferenceException($"Settings == null on entId={Entity?.EntityId}; Test log 1");

            if (MyAPIGateway.Utilities == null)
                throw new NullReferenceException(
                    $"MyAPIGateway.Utilities == null; entId={Entity?.EntityId}; Test log 2");

            if (Block.Storage == null)
                Block.Storage = new MyModStorageComponent();

            Block.Storage.SetValue(SettingsGUID,
                Convert.ToBase64String(MyAPIGateway.Utilities.SerializeToBinary(Settings)));
        }

        internal virtual void LoadDefaultSettings()
        {
            if (!MyAPIGateway.Session.IsServer)
                return;

            Settings.PowerUsage = 0.5f;
            Settings.OverridePowerUsage = 1.5f;

            PowerUsageSync.Value = Settings.PowerUsage;
            OverridePowerUsageSync.Value = Settings.OverridePowerUsage;
        }

        internal virtual bool LoadSettings()
        {
            if (Block.Storage == null)
            {
                LoadDefaultSettings();
                return false;
            }

            string rawData;
            if (!Block.Storage.TryGetValue(SettingsGUID, out rawData))
            {
                LoadDefaultSettings();
                return false;
            }

            try
            {
                var loadedSettings =
                    MyAPIGateway.Utilities.SerializeFromBinary<FusionPartSettings>(Convert.FromBase64String(rawData));

                if (loadedSettings != null)
                {
                    Settings.PowerUsage = loadedSettings.PowerUsage;
                    Settings.OverridePowerUsage = loadedSettings.OverridePowerUsage;

                    PowerUsageSync.Value = loadedSettings.PowerUsage;
                    OverridePowerUsageSync.Value = loadedSettings.OverridePowerUsage;

                    return true;
                }
            }
            catch (Exception e)
            {
                MyLog.Default.WriteLineAndConsole("Exception in loading FusionPart settings: " + e);
                MyAPIGateway.Utilities.ShowMessage("Fusion Systems", "Exception in loading FusionPart settings: " + e);
            }

            return false;
        }

        public override bool IsSerialized()
        {
            try
            {
                SaveSettings();
            }
            catch (Exception e)
            {
                MyLog.Default.WriteLineAndConsole("Exception in loading FusionPart settings: " + e);
                MyAPIGateway.Utilities.ShowMessage("Fusion Systems", "Exception in loading FusionPart settings: " + e);
            }

            return base.IsSerialized();
        }

        #endregion
    }

    [ProtoContract(UseProtoMembersOnly = true)]
    internal class FusionPartSettings
    {
        [ProtoMember(2)] public float OverridePowerUsage;

        [ProtoMember(1)] public float PowerUsage;
        // Don't need to save Override because it would be instantly reset.
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using Sandbox.ModAPI;
using VRage.Game.Entity;
using VRage.Game.ModAPI;
using VRageMath;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    FusionParts
{
    /// <summary>
    ///     Represents a single 'arm' (loop) of fusion accelerators.
    /// </summary>
    internal struct S_FusionArm
    {
        private const float LengthEfficiencyModifier = 0.13f;
        private const float BlockPowerGeneration = 0.01f;
        private const float BlockPowerStorage = 16f;

        private static ModularDefinitionAPI ModularAPI => ModularDefinition.ModularAPI;

        public readonly bool IsValid;

        public float PowerGeneration { get; }
        public float PowerStorage { get; }

        public IMyCubeBlock[] Parts;

        public S_FusionArm(MyEntity newPart, string rootSubtype)
        {
            var stopHits = 0;
            var ignore = new HashSet<IMyCubeBlock>();
            IsValid = PerformScan(newPart, ref ignore, rootSubtype, ref stopHits);
            MyAPIGateway.Utilities.ShowNotification(stopHits + " | " + ignore.Count);

            PowerGeneration = 0;
            PowerStorage = 0;

            if (!IsValid)
            {
                ignore.Clear();
                Parts = Array.Empty<IMyCubeBlock>();
                return;
            }

            foreach (var part in ignore)
                switch (part?.BlockDefinition.SubtypeName)
                {
                    case "Caster_Accelerator_90":
                        PowerGeneration += BlockPowerGeneration;
                        PowerStorage += BlockPowerStorage * 0.05f;
                        break;
                    case "Caster_Accelerator_0":
                        PowerStorage += BlockPowerStorage;
                        PowerGeneration += BlockPowerGeneration * 0.05f;
                        break;
                }

            Parts = ignore.ToArray();
            ignore.Clear();

            // Power capacities scale with length.
            PowerGeneration *= (float)Math.Pow(Parts.Length, LengthEfficiencyModifier);
            PowerStorage *= (float)Math.Pow(Parts.Length, LengthEfficiencyModifier);
        }


        /// <summary>
        ///     Performs a recursive scan for connected blocks in an arm loop.
        /// </summary>
        /// <param name="blockEntity">The block entity to check.</param>
        /// <param name="prevScan">The block entity to ignore; nullable.</param>
        /// <param name="stopAtSubtype">Exits the loop at this subtype.</param>
        /// <returns></returns>
private static bool PerformScan(MyEntity blockEntity, ref HashSet<IMyCubeBlock> parts, string stopAtSubtype, ref int stopHits, HashSet<MyEntity> visitedBlocks = null)
{
    if (visitedBlocks == null)
        visitedBlocks = new HashSet<MyEntity>();

    if (ModularAPI.IsDebug())
        DebugDraw.DebugDraw.AddGridPoint(((IMyCubeBlock)blockEntity).Position, ((IMyCubeBlock)blockEntity).CubeGrid, Color.Blue, 2);

    parts.Add((IMyCubeBlock)blockEntity);
    var connectedBlocks = ModularAPI.GetConnectedBlocks(blockEntity, false);

    if (connectedBlocks.Length < 2)
        return false;

    foreach (var connectedBlock in connectedBlocks)
    {
        var connectedSubtype = ((IMyCubeBlock)connectedBlock).BlockDefinition.SubtypeName;
        bool valid = parts.Add((IMyCubeBlock)connectedBlock);

        if (connectedSubtype == stopAtSubtype)
            stopHits++;

        if (!visitedBlocks.Contains(connectedBlock) && connectedSubtype != stopAtSubtype)
        {
            visitedBlocks.Add(connectedBlock);
            PerformScan(connectedBlock, ref parts, stopAtSubtype, ref stopHits, visitedBlocks);
        }
    }
    
    return stopHits >= 2;
}
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.FusionParts.FusionReactor;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.FusionParts.FusionThruster;
using Sandbox.ModAPI;
using VRage.Game.Entity;
using VRage.Game.ModAPI;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    FusionParts
{
    internal class S_FusionSystem
    {
        public const float MegawattsPerFusionPower = 29;
        public const float NewtonsPerFusionPower = 3200000;

        public List<S_FusionArm> Arms = new List<S_FusionArm>();
        public int BlockCount = 0;
        public int PhysicalAssemblyId;

        /// <summary>
        /// Total power generated minus PowerConsumption
        /// </summary>
        public float PowerGeneration;
        /// <summary>
        /// Total power consumed
        /// </summary>
        public float PowerConsumption;
        /// <summary>
        /// Current power stored
        /// </summary>
        public float PowerStored;
        /// <summary>
        /// Maximum power storage
        /// </summary>
        public float MaxPowerStored;
        public List<FusionReactorLogic> Reactors = new List<FusionReactorLogic>();
        public List<FusionThrusterLogic> Thrusters = new List<FusionThrusterLogic>();

        public S_FusionSystem(int physicalAssemblyId)
        {
            PhysicalAssemblyId = physicalAssemblyId;
        }

        private static ModularDefinitionAPI ModularAPI => ModularDefinition.ModularAPI;

        public void AddPart(IMyCubeBlock newPart)
        {
            if (newPart == null)
                return;

            BlockCount++;

            // Scan for 'arms' connected on both ends to the feeder block.
            switch (newPart.BlockDefinition.SubtypeName)
            {
                case "Caster_Accelerator_0":
                case "Caster_Accelerator_90":
                    var newArm = new S_FusionArm((MyEntity)newPart, "Caster_Feeder");
                    if (newArm.IsValid)
                    {
                        Arms.Add(newArm);
                        UpdatePower(true);
                    }
                    break;
                case "Caster_Feeder": // This is awful and I hate it. The idea is to generate new loops if a feeder is placed.
                    List<MyEntity> connectedAccelerators = new List<MyEntity>();
                    foreach (var connectedBlock in ModularAPI.GetConnectedBlocks((MyEntity)newPart))
                    {
                        string subtype = (connectedBlock as IMyCubeBlock)?.BlockDefinition.SubtypeName;
                        if (subtype != "Caster_Accelerator_0" && subtype != "Caster_Accelerator_90")
                            continue;
                        connectedAccelerators.Add(connectedBlock);
                    }
                    
                    foreach (var accelerator in connectedAccelerators)
                    {
                        if (Arms.Any(arm => arm.Parts.Contains((IMyCubeBlock)accelerator)))
                            continue;

                        bool accelsShareArm = false;
                        var newArm2 = new S_FusionArm(accelerator, "Caster_Feeder");
                        if (newArm2.IsValid)
                        {
                            Arms.Add(newArm2);
                            UpdatePower(true);
                    
                            foreach (var accelerator2 in connectedAccelerators)
                                if (accelerator2 != accelerator && newArm2.Parts.Contains((IMyCubeBlock) accelerator2))
                                    accelsShareArm = true;
                        }
                        MyAPIGateway.Utilities.ShowNotification(newArm2.Parts.Contains(newPart) + "C");
                        if (accelsShareArm)
                            break;
                    }
                    break;
            }
            
            if (newPart is IMyThrust)
            {
                var logic = newPart.GameLogic.GetAs<FusionThrusterLogic>();
                if (logic != null)
                {
                    Thrusters.Add(logic);
                    logic.MemberSystem = this;
                    logic.UpdatePower(PowerGeneration, NewtonsPerFusionPower);
                }
            }

            if (newPart is IMyReactor)
            {
                var logic = newPart.GameLogic.GetAs<FusionReactorLogic>();
                if (logic != null)
                {
                    Reactors.Add(logic);
                    logic.MemberSystem = this;
                    logic.UpdatePower(PowerGeneration, MegawattsPerFusionPower);
                }
            }

            UpdatePower();
        }

        public void RemovePart(IMyCubeBlock part)
        {
            if (part == null)
                return;

            BlockCount--;

            if (part is IMyThrust)
            {
                var logic = part.GameLogic.GetAs<FusionThrusterLogic>();
                logic.MemberSystem = null;
                Thrusters.Remove(logic);
            }

            if (part is IMyReactor)
            {
                var logic = part.GameLogic.GetAs<FusionReactorLogic>();
                logic.MemberSystem = null;
                Reactors.Remove(logic);
            }

            foreach (var arm in Arms.ToList())
                if (arm.Parts.Contains(part))
                {
                    Arms.Remove(arm);
                    UpdatePower(true);
                }

            if (BlockCount <= 0)
                S_FusionManager.I.FusionSystems.Remove(PhysicalAssemblyId);

            UpdatePower();
        }

        private void UpdatePower(bool updateReactors = false)
        {
            var powerGeneration = float.Epsilon;
            var powerCapacity = float.Epsilon;
            var totalPowerUsage = 0f;

            foreach (var arm in Arms)
            {
                powerGeneration += arm.PowerGeneration;
                powerCapacity += arm.PowerStorage;
            }

            // Math for slider on reactor parts to allow for a power <-> efficiency tradeoff.
            if (updateReactors)
            {
                foreach (var reactor in Reactors)
                {
                    reactor?.UpdatePower(powerGeneration, MegawattsPerFusionPower);
                    totalPowerUsage += reactor?.PowerConsumption ?? 0;
                }

            foreach (var thruster in Thrusters)
            {
                totalPowerUsage += thruster?.PowerConsumption ?? 0;

                if (updateReactors)
                    thruster?.UpdatePower(powerGeneration, NewtonsPerFusionPower);
            }
            else
            {
                foreach (var reactor in Reactors)
                {
                    totalPowerUsage += reactor?.PowerConsumption ?? 0;
                }

                foreach (var thruster in Thrusters)
                {
                    totalPowerUsage += thruster?.PowerConsumption ?? 0;
                }
            }


            // Subtract power usage afterwards so that all reactors have the same stats.
            PowerGeneration = powerGeneration;
            MaxPowerStored = powerCapacity;
            PowerConsumption = totalPowerUsage;
            PowerGeneration -= totalPowerUsage;

            // Update PowerStored
            PowerStored += PowerGeneration;
            if (PowerStored > MaxPowerStored)
            {
                PowerStored = MaxPowerStored;
                //PowerGeneration = 0;
            }
        }
        public void UpdateTick()
        {
            UpdatePower();
        }

        private void RemoveBlockInLoops(MyEntity entity)
        {
            foreach (var loop in Arms.ToList())
            {
                if (loop.Parts.Contains((IMyCubeBlock)entity))
                {
                    Arms.Remove(loop);
                }
            }
        }
    }
}﻿using System;
using Sandbox.Common.ObjectBuilders;
using Sandbox.ModAPI;
using VRage.Game.Components;
using VRage.ModAPI;
using VRage.ObjectBuilders;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.
    FusionParts.FusionReactor
{
    [MyEntityComponentDescriptor(typeof(MyObjectBuilder_Reactor), false, "Caster_Reactor")]
    public class FusionReactorLogic : FusionPart<IMyReactor>
    {
        private const float MaxPowerPerReactor = 2000;

        private float BufferReactorOutput;


        internal override string BlockSubtype => "Caster_Reactor";
        internal override string ReadableName => "Reactor";


        public override void UpdatePower(float PowerGeneration, float MegawattsPerFusionPower)
        {
            BufferPowerGeneration = PowerGeneration;

            var reactorConsumptionMultiplier =
                OverrideEnabled.Value
                    ? OverridePowerUsageSync
                    : PowerUsageSync.Value; // This is ugly, let's make it better.
            // Power generation consumed (per second)
            var powerConsumption = PowerGeneration * 60 * reactorConsumptionMultiplier;

            var reactorEfficiencyMultiplier = 1 / (0.8f + reactorConsumptionMultiplier);

            // Power generated (per second)
            var reactorOutput = reactorEfficiencyMultiplier * powerConsumption * MegawattsPerFusionPower;

            if (reactorOutput > MaxPowerPerReactor)
            {
                reactorOutput = MaxPowerPerReactor;
                powerConsumption = GetConsumptionFromPower(reactorOutput, MegawattsPerFusionPower);
            }

            BufferReactorOutput = reactorOutput;
            MaxPowerConsumption = powerConsumption / 60;

            InfoText.Clear();
            InfoText.AppendLine(
                $"\nOutput: {Math.Round(reactorOutput, 1)}/{Math.Round(PowerGeneration * 60 * MegawattsPerFusionPower, 1)}");
            InfoText.AppendLine($"Input: {Math.Round(powerConsumption, 1)}/{Math.Round(PowerGeneration * 60, 1)}");
            InfoText.AppendLine($"Efficiency: {Math.Round(reactorEfficiencyMultiplier * 100)}%");

            // Convert back into power per tick
            SyncMultipliers.ReactorOutput(Block, BufferReactorOutput);
        }

        private float GetConsumptionFromPower(float reactorOutput, float MegawattsPerFusionPower)
        {
            return reactorOutput / MegawattsPerFusionPower;
        }

        public void SetPowerBoost(bool value)
        {
            if (OverrideEnabled.Value == value)
                return;

            OverrideEnabled.Value = value;
            UpdatePower(BufferPowerGeneration, S_FusionSystem.MegawattsPerFusionPower);
        }

        #region Base Methods

        public override void Init(MyObjectBuilder_EntityBase definition)
        {
            base.Init(definition);
            Block = (IMyReactor)Entity;
            NeedsUpdate |= MyEntityUpdateEnum.BEFORE_NEXT_FRAME;

            // Trigger power update is only needed when OverrideEnabled is false
            PowerUsageSync.ValueChanged += value =>
            {
                if (!OverrideEnabled.Value)
                    UpdatePower(BufferPowerGeneration, S_FusionSystem.MegawattsPerFusionPower);
            };

            // Trigger power update is only needed when OverrideEnabled is true
            OverridePowerUsageSync.ValueChanged += value =>
            {
                if (OverrideEnabled.Value)
                    UpdatePower(BufferPowerGeneration, S_FusionSystem.MegawattsPerFusionPower);
            };

            // Trigger power update if boostEnabled is changed
            OverrideEnabled.ValueChanged += value =>
                UpdatePower(BufferPowerGeneration, S_FusionSystem.MegawattsPerFusionPower);
        }

        public override void UpdateAfterSimulation()
        {
            base.UpdateAfterSimulation();
            float storagePct = MemberSystem?.PowerStored / MemberSystem?.MaxPowerStored ?? 0;

            if (storagePct <= 0)
            {
                if (Block.MaxOutput == 0)
                    return;
                SyncMultipliers.ReactorOutput(Block, 0);
                PowerConsumption = 0;
                LastShutdown = DateTime.Now.Ticks + 4 * TimeSpan.TicksPerSecond;
                return;
            }

            // If boost is unsustainable, disable it.
            // If power draw exceeds power available, disable self until available.
            if ((OverrideEnabled.Value && MemberSystem?.PowerStored <= MemberSystem?.PowerConsumption * 30) || !Block.IsWorking)
            {
                SetPowerBoost(false);
                PowerConsumption = 0;
                SyncMultipliers.ReactorOutput(Block, 0);
            }
            else if (storagePct > 0.025f && DateTime.Now.Ticks > LastShutdown)
            {
                SyncMultipliers.ReactorOutput(Block, BufferReactorOutput);
                PowerConsumption = MaxPowerConsumption * Block.CurrentOutputRatio;
            }
        }

        #endregion
    }
}﻿using System;
using Sandbox.Common.ObjectBuilders;
using Sandbox.ModAPI;
using VRage.Game.Components;
using VRage.ModAPI;
using VRage.ObjectBuilders;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.FusionParts.FusionThruster
{
    [MyEntityComponentDescriptor(typeof(MyObjectBuilder_Thrust), false, "Caster_FocusLens")]
    public class FusionThrusterLogic : FusionPart<IMyThrust>
    {
        private float BufferThrustOutput;


        internal override string BlockSubtype => "Caster_FocusLens";
        internal override string ReadableName => "Thruster";

        public override void UpdatePower(float PowerGeneration, float NewtonsPerFusionPower)
        {
            BufferPowerGeneration = PowerGeneration;

            var consumptionMultiplier =
                OverrideEnabled.Value
                    ? OverridePowerUsageSync
                    : PowerUsageSync.Value; // This is ugly, let's make it better.

            // Power generation consumed (per second)
            var powerConsumption = PowerGeneration * 60 * consumptionMultiplier;

            var efficiencyMultiplier = 1 / (0.8f + consumptionMultiplier);

            // Power generated (per second)
            var thrustOutput = efficiencyMultiplier * powerConsumption * NewtonsPerFusionPower;
            BufferThrustOutput = thrustOutput;
            MaxPowerConsumption = powerConsumption / 60;

            InfoText.Clear();
            InfoText.AppendLine(
                $"\nOutput: {Math.Round(thrustOutput, 1)}/{Math.Round(PowerGeneration * 60 * NewtonsPerFusionPower, 1)}");
            InfoText.AppendLine($"Input: {Math.Round(powerConsumption, 1)}/{Math.Round(PowerGeneration * 60, 1)}");
            InfoText.AppendLine($"Efficiency: {Math.Round(efficiencyMultiplier * 100)}%");

            // Convert back into power per tick
            SyncMultipliers.ThrusterOutput(Block, BufferThrustOutput);
        }

        public void SetPowerBoost(bool value)
        {
            if (OverrideEnabled.Value == value)
                return;

            OverrideEnabled.Value = value;
            UpdatePower(BufferPowerGeneration, S_FusionSystem.NewtonsPerFusionPower);
        }

        #region Base Methods

        public override void Init(MyObjectBuilder_EntityBase definition)
        {
            base.Init(definition);
            Block = (IMyThrust)Entity;
            NeedsUpdate |= MyEntityUpdateEnum.BEFORE_NEXT_FRAME;

            // Trigger power update is only needed when OverrideEnabled is false
            PowerUsageSync.ValueChanged += value =>
            {
                if (!OverrideEnabled.Value)
                    UpdatePower(BufferPowerGeneration, S_FusionSystem.NewtonsPerFusionPower);
            };

            // Trigger power update is only needed when OverrideEnabled is true
            OverridePowerUsageSync.ValueChanged += value =>
            {
                if (OverrideEnabled.Value)
                    UpdatePower(BufferPowerGeneration, S_FusionSystem.NewtonsPerFusionPower);
            };

            // Trigger power update if boostEnabled is changed
            OverrideEnabled.ValueChanged += value =>
                UpdatePower(BufferPowerGeneration, S_FusionSystem.NewtonsPerFusionPower);
        }

        public override void UpdateAfterSimulation()
        {
            base.UpdateAfterSimulation();
            float storagePct = MemberSystem?.PowerStored / MemberSystem?.MaxPowerStored ?? 0;

            if (storagePct <= 0.05f)
            {
                if (Block.ThrustMultiplier == 0)
                    return;
                SyncMultipliers.ThrusterOutput(Block, 0);
                PowerConsumption = 0;
                LastShutdown = DateTime.Now.Ticks + 4 * TimeSpan.TicksPerSecond;
                return;
            }

            // If boost is unsustainable, disable it.
            // If power draw exceeds power available, disable self until available.
            if ((OverrideEnabled.Value && MemberSystem?.PowerStored <= MemberSystem?.PowerConsumption * 30) || !Block.IsWorking)
            {
                SetPowerBoost(false);
                PowerConsumption = 0;
                SyncMultipliers.ThrusterOutput(Block, 0);
            }
            else if (storagePct > 0.1f && DateTime.Now.Ticks > LastShutdown)
            {
                SyncMultipliers.ThrusterOutput(Block, BufferThrustOutput);
                PowerConsumption = MaxPowerConsumption * (Block.CurrentThrustPercentage / 100f);
            }
        }

        #endregion
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.Communication;
using RichHudFramework.Client;
using RichHudFramework.UI;
using RichHudFramework.UI.Client;
using RichHudFramework.UI.Rendering;
using Sandbox.ModAPI;
using VRage.Game.ModAPI;
using VRage.Input;
using VRage.Utils;
using VRageMath;
using VRageRender;

namespace MoA_Fusion_Systems.Data.Scripts.ModularAssemblies.HudHelpers
{
    internal class ConsumptionBar : WindowBase
    {
        private readonly TexturedBox _storageBackground; 
        private readonly TexturedBox _storageForeground;
        private bool _shouldHide = false;
        private static ModularDefinitionAPI ModularAPI => ModularDefinition.ModularAPI;


        public ConsumptionBar(HudParentBase parent) : base(parent)
        {
            _storageForeground = new TexturedBox(body)
            {
                Material = new Material("fusionBarBackground", Vector2.One * 100),
                ParentAlignment = ParentAlignments.Bottom | ParentAlignments.InnerV,
                DimAlignment = DimAlignments.Width,
                Color = new Color(1, 1, 1, 0.75f),
            };
            
            _storageBackground = new TexturedBox(body)
            {
                Material = new Material("fusionBarForeground", Vector2.One * 100),
                ParentAlignment = ParentAlignments.Center,
                DimAlignment = DimAlignments.Both,
                Color = new Color(1, 1, 1, 1f),
            };

            BodyColor = new Color(0, 0, 0, 0);
            BorderColor = new Color(0, 0, 0, 0);

            header.Format = new GlyphFormat(GlyphFormat.Blueish.Color, TextAlignment.Center, 1f);
            header.Height = 30f;

            HeaderText = "Fusion | 0s";
            Size = new Vector2(100f, 300f);
            Offset = new Vector2(-HudMain.ScreenWidth/(2.01f*HudMain.ResScale) + Width/2, 0); // Relative to 1920x1080
        }

        protected override void Layout()
        {
            base.Layout();

            MinimumSize = new Vector2(Math.Max(1, MinimumSize.X), MinimumSize.Y);
        }

        public void Update()
        {
            var playerCockpit = MyAPIGateway.Session?.Player?.Controller?.ControlledEntity?.Entity as IMyShipController;

            // Pulling the current HudState is SLOOOOWWWW, so we only pull it when tab is just pressed.
            if (MyAPIGateway.Input.IsNewKeyPressed(MyKeys.Tab))
                _shouldHide = MyAPIGateway.Session?.Config?.HudState != 1;

            // Hide HUD element if the player isn't in a cockpit
            if (playerCockpit == null || _shouldHide)
            {
                if (Visible)
                {
                    Visible = false;
                }
                return;
            }

            var playerGrid = playerCockpit.CubeGrid;

            float totalFusionCapacity = 0;
            float totalFusionGeneration = 0;
            float totalFusionStored = 0;
            foreach (var system in S_FusionManager.I.FusionSystems)
            {
                if (playerGrid != ModularAPI.GetAssemblyGrid(system.Key))
                    continue;

                totalFusionCapacity += system.Value.MaxPowerStored;
                totalFusionGeneration += system.Value.PowerGeneration;
                totalFusionStored += system.Value.PowerStored;
            }

            // Hide HUD element if the grid has no fusion systems (capacity is always >0 for a fusion system)
            if (totalFusionCapacity == 0)
            {
                if (Visible)
                {
                    Visible = false;
                }
                return;
            }

            // Show otherwise
            if (!Visible)
            {
                Visible = true;
            }

            float storagePct = totalFusionStored / totalFusionCapacity;
            float timeToCharge;

            if (totalFusionGeneration > 0)
            {
                timeToCharge = (totalFusionCapacity - totalFusionStored) / totalFusionGeneration / 60;
            }
            else if (totalFusionGeneration < 0)
            {
                timeToCharge = totalFusionStored / -totalFusionGeneration / 60;
            }
            else
            {
                timeToCharge = 0;
            }

            HeaderText = $"Fusion | {(totalFusionGeneration > 0 ? "+" : "-")}{Math.Round(timeToCharge)}s";
            _storageForeground.Height = storagePct * _storageBackground.Height;
            //_storageForeground.Origin = new Vector2D(_storageForeground.Origin.X, _storageForeground.Width * 0.75 - _storageBackground.Width*0.35); // THIS SHOULD BE RICHHUD!
        }
    }
}
﻿using RichHudFramework;
using RichHudFramework.Internal;
using RichHudFramework.IO;
using Sandbox.ModAPI;
using System;
using VRage;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using ClientData = VRage.MyTuple<string, System.Action<int, object>, System.Action, int>;
using ServerData = VRage.MyTuple<System.Action, System.Func<int, object>, int>;

namespace RichHudFramework.Client
{
    using ExtendedClientData = MyTuple<ClientData, Action<Action>, ApiMemberAccessor>;

    /// <summary>
    /// API Client for the Rich HUD Framework 
    /// </summary>
    public sealed class RichHudClient : RichHudComponentBase
    {
        public static readonly Vector4I versionID = new Vector4I(1, 2, 3, 1); // Major, Minor, Rev, Hotfix
        public const ClientSubtypes subtype = ClientSubtypes.NoLib;

        private const long modID = 1965654081, queueID = 1314086443;
        private const int vID = 10;

        public static bool Registered => Instance != null ? Instance.registered : false;
        private static RichHudClient Instance { get; set; }

        private readonly ExtendedClientData regMessage;
        private readonly Action InitAction, OnResetAction;

        private bool regFail, registered, inQueue;
        private Func<int, object> GetApiDataFunc;
        private Action UnregisterAction;

        private RichHudClient(string modName, Action InitCallback, Action ResetCallback) : base(false, true)
        {
            InitAction = InitCallback;
            OnResetAction = ResetCallback;

            ExceptionHandler.ModName = modName;

            if (LogIO.FileName == null || LogIO.FileName == "modLog.txt")
                LogIO.FileName = $"richHudLog.txt";

            var clientData = new ClientData(modName, MessageHandler, RemoteReset, vID);
            regMessage = new ExtendedClientData(clientData, ExceptionHandler.Run, GetOrSetMember);
        }

        /// <summary>
        /// Initialzes and registers the client with the API if it is not already registered.
        /// </summary>
        /// <param name="modName">Name of the mod as it appears in the settings menu and in diagnostics</param>
        /// <param name="InitCallback">Invoked upon successfully registering with the API.</param>
        /// <param name="ResetCallback">Invoked on client reset.</param>
        public static void Init(string modName, Action InitCallback, Action ResetCallback)
        {
            if (Instance == null)
            {
                Instance = new RichHudClient(modName, InitCallback, ResetCallback);
                Instance.RequestRegistration();

                if (!Registered && !Instance.regFail)
                {
                    Instance.EnterQueue();
                }
            }
        }

        /// <summary>
        /// Unregisters the client and resets all framework modules.
        /// </summary>
        public static void Reset()
        {
            if (Registered)
                ExceptionHandler.ReloadClients();
        }

        /// <summary>
        /// Handles registration response.
        /// </summary>
        private void MessageHandler(int typeValue, object message)
        {
            MsgTypes msgType = (MsgTypes)typeValue;

            if (!regFail)
            {
                if (!Registered)
                {
                    if ((msgType == MsgTypes.RegistrationSuccessful) && message is ServerData)
                    {
                        var data = (ServerData)message;
                        UnregisterAction = data.Item1;
                        GetApiDataFunc = data.Item2;

                        registered = true;

                        ExceptionHandler.Run(InitAction);
                        ExceptionHandler.WriteToLog($"[RHF] Successfully registered with Rich HUD Master.");
                    }
                    else if (msgType == MsgTypes.RegistrationFailed)
                    {
                        if (message is string)
                            ExceptionHandler.WriteToLog($"[RHF] Failed to register with Rich HUD Master. Message: {message as string}");
                        else
                            ExceptionHandler.WriteToLog($"[RHF] Failed to register with Rich HUD Master.");

                        regFail = true;
                    }
                }
            }
        }

        private object GetOrSetMember(object data, int memberEnum)
        {
            switch((ClientDataAccessors)memberEnum)
            {
                case ClientDataAccessors.GetVersionID:
                    return versionID;
                case ClientDataAccessors.GetSubtype:
                    return subtype;
            }

            return null;
        }

        /// <summary>
        /// Attempts to register the client with the API
        /// </summary>
        private void RequestRegistration() =>
            MyAPIUtilities.Static.SendModMessage(modID, regMessage);

        /// <summary>
        /// Enters queue to await client registration.
        /// </summary>
        private void EnterQueue() =>
            MyAPIUtilities.Static.RegisterMessageHandler(queueID, QueueHandler);

        /// <summary>
        /// Unregisters callback for framework client queue.
        /// </summary>
        private void ExitQueue() =>
            MyAPIUtilities.Static.UnregisterMessageHandler(queueID, QueueHandler);

        /// <summary>
        /// Resend registration request on queue invocation.
        /// </summary>
        private void QueueHandler(object message)
        {
            if (!(registered || regFail))
            {
                inQueue = true;
                RequestRegistration();
            }
        }

        public override void Update()
        {
            if (registered && inQueue)
            {
                ExitQueue();
                inQueue = false;
            }
        }

        public override void Close()
        {
            ExitQueue();
            Unregister();
            Instance = null;
        }

        private void RemoteReset()
        {
            ExceptionHandler.Run(() => 
            {
                if (registered)
                {
                    ExceptionHandler.ReloadClients();
                    OnResetAction();
                }
            });  
        }

        /// <summary>
        /// Unregisters client from API
        /// </summary>
        private void Unregister()
        {
            if (registered)
            {
                registered = false;
                UnregisterAction();
            }
        }

        /// <summary>
        /// Base class for types acting as modules for the API
        /// </summary>
        public abstract class ApiModule<T> : RichHudComponentBase
        {
            protected readonly ApiModuleTypes componentType;

            public ApiModule(ApiModuleTypes componentType, bool runOnServer, bool runOnClient) : base(runOnServer, runOnClient)
            {
                if (!Registered)
                    throw new Exception("Types of ApiModule cannot be instantiated before RichHudClient is initialized.");

                this.componentType = componentType;
            }

            protected T GetApiData()
            {
                object data = Instance?.GetApiDataFunc((int)componentType);

                return (T)data;
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;

namespace RichHudFramework
{
    using EventData = MyTuple<bool, Action>;

    namespace UI.Client
    {
        public sealed partial class BindManager
        {
            private partial class BindGroup
            {
                public class Bind : IBind
                {
                    /// <summary>
                    /// Name of the keybind
                    /// </summary>
                    public string Name => _instance.GetOrSetBindMemberFunc(index, null, (int)BindAccesssors.Name) as string;

                    /// <summary>
                    /// Index of the bind within its group
                    /// </summary>
                    public int Index => index.Y;

                    /// <summary>
                    /// True if any controls in the bind are marked analog. For these types of binds, IsPressed == IsNewPressed.
                    /// </summary>
                    public bool Analog => (bool)_instance.GetOrSetBindMemberFunc(index, null, (int)BindAccesssors.Analog);

                    /// <summary>
                    /// True if currently pressed.
                    /// </summary>
                    public bool IsPressed => _instance.IsBindPressedFunc(index, (int)BindAccesssors.IsPressed);

                    /// <summary>
                    /// True after being held for more than 500ms.
                    /// </summary>
                    public bool IsPressedAndHeld => _instance.IsBindPressedFunc(index, (int)BindAccesssors.IsPressedAndHeld);

                    /// <summary>
                    /// True if just pressed.
                    /// </summary>
                    public bool IsNewPressed => _instance.IsBindPressedFunc(index, (int)BindAccesssors.IsNewPressed);

                    /// <summary>
                    /// True if just released.
                    /// </summary>
                    public bool IsReleased => _instance.IsBindPressedFunc(index, (int)BindAccesssors.IsReleased);

                    /// <summary>
                    /// Invoked when the bind is first pressed.
                    /// </summary>
                    public event EventHandler NewPressed;

                    /// <summary>
                    /// Invoked after the bind has been held and pressed for at least 500ms.
                    /// </summary>
                    public event EventHandler PressedAndHeld;

                    /// <summary>
                    /// Invoked after the bind has been released.
                    /// </summary>
                    public event EventHandler Released;

                    private readonly Vector2I index;

                    public Bind(Vector2I index)
                    {
                        this.index = index;
                        _instance.GetOrSetBindMemberFunc(index, new EventData(true, OnNewPressed), (int)BindAccesssors.OnNewPress);
                        _instance.GetOrSetBindMemberFunc(index, new EventData(true, OnPressedAndHeld), (int)BindAccesssors.OnPressAndHold);
                        _instance.GetOrSetBindMemberFunc(index, new EventData(true, OnReleased), (int)BindAccesssors.OnRelease);
                    }

                    private void OnNewPressed()
                    {
                        NewPressed?.Invoke(this, EventArgs.Empty);
                    }

                    private void OnPressedAndHeld()
                    {
                        PressedAndHeld?.Invoke(this, EventArgs.Empty);
                    }

                    private void OnReleased()
                    {
                        Released?.Invoke(this, EventArgs.Empty);
                    }

                    /// <summary>
                    /// Returns a list of the current key combo for this bind.
                    /// </summary>
                    public List<IControl> GetCombo() 
                    {
                        var indices = _instance.GetOrSetBindMemberFunc(index, null, (int)BindAccesssors.GetCombo) as List<int>;
                        var combo = new List<IControl>(indices.Count);

                        for (int n = 0; n < indices.Count; n++)
                            combo.Add(_instance.controls[indices[n]]);

                        return combo;
                    }

                    /// <summary>
                    /// Returns a list of control indices for the current bind combo
                    /// </summary>
                    public List<int> GetComboIndices() =>
                        _instance.GetOrSetBindMemberFunc(index, null, (int)BindAccesssors.GetCombo) as List<int>;

                    /// <summary>
                    /// Attempts to set the binds combo to the given controls. Returns true if successful.
                    /// </summary>
                    public bool TrySetCombo(IReadOnlyList<IControl> combo, bool strict = true, bool silent = true)
                    {
                        var indices = new int[combo.Count];

                        for (int n = 0; n < combo.Count; n++)
                            indices[n] = combo[n].Index;

                        var comboData = new MyTuple<IReadOnlyList<int>, bool, bool>(indices, strict, silent);
                        return (bool)_instance.GetOrSetBindMemberFunc(index, comboData, (int)BindAccesssors.TrySetComboWithIndices);
                    }

                    /// <summary>
                    /// Attempts to set the binds combo to the given controls. Returns true if successful.
                    /// </summary>
                    public bool TrySetCombo(IReadOnlyList<int> combo, bool strict = true, bool silent = true)
                    {
                        var comboData = new MyTuple<IReadOnlyList<int>, bool, bool>(combo, strict, silent);
                        return (bool)_instance.GetOrSetBindMemberFunc(index, comboData, (int)BindAccesssors.TrySetComboWithIndices);
                    }

                    /// <summary>
                    /// Attempts to set the binds combo to the given controls. Returns true if successful.
                    /// </summary>
                    public bool TrySetCombo(IReadOnlyList<string> combo, bool strict = true, bool silent = true)
                    {
                        var comboData = new MyTuple<IReadOnlyList<string>, bool, bool>(combo, strict, silent);
                        return (bool)_instance.GetOrSetBindMemberFunc(index, comboData, (int)BindAccesssors.TrySetComboWithNames);
                    }

                    /// <summary>
                    /// Clears the current key combination.
                    /// </summary>
                    public void ClearCombo() =>
                        _instance.GetOrSetBindMemberFunc(index, null, (int)BindAccesssors.ClearCombo);

                    /// <summary>
                    /// Clears all event subscibers for this bind.
                    /// </summary>
                    public void ClearSubscribers() =>
                        _instance.GetOrSetBindMemberFunc(index, null, (int)BindAccesssors.ClearSubscribers);

                    public override bool Equals(object obj)
                    {
                        return ((Bind)obj).index == index;
                    }

                    public override int GetHashCode()
                    {
                        return index.GetHashCode();
                    }
                }
            }
        }
    }
}﻿using System.Collections.Generic;
using System;
using VRage;
using VRageMath;
using BindDefinitionData = VRage.MyTuple<string, string[]>;

namespace RichHudFramework
{
    namespace UI.Client
    {
        public sealed partial class BindManager
        {
            // <summary>
            /// A collection of unique keybinds.
            /// </summary>
            private partial class BindGroup : ReadOnlyApiCollection<IBind>, IBindGroup
            {
                /// <summary>
                /// Returns the bind with the name given, if it exists.
                /// </summary>
                public IBind this[string name] 
                { 
                    get 
                    {
                        IBind bind = GetBind(name);

                        if (bind == null)
                            throw new Exception($"Bind: {name} was not found in bind group {Name}.");
                        else
                            return bind;
                    } 
                }

                /// <summary>
                /// Bind group name
                /// </summary>
                public string Name => _instance.GetOrSetGroupMemberFunc(Index, null, (int)BindGroupAccessors.Name) as string;

                /// <summary>
                /// Index of the bind group in its associated client
                /// </summary>
                public int Index { get; }

                /// <summary>
                /// Unique identifer
                /// </summary>
                public object ID => _instance.GetOrSetGroupMemberFunc(Index, null, (int)BindGroupAccessors.ID);

                public BindGroup(int index) 
                    : base(x => new Bind(new Vector2I(index, x)), () => _instance.GetBindCountFunc(index))
                {
                    Index = index;
                }

                /// <summary>
                /// Returns true if the group contains a bind with the given name.
                /// </summary>
                public bool DoesBindExist(string name) =>
                    (bool)_instance.GetOrSetGroupMemberFunc(Index, name, (int)BindGroupAccessors.DoesBindExist);

                /// <summary>
                /// Returns true if the given list of controls conflicts with any existing binds.
                /// </summary>
                public bool DoesComboConflict(IReadOnlyList<IControl> newCombo, IBind exception = null)
                {
                    var indices = new int[newCombo.Count];

                    for (int n = 0; n < newCombo.Count; n++)
                        indices[n] = newCombo[n].Index;

                    var data = new MyTuple<IReadOnlyList<int>, int>(indices, exception?.Index ?? -1);
                    return (bool)_instance.GetOrSetGroupMemberFunc(Index, data, (int)BindGroupAccessors.DoesComboConflict);
                }

                /// <summary>
                /// Determines if given combo is equivalent to any existing binds.
                /// </summary>
                public bool DoesComboConflict(IReadOnlyList<int> newCombo, int exception = -1)
                {
                    var data = new MyTuple<IReadOnlyList<int>, int>(newCombo, exception);
                    return (bool)_instance.GetOrSetGroupMemberFunc(Index, data, (int)BindGroupAccessors.DoesComboConflict);
                }

                /// <summary>
                /// Replaces current bind combos with combos based on the given <see cref="BindDefinition"/>[]. Does not register new binds.
                /// </summary>
                public bool TryLoadBindData(IReadOnlyList<BindDefinitionData> bindData) =>
                    (bool)_instance.GetOrSetGroupMemberFunc(Index, bindData, (int)BindGroupAccessors.TryLoadBindData);

                /// <summary>
                /// Attempts to load bind combinations from bind data. Will not register new binds.
                /// </summary>
                public bool TryLoadBindData(IReadOnlyList<BindDefinition> bindData)
                {
                    var defData = new BindDefinitionData[bindData.Count];

                    for (int n = 0; n < bindData.Count; n++)
                        defData[n] = new BindDefinitionData(bindData[n].name, bindData[n].controlNames);

                    return (bool)_instance.GetOrSetGroupMemberFunc(Index, defData, (int)BindGroupAccessors.TryLoadBindData);
                }

                /// <summary>
                /// Registers a list of binds using the names given.
                /// </summary>
                public void RegisterBinds(IReadOnlyList<string> bindNames) =>
                    _instance.GetOrSetGroupMemberFunc(Index, bindNames, (int)BindGroupAccessors.RegisterBindNames);

                /// <summary>
                /// Attempts to register a set of binds with the given names.
                /// </summary>
                public void RegisterBinds(BindGroupInitializer bindData)
                {
                    foreach (var bind in bindData)
                        _instance.GetOrSetGroupMemberFunc(Index, bind, (int)BindGroupAccessors.AddBindWithIndices);
                }

                /// <summary>
                /// Registers a list of binds using the names given paired with associated control indices.
                /// </summary>
                public void RegisterBinds(IReadOnlyList<MyTuple<string, IReadOnlyList<int>>> bindData) =>
                    _instance.GetOrSetGroupMemberFunc(Index, bindData, (int)BindGroupAccessors.RegisterBindIndices);

                /// <summary>
                /// Registers and loads bind combinations from BindDefinitions.
                /// </summary>
                public void RegisterBinds(IReadOnlyList<BindDefinition> bindData)
                {
                    var defData = new BindDefinitionData[bindData.Count];

                    for (int n = 0; n < bindData.Count; n++)
                        defData[n] = new BindDefinitionData(bindData[n].name, bindData[n].controlNames);

                    _instance.GetOrSetGroupMemberFunc(Index, defData, (int)BindGroupAccessors.RegisterBindDefinitions);
                }

                /// <summary>
                /// Registers and loads bind combinations from BindDefinitionData.
                /// </summary>
                public void RegisterBinds(IReadOnlyList<BindDefinitionData> bindData) =>
                    _instance.GetOrSetGroupMemberFunc(Index, bindData, (int)BindGroupAccessors.RegisterBindDefinitions);

                /// <summary>
                /// Returns the bind with the name given, if it exists.
                /// </summary>
                public IBind GetBind(string name)
                {
                    var index = (Vector2I)_instance.GetOrSetGroupMemberFunc(Index, name, (int)BindGroupAccessors.GetBindFromName);
                    return index.Y != -1 ? this[index.Y] : null;
                }

                /// <summary>
                /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
                /// </summary>
                public IBind AddBind(string bindName, IReadOnlyList<int> combo)
                {
                    var index = (Vector2I)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<int>>(bindName, combo), (int)BindGroupAccessors.AddBindWithIndices);
                    return this[index.Y];
                }

                /// <summary>
                /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
                /// </summary>
                public IBind AddBind(string bindName, IReadOnlyList<string> combo)
                {
                    var index = (Vector2I)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<string>>(bindName, combo), (int)BindGroupAccessors.AddBindWithNames);
                    return this[index.Y];
                }

                /// <summary>
                /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
                /// </summary>
                public IBind AddBind(string bindName, IReadOnlyList<ControlData> combo = null)
                {
                    var indices = new int[combo.Count];

                    for (int n = 0; n < combo.Count; n++)
                        indices[n] = combo[n].index;

                    var index = (Vector2I)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<int>>(bindName, indices), (int)BindGroupAccessors.AddBindWithIndices);
                    return this[index.Y];
                }

                /// <summary>
                /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
                /// </summary>
                public IBind AddBind(string bindName, IReadOnlyList<IControl> combo = null)
                {
                    var indices = new int[combo.Count];

                    for (int n = 0; n < combo.Count; n++)
                        indices[n] = combo[n].Index;

                    var index = (Vector2I)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<int>>(bindName, indices), (int)BindGroupAccessors.AddBindWithIndices);
                    return this[index.Y];
                }

                /// <summary>
                /// Tries to register an empty bind using the given name.
                /// </summary>
                public bool TryRegisterBind(string bindName, out IBind newBind)
                {
                    int index = (int)_instance.GetOrSetGroupMemberFunc(Index, bindName, (int)BindGroupAccessors.TryRegisterBindName);

                    if (index != -1)
                    {
                        newBind = this[index];
                        return true;
                    }
                    else
                    {
                        newBind = null;
                        return false;
                    }
                }

                /// <summary>
                /// Tries to register a bind using the given name and the given key combo.
                /// </summary>
                public bool TryRegisterBind(string bindName, IReadOnlyList<int> combo, out IBind newBind)
                {
                    int index = (int)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<int>>(bindName, combo), (int)BindGroupAccessors.TryRegisterBindWithIndices);

                    if (index != -1)
                    {
                        newBind = this[index];
                        return true;
                    }
                    else
                    {
                        newBind = null;
                        return false;
                    }
                }

                /// <summary>
                /// Tries to register a bind using the given name and the given key combo.
                /// </summary>
                public bool TryRegisterBind(string bindName, out IBind newBind, IReadOnlyList<int> combo)
                {
                    int index = (int)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<int>>(bindName, combo), (int)BindGroupAccessors.TryRegisterBindWithIndices);

                    if (index != -1)
                    {
                        newBind = this[index];
                        return true;
                    }
                    else
                    {
                        newBind = null;
                        return false;
                    }
                }

                /// <summary>
                /// Tries to register a bind using the given name and the given key combo.
                /// </summary>
                public bool TryRegisterBind(string bindName, out IBind bind, IReadOnlyList<string> combo)
                {
                    int index = (int)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<string>>(bindName, combo), (int)BindGroupAccessors.TryRegisterBindWithNames);

                    if (index != -1)
                    {
                        bind = this[index];
                        return true;
                    }
                    else
                    {
                        bind = null;
                        return false;
                    }
                }

                /// <summary>
                /// Tries to register a bind using the given name and the given key combo.
                /// </summary>
                public bool TryRegisterBind(string bindName, out IBind newBind, IReadOnlyList<IControl> combo)
                {
                    var indices = new int[combo.Count];

                    for (int n = 0; n < combo.Count; n++)
                        indices[n] = combo[n].Index;

                    int index = (int)_instance.GetOrSetGroupMemberFunc(Index, new MyTuple<string, IReadOnlyList<int>>(bindName, indices), (int)BindGroupAccessors.TryRegisterBindWithIndices);

                    if (index != -1)
                    {
                        newBind = this[index];
                        return true;
                    }
                    else
                    {
                        newBind = null;
                        return false;
                    }
                }

                /// <summary>
                /// Retrieves the set of key binds as an array of BindDefinition
                /// </summary>
                public BindDefinition[] GetBindDefinitions()
                {
                    var bindData = _instance.GetOrSetGroupMemberFunc(Index, null, (int)BindGroupAccessors.GetBindData) as BindDefinitionData[];
                    var definitions = new BindDefinition[bindData.Length];

                    for (int n = 0; n < bindData.Length; n++)
                        definitions[n] = new BindDefinition(bindData[n].Item1, bindData[n].Item2);

                    return definitions;
                }

                /// <summary>
                /// Retrieves the set of key binds as an array of BindDefinition
                /// </summary>
                public BindDefinitionData[] GetBindData() =>
                    _instance.GetOrSetGroupMemberFunc(Index, null, (int)BindGroupAccessors.GetBindData) as BindDefinitionData[];

                /// <summary>
                /// Clears bind subscribers for the entire group
                /// </summary>
                public void ClearSubscribers() =>
                    _instance.GetOrSetGroupMemberFunc(Index, null, (int)BindGroupAccessors.ClearSubscribers);

                public override bool Equals(object obj)
                {
                    return Index.Equals(obj);
                }

                public override int GetHashCode()
                {
                    return Index.GetHashCode();
                }
            }
        }
    }
}﻿using RichHudFramework.Client;
using System;
using System.Collections.Generic;
using Sandbox.ModAPI;
using VRage;
using VRageMath;
using VRage.Input;
using BindDefinitionData = VRage.MyTuple<string, string[]>;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    using Client;
    using UI;

    namespace UI.Client
    {
        using BindClientMembers = MyTuple<
            ApiMemberAccessor, // GetOrSetMember
            MyTuple<Func<int, object, int, object>, Func<int>>, // GetOrSetGroupMember, GetGroupCount
            MyTuple<Func<Vector2I, object, int, object>, Func<int, int>>, // GetOrSetBindMember, GetBindCount
            Func<Vector2I, int, bool>, // IsBindPressed
            MyTuple<Func<int, int, object>, Func<int>>, // GetControlMember, GetControlCount
            Action // Unload
        >;

        /// <summary>
        /// Manages custom keybinds; singleton
        /// </summary>
        public sealed partial class BindManager : RichHudClient.ApiModule<BindClientMembers>
        {
            /// <summary>
            /// Read-only collection of bind groups registered
            /// </summary>
            public static IReadOnlyList<IBindGroup> Groups => Instance.groups;

            /// <summary>
            /// Read-only collection of all available controls for use with key binds
            /// </summary
            public static IReadOnlyList<IControl> Controls => Instance.controls;

            /// <summary>
            /// Specifies blacklist mode for SE controls
            /// </summary>
            public static SeBlacklistModes BlacklistMode
            {
                get 
                { 
                    if (_instance == null) Init(); 
                        return (SeBlacklistModes)_instance.GetOrSetMemberFunc(null, (int)BindClientAccessors.RequestBlacklistMode); 
                }
                set
                {
                    if (_instance == null)
                        Init();

                    lastBlacklist = value;
                    _instance.GetOrSetMemberFunc(value, (int)BindClientAccessors.RequestBlacklistMode);
                }
            }

            /// <summary>
            /// MyAPIGateway.Gui.ChatEntryVisible, but actually usable for input polling
            /// </summary>
            public static bool IsChatOpen => (bool)_instance.GetOrSetMemberFunc(null, (int)BindClientAccessors.IsChatOpen);

            private static BindManager Instance
            {
                get { Init(); return _instance; }
            }
            private static BindManager _instance;

            // Group list
            private readonly Func<int, object, int, object> GetOrSetGroupMemberFunc;
            private readonly Func<int> GetGroupCountFunc;

            // Bind lists
            private readonly Func<Vector2I, object, int, object> GetOrSetBindMemberFunc;
            private readonly Func<Vector2I, int, bool> IsBindPressedFunc;
            private readonly Func<int, int> GetBindCountFunc;

            // Control list
            private readonly Func<int, int, object> GetControlMember;
            private readonly Func<int> GetControlCountFunc;

            private readonly ApiMemberAccessor GetOrSetMemberFunc;
            private readonly Action UnloadAction;

            private readonly ReadOnlyApiCollection<IBindGroup> groups;
            private readonly ReadOnlyApiCollection<IControl> controls;

            private static SeBlacklistModes lastBlacklist, tmpBlacklist;

            private BindManager() : base(ApiModuleTypes.BindManager, false, true)
            {
                var clientData = GetApiData();

                GetOrSetMemberFunc = clientData.Item1;
                UnloadAction = clientData.Item6;

                // Group list
                GetOrSetGroupMemberFunc = clientData.Item2.Item1;
                GetGroupCountFunc = clientData.Item2.Item2;

                // Bind lists
                IsBindPressedFunc = clientData.Item4;
                GetOrSetBindMemberFunc = clientData.Item3.Item1;
                GetBindCountFunc = clientData.Item3.Item2;

                // Control list
                GetControlMember = clientData.Item5.Item1;
                GetControlCountFunc = clientData.Item5.Item2;

                groups = new ReadOnlyApiCollection<IBindGroup>(x => new BindGroup(x), GetGroupCountFunc);
                controls = new ReadOnlyApiCollection<IControl>(x => new Control(x), GetControlCountFunc);
            }

            public static void Init()
            {
                if (_instance == null)
                {
                    _instance = new BindManager();
                }
            }

            public override void Close()
            {
                UnloadAction?.Invoke();
                _instance = null;
            }

            /// <summary>
            /// Sets a temporary control blacklist cleared after every frame. Blacklists set via
            /// property will persist regardless.
            /// </summary>
            public static void RequestTempBlacklist(SeBlacklistModes mode)
            {
                tmpBlacklist |= mode;
            }

            public override void Draw()
            {
                GetOrSetMemberFunc(lastBlacklist | tmpBlacklist, (int)BindClientAccessors.RequestBlacklistMode);
                tmpBlacklist = SeBlacklistModes.None;
            }

            /// <summary>
            /// Returns the bind group with the given name and/or creates one with the name given
            /// if one doesn't exist.
            /// </summary>
            public static IBindGroup GetOrCreateGroup(string name)
            {
                var index = (int)Instance.GetOrSetMemberFunc(name, (int)BindClientAccessors.GetOrCreateGroup);
                return index != -1 ? Groups[index] : null;
            }

            /// <summary>
            /// Returns the bind group with the name igven.
            /// </summary>
            public static IBindGroup GetBindGroup(string name)
            {
                var index = (int)Instance.GetOrSetMemberFunc(name, (int)BindClientAccessors.GetBindGroup);
                return index != -1 ? Groups[index] : null;
            }

            /// <summary>
            /// Returns the control associated with the given name.
            /// </summary>
            public static IControl GetControl(string name)
            {
                var index = (int)Instance.GetOrSetMemberFunc(name, (int)BindClientAccessors.GetControlByName);
                return index != -1 ? Controls[index] : null;
            }

            /// <summary>
            /// Generates a list of controls from a list of control names.
            /// </summary>
            public static IControl[] GetCombo(IList<string> names)
            {
                IControl[] combo = new IControl[names.Count];

                for (int n = 0; n < names.Count; n++)
                    combo[n] = GetControl(names[n]);

                return combo;
            }

            /// <summary>
            /// Generates a combo array using the corresponding control indices.
            /// </summary>
            public static IControl[] GetCombo(IList<ControlData> indices)
            {
                IControl[] combo = new IControl[indices.Count];

                for (int n = 0; n < indices.Count; n++)
                    combo[n] = Controls[indices[n].index];

                return combo;
            }

            /// <summary>
            /// Generates a combo array using the corresponding control indices.
            /// </summary>
            public static IControl[] GetCombo(IList<int> indices)
            {
                IControl[] combo = new IControl[indices.Count];

                for (int n = 0; n < indices.Count; n++)
                    combo[n] = Controls[indices[n]];

                return combo;
            }

            /// <summary>
            /// Generates a list of control indices using a list of control names.
            /// </summary>
            public static int[] GetComboIndices(IList<string> controlNames) =>
                Instance.GetOrSetMemberFunc(controlNames, (int)BindClientAccessors.GetComboIndices) as int[];

            /// <summary>
            /// Returns the control associated with the given <see cref="MyKeys"/> enum.
            /// </summary>
            public static IControl GetControl(MyKeys seKey) =>
                Controls[(int)seKey];

            /// <summary>
            /// Returns the control associated with the given custom <see cref="RichHudControls"/> enum.
            /// </summary>
            public static IControl GetControl(RichHudControls rhdKey) =>
                Controls[(int)rhdKey];

            /// <summary>
            /// Generates a list of control indices from a list of controls.
            /// </summary>
            public static int[] GetComboIndices(IList<IControl> controls)
            {
                int[] indices = new int[controls.Count];

                for (int n = 0; n < controls.Count; n++)
                    indices[n] = controls[n].Index;

                return indices;
            }

            /// <summary>
            /// Generates a list of control indices from a list of controls.
            /// </summary>
            public static int[] GetComboIndices(IList<ControlData> controls)
            {
                int[] indices = new int[controls.Count];

                for (int n = 0; n < controls.Count; n++)
                    indices[n] = controls[n].index;

                return indices;
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI.Client
    {
        public sealed partial class BindManager
        {
            private class Control : IControl
            {
                /// <summary>
                /// Name of the control
                /// </summary>
                public string Name => _instance.GetControlMember(Index, (int)ControlAccessors.Name) as string;

                /// <summary>
                /// Name of the control as displayed in bind menu
                /// </summary>
                public string DisplayName => _instance.GetControlMember(Index, (int)ControlAccessors.DisplayName) as string;

                /// <summary>
                /// Index of the control in the bind manager
                /// </summary>
                public int Index { get; }

                /// <summary>
                /// Returns true if the control is being pressed
                /// </summary>
                public bool IsPressed => (bool)(_instance.GetControlMember(Index, (int)ControlAccessors.IsPressed) ?? false);

                /// <summary>
                /// Returns true if the control was just pressed
                /// </summary>
                public bool IsNewPressed => (bool)(_instance.GetControlMember(Index, (int)ControlAccessors.IsNewPressed) ?? false);

                /// <summary>
                /// Returns true if the control was just released
                /// </summary>
                public bool IsReleased => (bool)(_instance.GetControlMember(Index, (int)ControlAccessors.IsReleased) ?? false);

                // <summary>
                /// Returns true if the control doesn't represent a boolean value. For example, MwUp/Dn
                /// represent scroll wheel movement, but don't return an exact position/displacement.
                /// </summary>
                public bool Analog { get; }

                public Control(int index)
                {
                    this.Index = index;
                }

                public override bool Equals(object obj)
                {
                    return (obj as Control).Index == Index;
                }

                public override int GetHashCode()
                {
                    return Index.GetHashCode();
                }
            }
        }
    }
}﻿using System;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    using CursorMembers = MyTuple<
        Func<HudSpaceDelegate, bool>, // IsCapturingSpace
        Func<float, HudSpaceDelegate, bool>, // TryCaptureHudSpace
        Func<ApiMemberAccessor, bool>, // IsCapturing
        Func<ApiMemberAccessor, bool>, // TryCapture
        Func<ApiMemberAccessor, bool>, // TryRelease
        ApiMemberAccessor // GetOrSetMember
    >;

    namespace UI.Client
    {
        public sealed partial class HudMain
        {
            /// <summary>
            /// Wrapper for the cursor rendered by the Rich HUD Framework
            /// </summary>
            private class HudCursor : ICursor
            {
                /// <summary>
                /// Indicates whether the cursor is currently visible
                /// </summary>
                public bool Visible { get; private set; }

                /// <summary>
                /// Returns true if the cursor has been captured by a UI element
                /// </summary>
                public bool IsCaptured => (bool)GetOrSetMemberFunc(null, (int)HudCursorAccessors.IsCaptured);

                /// <summary>
                /// Returns true if a tooltip has been registered
                /// </summary>
                public bool IsToolTipRegistered { get; private set; }

                /// <summary>
                /// The position of the cursor in pixels in screen space
                /// </summary>
                public Vector2 ScreenPos { get; private set; }

                /// <summary>
                /// Position of the cursor in world space.
                /// </summary>
                public Vector3D WorldPos { get; private set; }

                /// <summary>
                /// Line projected from the cursor into world space on the -Z axis 
                /// correcting for apparent warping due to perspective projection.
                /// </summary>
                public LineD WorldLine { get; private set; }

                private readonly Func<HudSpaceDelegate, bool> IsCapturingSpaceFunc;
                private readonly Func<float, HudSpaceDelegate, bool> TryCaptureHudSpaceFunc;
                private readonly Func<ApiMemberAccessor, bool> IsCapturingFunc;
                private readonly Func<ApiMemberAccessor, bool> TryCaptureFunc;
                private readonly Func<ApiMemberAccessor, bool> TryReleaseFunc;
                private readonly ApiMemberAccessor GetOrSetMemberFunc;

                public HudCursor(CursorMembers members)
                {
                    IsCapturingSpaceFunc = members.Item1;
                    TryCaptureHudSpaceFunc = members.Item2;
                    IsCapturingFunc = members.Item3;
                    TryCaptureFunc = members.Item4;
                    TryReleaseFunc = members.Item5;
                    GetOrSetMemberFunc = members.Item6;
                }

                public void Update()
                {
                    Visible = (bool)GetOrSetMemberFunc(null, (int)HudCursorAccessors.Visible);
                    ScreenPos = (Vector2)GetOrSetMemberFunc(null, (int)HudCursorAccessors.ScreenPos);
                    WorldPos = (Vector3D)GetOrSetMemberFunc(null, (int)HudCursorAccessors.WorldPos);
                    WorldLine = (LineD)GetOrSetMemberFunc(null, (int)HudCursorAccessors.WorldLine);
                    IsToolTipRegistered = (bool)GetOrSetMemberFunc(null, (int)HudCursorAccessors.IsToolTipRegistered);
                }

                /// <summary>
                /// Returns true if the given HUD space is being captured by the cursor
                /// </summary>
                public bool IsCapturingSpace(HudSpaceDelegate GetHudSpaceFunc) =>
                    IsCapturingSpaceFunc(GetHudSpaceFunc);

                /// <summary>
                /// Attempts to capture the cursor at the given depth with the given HUD space. If drawInHudSpace
                /// is true, then the cursor will be drawn in the given space.
                /// </summary>
                public bool TryCaptureHudSpace(float depthSquared, HudSpaceDelegate GetHudSpaceFunc) =>
                    TryCaptureHudSpaceFunc(depthSquared, GetHudSpaceFunc);

                /// <summary>
                /// Attempts to capture the cursor at the given depth with the given HUD space. If drawInHudSpace
                /// is true, then the cursor will be drawn in the given space.
                /// </summary>
                public void CaptureHudSpace(float depthSquared, HudSpaceDelegate GetHudSpaceFunc) =>
                    TryCaptureHudSpaceFunc(depthSquared, GetHudSpaceFunc);

                /// <summary>
                /// Attempts to capture the cursor with the given object
                /// </summary>
                public void Capture(ApiMemberAccessor capturedElement) =>
                    TryCaptureFunc(capturedElement);

                /// <summary>
                /// Indicates whether the cursor is being captured by the given element.
                /// </summary>
                public bool IsCapturing(ApiMemberAccessor capturedElement) =>
                    IsCapturingFunc(capturedElement);

                /// <summary>
                /// Attempts to capture the cursor using the given object. Returns true on success.
                /// </summary>
                public bool TryCapture(ApiMemberAccessor capturedElement) =>
                    TryCaptureFunc(capturedElement);

                /// <summary>
                /// Attempts to release the cursor from the given element. Returns false if
                /// not capture or if not captured by the object given.
                /// </summary>
                public bool TryRelease(ApiMemberAccessor capturedElement) =>
                    TryReleaseFunc(capturedElement);

                /// <summary>
                /// Registers a callback delegate to set the tooltip for the next frame. Tooltips are reset
                /// every tick and must be reregistered in HandleInput() every tick. The first tooltip registered
                /// takes precedence.
                /// </summary>
                public void RegisterToolTip(ToolTip toolTip) =>
                    GetOrSetMemberFunc(toolTip.GetToolTipFunc, (int)HudCursorAccessors.RegisterToolTip);
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using RichHudFramework.UI.Rendering;
using ApiMemberAccessor = System.Func<object, int, object>;
using FloatProp = VRage.MyTuple<System.Func<float>, System.Action<float>>;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;
using RichStringMembers = VRage.MyTuple<System.Text.StringBuilder, VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>>;
using Vec2Prop = VRage.MyTuple<System.Func<VRageMath.Vector2>, System.Action<VRageMath.Vector2>>;

namespace RichHudFramework
{
    using Internal;
    using Client;
    using CursorMembers = MyTuple<
        Func<HudSpaceDelegate, bool>, // IsCapturingSpace
        Func<float, HudSpaceDelegate, bool>, // TryCaptureHudSpace
        Func<ApiMemberAccessor, bool>, // IsCapturing
        Func<ApiMemberAccessor, bool>, // TryCapture
        Func<ApiMemberAccessor, bool>, // TryRelease
        ApiMemberAccessor // GetOrSetMember
    >;
    using TextBuilderMembers = MyTuple<
        MyTuple<Func<int, int, object>, Func<int>>, // GetLineMember, GetLineCount
        Func<Vector2I, int, object>, // GetCharMember
        ApiMemberAccessor, // GetOrSetMember
        Action<IList<RichStringMembers>, Vector2I>, // Insert
        Action<IList<RichStringMembers>>, // SetText
        Action // Clear
    >;

    namespace UI
    {
        using TextBoardMembers = MyTuple<
            TextBuilderMembers,
            FloatProp, // Scale
            Func<Vector2>, // Size
            Func<Vector2>, // TextSize
            Vec2Prop, // FixedSize
            Action<BoundingBox2, BoundingBox2, MatrixD[]> // Draw 
        >;

        namespace Client
        {
            using HudClientMembers = MyTuple<
                CursorMembers, // Cursor
                Func<TextBoardMembers>, // GetNewTextBoard
                ApiMemberAccessor, // GetOrSetMembers
                Action // Unregister
            >;
            using HudUpdateAccessors = MyTuple<
                ApiMemberAccessor,
                MyTuple<Func<ushort>, Func<Vector3D>>, // ZOffset + GetOrigin
                Action, // DepthTest
                Action, // HandleInput
                Action<bool>, // BeforeLayout
                Action // BeforeDraw
            >;

            public sealed partial class HudMain : RichHudClient.ApiModule<HudClientMembers>
            {
                /// <summary>
                /// Root parent for all HUD elements.
                /// </summary>
                public static HudParentBase Root
                {
                    get
                    {
                        if (_instance == null)
                            Init();

                        return _instance.root;
                    }
                }

                /// <summary>
                /// Root node for high DPI scaling at > 1080p. Draw matrix automatically rescales to comensate
                /// for decrease in apparent size due to high DPI displays.
                /// </summary>
                public static HudParentBase HighDpiRoot
                {
                    get
                    {
                        if (_instance == null)
                            Init();

                        return _instance.highDpiRoot;
                    }
                }

                /// <summary>
                /// Cursor shared between mods.
                /// </summary>
                public static ICursor Cursor
                {
                    get
                    {
                        if (_instance == null)
                            Init();

                        return _instance.cursor;
                    }
                }

                /// <summary>
                /// Shared clipboard.
                /// </summary>
                public static RichText ClipBoard
                {
                    get
                    {
                        object value = Instance.GetOrSetMemberFunc(null, (int)HudMainAccessors.ClipBoard);

                        if (value != null)
                            return new RichText(value as List<RichStringMembers>);
                        else
                            return default(RichText);
                    }
                    set { Instance.GetOrSetMemberFunc(value.apiData, (int)HudMainAccessors.ClipBoard); }
                }

                /// <summary>
                /// Resolution scale normalized to 1080p for resolutions over 1080p. Returns a scale of 1f
                /// for lower resolutions.
                /// </summary>
                public static float ResScale { get; private set; }

                /// <summary>
                /// Matrix used to convert from 2D pixel-value screen space coordinates to worldspace.
                /// </summary>
                public static MatrixD PixelToWorld => PixelToWorldRef[0];

                /// <summary>
                /// Matrix used to convert from 2D pixel-value screen space coordinates to worldspace.
                /// </summary>
                public static MatrixD[] PixelToWorldRef { get; private set; }

                /// <summary>
                /// The current horizontal screen resolution in pixels.
                /// </summary>
                public static float ScreenWidth { get; private set; }

                /// <summary>
                /// The current vertical resolution in pixels.
                /// </summary>
                public static float ScreenHeight { get; private set; }

                /// <summary>
                /// The current aspect ratio (ScreenWidth/ScreenHeight).
                /// </summary>
                public static float AspectRatio { get; private set; }

                /// <summary>
                /// The current field of view
                /// </summary>
                public static float Fov { get; private set; }

                /// <summary>
                /// Scaling used by MatBoards to compensate for changes in apparent size and position as a result
                /// of changes to Fov.
                /// </summary>
                public static float FovScale { get; private set; }

                /// <summary>
                /// The current opacity for the in-game menus as configured.
                /// </summary>
                public static float UiBkOpacity { get; private set; }

                /// <summary>
                /// If true then the cursor will be visible while chat is open
                /// </summary>
                public static bool EnableCursor { get; set; }

                /// <summary>
                /// Current input mode. Used to indicate whether UI elements should accept cursor or text input.
                /// </summary>
                public static HudInputMode InputMode { get; private set; }

                private static HudMain Instance
                {
                    get { Init(); return _instance; }
                    set { _instance = value; }
                }
                private static HudMain _instance;

                private readonly HudClientRoot root;
                private readonly ScaledSpaceNode highDpiRoot;
                private readonly HudCursor cursor;
                private bool enableCursorLast;

                private readonly Func<TextBoardMembers> GetTextBoardDataFunc;
                private readonly ApiMemberAccessor GetOrSetMemberFunc;
                private readonly Action UnregisterAction;

                private HudMain() : base(ApiModuleTypes.HudMain, false, true)
                {
                    if (_instance != null)
                        throw new Exception("Only one instance of HudMain can exist at any give time!");

                    _instance = this;
                    var members = GetApiData();

                    cursor = new HudCursor(members.Item1);
                    GetTextBoardDataFunc = members.Item2;
                    GetOrSetMemberFunc = members.Item3;
                    UnregisterAction = members.Item4;

                    PixelToWorldRef = new MatrixD[1];
                    root = new HudClientRoot();
                    highDpiRoot = new ScaledSpaceNode(root) { UpdateScaleFunc = () => ResScale };

                    Action<List<HudUpdateAccessors>, byte> rootDelegate = root.GetUpdateAccessors,
                        safeAccessor = (List<HudUpdateAccessors> list, byte depth) =>
                        {
                            ExceptionHandler.Run(() => rootDelegate(list, depth));
                        };

                    // Register update delegate
                    GetOrSetMemberFunc(safeAccessor, (int)HudMainAccessors.GetUpdateAccessors);

                    GetOrSetMemberFunc(new Action(() => ExceptionHandler.Run(BeforeMasterDraw)), (int)HudMainAccessors.SetBeforeDrawCallback);
                    GetOrSetMemberFunc(new Action(() => ExceptionHandler.Run(AfterMasterDraw)), (int)HudMainAccessors.SetAfterDrawCallback);

                    UpdateCache();
                }

                private static void Init()
                {
                    BillBoardUtils.Init();

                    if (_instance == null)
                        new HudMain();
                }

                private void BeforeMasterDraw()
                {
                    UpdateCache();
                    cursor.Update();
                    BillBoardUtils.BeginDraw();
                }

                private void AfterMasterDraw()
                {
                    BillBoardUtils.FinishDraw();
                }
 
                public override void Close()
                {
                    UnregisterAction?.Invoke();
                    _instance = null;
                }

                private void UpdateCache()
                {
                    ScreenWidth = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.ScreenWidth);
                    ScreenHeight = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.ScreenHeight);
                    AspectRatio = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.AspectRatio);
                    ResScale = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.ResScale);
                    Fov = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.Fov);
                    FovScale = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.FovScale);
                    PixelToWorldRef[0] = (MatrixD)GetOrSetMemberFunc(null, (int)HudMainAccessors.PixelToWorldTransform);
                    UiBkOpacity = (float)GetOrSetMemberFunc(null, (int)HudMainAccessors.UiBkOpacity);
                    InputMode = (HudInputMode)GetOrSetMemberFunc(null, (int)HudMainAccessors.InputMode);

                    if (EnableCursor != enableCursorLast)
                        GetOrSetMemberFunc(EnableCursor, (int)HudMainAccessors.EnableCursor);
                    else
                        EnableCursor = (bool)GetOrSetMemberFunc(null, (int)HudMainAccessors.EnableCursor);

                    enableCursorLast = EnableCursor;
                }

                /// <summary>
                /// Returns the ZOffset for focusing a window and registers a callback
                /// for when another object takes focus.
                /// </summary>
                public static byte GetFocusOffset(Action<byte> LoseFocusCallback) =>
                    (byte)Instance.GetOrSetMemberFunc(LoseFocusCallback, (int)HudMainAccessors.GetFocusOffset);

                /// <summary>
                /// Registers a callback for UI elements taking input focus. Callback
                /// invoked when another element takes focus.
                /// </summary>
                public static void GetInputFocus(Action LoseFocusCallback) =>
                    Instance.GetOrSetMemberFunc(LoseFocusCallback, (int)HudMainAccessors.GetInputFocus);

                /// <summary>
                /// Returns accessors for a new TextBoard
                /// </summary>
                public static TextBoardMembers GetTextBoardData() =>
                    Instance.GetTextBoardDataFunc();

                /// <summary>
                /// Converts from a position in absolute screen space coordinates to a position in pixels.
                /// </summary>
                public static Vector2 GetPixelVector(Vector2 scaledVec)
                {
                    if (_instance == null)
                        Init();

                    return new Vector2
                    (
                        (int)(scaledVec.X * ScreenWidth),
                        (int)(scaledVec.Y * ScreenHeight)
                    );
                }

                /// <summary>
                /// Converts from a coordinate given in pixels to a position in absolute units.
                /// </summary>
                public static Vector2 GetAbsoluteVector(Vector2 pixelVec)
                {
                    if (_instance == null)
                        Init();

                    return new Vector2
                    (
                        pixelVec.X / ScreenWidth,
                        pixelVec.Y / ScreenHeight
                    );
                }

                /// <summary>
                /// Root UI element for the client. Registered directly to master root.
                /// </summary>
                private class HudClientRoot : HudParentBase, IReadOnlyHudSpaceNode
                {
                    public override bool Visible => true;

                    public bool DrawCursorInHudSpace { get; }

                    public Vector3 CursorPos { get; private set; }

                    public HudSpaceDelegate GetHudSpaceFunc { get; }

                    public MatrixD PlaneToWorld => PlaneToWorldRef[0];

                    public MatrixD[] PlaneToWorldRef { get; }

                    public Func<MatrixD> UpdateMatrixFunc { get; }

                    public Func<Vector3D> GetNodeOriginFunc { get; }

                    public bool IsInFront { get; }

                    public bool IsFacingCamera { get; }

                    public HudClientRoot()
                    {
                        accessorDelegates.Item2 = new MyTuple<Func<ushort>, Func<Vector3D>>(() => 0, null);

                        State |= HudElementStates.CanUseCursor;
                        DrawCursorInHudSpace = true;
                        HudSpace = this;
                        IsInFront = true;
                        IsFacingCamera = true;
                        PlaneToWorldRef = new MatrixD[1];

                        GetHudSpaceFunc = _instance.GetOrSetMemberFunc(null, (int)HudMainAccessors.GetPixelSpaceFunc) as HudSpaceDelegate;
                        GetNodeOriginFunc = _instance.GetOrSetMemberFunc(null, (int)HudMainAccessors.GetPixelSpaceOriginFunc) as Func<Vector3D>;
                    }

                    protected override void Layout()
                    {
                        PlaneToWorldRef[0] = PixelToWorldRef[0];
                        CursorPos = new Vector3(Cursor.ScreenPos.X, Cursor.ScreenPos.Y, 0f);
                    }
                }
            }
        }
    }

    namespace UI.Server
    { }
}﻿using System.Collections.Generic;
using System;
using System.Threading;
using Sandbox.ModAPI;
using VRage.Game;
using VRage;
using VRage.Utils;
using VRageMath;
using VRageRender;
using RichHudFramework.UI.Rendering;
using RichHudFramework.Client;
using RichHudFramework.Internal;
using BlendTypeEnum = VRageRender.MyBillboard.BlendTypeEnum;

namespace RichHudFramework
{
    namespace UI
    {
        using ApiMemberAccessor = System.Func<object, int, object>;
        using TriangleBillboardData = MyTuple<
            BlendTypeEnum, // blendType
            Vector2I, // bbID + matrixID
            MyStringId, // material
            Vector4, // color
            MyTuple<Vector2, Vector2, Vector2>, // texCoords
            MyTuple<Vector3D, Vector3D, Vector3D> // vertexPos
        >;
        using FlatTriangleBillboardData = MyTuple<
            BlendTypeEnum, // blendType
            Vector2I, // bbID + matrixID
            MyStringId, // material
            MyTuple<Vector4, BoundingBox2?>, // color + mask
            MyTuple<Vector2, Vector2, Vector2>, // texCoords
            MyTuple<Vector2, Vector2, Vector2> // flat pos
        >;

        namespace Rendering
        {
            using BbUtilData = MyTuple<
                ApiMemberAccessor, // GetOrSetMember
                List<TriangleBillboardData>, // triangleList
                List<FlatTriangleBillboardData>, // flatTriangleList
                List<MatrixD>, // matrixBuf
                Dictionary<MatrixD[], int> // matrixTable
            >;

            public sealed partial class BillBoardUtils : RichHudClient.ApiModule<BbUtilData>
            {
                private static BillBoardUtils instance;

                private readonly List<MyTriangleBillboard> bbBuf;
                private List<MyTriangleBillboard> bbPoolBack;

                private readonly ApiMemberAccessor GetOrSetMember;
                private readonly List<TriangleBillboardData> triangleList;
                private readonly List<FlatTriangleBillboardData> flatTriangleList;
                private readonly List<MatrixD> matrixBuf;
                private readonly Dictionary<MatrixD[], int> matrixTable;

                private BillBoardUtils() : base(ApiModuleTypes.BillBoardUtils, false, true)
                {
                    if (instance != null)
                        throw new Exception($"Only one instance of {GetType().Name} can exist at once.");

                    bbBuf = new List<MyTriangleBillboard>(1000);

                    var data = GetApiData();
                    GetOrSetMember = data.Item1;
                    triangleList = data.Item2;
                    flatTriangleList = data.Item3;
                    matrixBuf = data.Item4;
                    matrixTable = data.Item5;
                }

                public static void Init()
                {
                    if (instance == null)
                    {
                        instance = new BillBoardUtils();
                    }
                }

                public override void Close()
                {
                    if (ExceptionHandler.Unloading)
                    {
                        instance = null;
                    }
                }

                public static void BeginDraw()
                {
                    if (instance != null)
                    {
                        instance.bbPoolBack = instance.GetOrSetMember(null, (int)BillBoardUtilAccessors.GetPoolBack) as List<MyTriangleBillboard>;
                    }
                }

                public static void FinishDraw()
                { }
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using BoolProp = MyTuple<Func<bool>, Action<bool>>;
    using FloatProp = MyTuple<Func<float>, Action<float>>;
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using Vec2Prop = MyTuple<Func<Vector2>, Action<Vector2>>;

    namespace UI
    {
        using UI.Client;
        using UI.Server;
        using TextBuilderMembers = MyTuple<
            MyTuple<Func<int, int, object>, Func<int>>, // GetLineMember, GetLineCount
            Func<Vector2I, int, object>, // GetCharMember
            Func<object, int, object>, // GetOrSetMember
            Action<IList<RichStringMembers>, Vector2I>, // Insert
            Action<IList<RichStringMembers>>, // SetText
            Action // Clear
        >;

        namespace Rendering.Client
        {
            using TextBoardMembers = MyTuple<
                TextBuilderMembers,
                FloatProp, // Scale
                Func<Vector2>, // Size
                Func<Vector2>, // TextSize
                Vec2Prop, // FixedSize
                Action<BoundingBox2, BoundingBox2, MatrixD[]> // Draw 
            >;

            public class TextBoard : TextBuilder, ITextBoard
            {
                /// <summary>
                /// Invoked whenever a change is made to the text.
                /// </summary>
                public event Action TextChanged
                {
                    add
                    {
                        var args = new MyTuple<bool, Action>(true, value);
                        GetOrSetMemberFunc(args, (int)TextBoardAccessors.OnTextChanged);
                    }
                    remove
                    {
                        var args = new MyTuple<bool, Action>(false, value);
                        GetOrSetMemberFunc(args, (int)TextBoardAccessors.OnTextChanged);
                    }
                }

                /// <summary>
                /// Scale of the text board. Applied after scaling specified in GlyphFormat.
                /// </summary>
                public float Scale { get { return GetScaleFunc(); } set { SetScaleAction(value); } }

                /// <summary>
                /// Size of the text box as rendered
                /// </summary>
                public Vector2 Size => GetSizeFunc();

                /// <summary>
                /// Full text size including any text outside the visible range.
                /// </summary>
                public Vector2 TextSize => GetTextSizeFunc();

                /// <summary>
                /// Used to change the position of the text within the text element. AutoResize must be disabled for this to work.
                /// </summary>
                public Vector2 TextOffset
                {
                    get { return (Vector2)GetOrSetMemberFunc(null, (int)TextBoardAccessors.TextOffset); }
                    set { GetOrSetMemberFunc(value, (int)TextBoardAccessors.TextOffset); }
                }

                /// <summary>
                /// Full text size including any text outside the visible range.
                /// </summary>
                public Vector2I VisibleLineRange => (Vector2I)GetOrSetMemberFunc(null, (int)TextBoardAccessors.VisibleLineRange);

                /// <summary>
                /// Size of the text box when AutoResize is set to false. Does nothing otherwise.
                /// </summary>
                public Vector2 FixedSize { get { return GetFixedSizeFunc(); } set { SetFixedSizeAction(value); } }

                /// <summary>
                /// If true, the text board will automatically resize to fit the text.
                /// </summary>
                public bool AutoResize
                {
                    get { return (bool)GetOrSetMemberFunc(null, (int)TextBoardAccessors.AutoResize); }
                    set { GetOrSetMemberFunc(value, (int)TextBoardAccessors.AutoResize); }
                }

                /// <summary>
                /// If true, the text will be vertically aligned to the center of the text board.
                /// </summary>
                public bool VertCenterText
                {
                    get { return (bool)GetOrSetMemberFunc(null, (int)TextBoardAccessors.VertAlign); }
                    set { GetOrSetMemberFunc(value, (int)TextBoardAccessors.VertAlign); }
                }

                private readonly Func<float> GetScaleFunc;
                private readonly Action<float> SetScaleAction;
                private readonly Func<Vector2> GetSizeFunc;
                private readonly Func<Vector2> GetTextSizeFunc;
                private readonly Func<Vector2> GetFixedSizeFunc;
                private readonly Action<Vector2> SetFixedSizeAction;
                private readonly Action<BoundingBox2, BoundingBox2, MatrixD[]> DrawAction;
                private readonly MatrixD[] matRef;

                public TextBoard() : this(HudMain.GetTextBoardData())
                { }

                private TextBoard(TextBoardMembers members) : base(members.Item1)
                {
                    Format = GlyphFormat.Black;
                    GetScaleFunc = members.Item2.Item1;
                    SetScaleAction = members.Item2.Item2;
                    GetSizeFunc = members.Item3;
                    GetTextSizeFunc = members.Item4;
                    GetFixedSizeFunc = members.Item5.Item1;
                    SetFixedSizeAction = members.Item5.Item2;
                    DrawAction = members.Item6;

                    matRef = new MatrixD[1];
                }

                /// <summary>
                /// Draws the text board in screen space with an offset given in pixels.
                /// </summary>
                public void Draw(Vector2 origin)
                {
                    Vector2 halfSize = GetSizeFunc() * .5f;
                    BoundingBox2 box = new BoundingBox2(origin - halfSize, origin + halfSize);

                    DrawAction(box, CroppedBox.defaultMask, HudMain.PixelToWorldRef);
                }

                /// <summary>
                /// Draws the text board in world space on the XY plane of the matrix, facing in the +Z
                /// direction.
                /// </summary>
                public void Draw(Vector2 origin, MatrixD matrix)
                {
                    Vector2 halfSize = GetSizeFunc() * .5f;
                    BoundingBox2 box = new BoundingBox2(origin - halfSize, origin + halfSize);
                    matRef[0] = matrix;

                    DrawAction(box, CroppedBox.defaultMask, matRef);
                }

                /// <summary>
                /// Draws the text board in world space on the XY plane of the matrix, facing in the +Z
                /// direction.
                /// </summary>
                public void Draw(BoundingBox2 box, BoundingBox2 mask, MatrixD[] matrix) =>
                    DrawAction(box, mask, matrix);

                /// <summary>
                /// Calculates and applies the minimum offset needed to ensure that the character at the specified index
                /// is within the visible range.
                /// </summary>
                public void MoveToChar(Vector2I index) =>
                    GetOrSetMemberFunc(index, (int)TextBoardAccessors.MoveToChar);

                /// <summary>
                /// Returns the index of the character at the given offset.
                /// </summary>
                public Vector2I GetCharAtOffset(Vector2 offset) =>
                    (Vector2I)GetOrSetMemberFunc(offset, (int)TextBoardAccessors.GetCharAtOffset);
            }
        }

        namespace Rendering.Server
        { }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using BoolProp = MyTuple<Func<bool>, Action<bool>>;
    using FloatProp = MyTuple<Func<float>, Action<float>>;
    using RangeData = MyTuple<Vector2I, Vector2I>;
    using RangeFormatData = MyTuple<Vector2I, Vector2I, GlyphFormatMembers>;
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using Vec2Prop = MyTuple<Func<Vector2>, Action<Vector2>>;

    namespace UI
    {
        using System.Collections;
        using TextBuilderMembers = MyTuple<
            MyTuple<Func<int, int, object>, Func<int>>, // GetLineMember, GetLineCount
            Func<Vector2I, int, object>, // GetCharMember
            Func<object, int, object>, // GetOrSetMember
            Action<IList<RichStringMembers>, Vector2I>, // Insert
            Action<IList<RichStringMembers>>, // SetText
            Action // Clear
        >;

        namespace Rendering.Client
        {
            public abstract class TextBuilder : ITextBuilder
            {
                /// <summary>
                /// Returns the character at the index specified.
                /// </summary>
                public IRichChar this[Vector2I index] => lines[index.X][index.Y];

                /// <summary>
                /// Returns the line at the index given.
                /// </summary>
                public ILine this[int index] => lines[index];

                /// <summary>
                /// Returns the current number of lines.
                /// </summary>
                public int Count => GetLineCountFunc();

                /// <summary>
                /// Default text format. Applied to strings added without any other formatting specified.
                /// </summary>
                public GlyphFormat Format
                {
                    get { return new GlyphFormat((GlyphFormatMembers)GetOrSetMemberFunc(null, (int)TextBuilderAccessors.Format)); }
                    set { GetOrSetMemberFunc(value.Data, (int)TextBuilderAccessors.Format); }
                }

                /// <summary>
                /// Gets or sets the maximum line width before text will wrap to the next line. Word wrapping must be enabled for
                /// this to apply.
                /// </summary>
                public float LineWrapWidth
                {
                    get { return (float)GetOrSetMemberFunc(null, (int)TextBuilderAccessors.LineWrapWidth); }
                    set { GetOrSetMemberFunc(value, (int)TextBuilderAccessors.LineWrapWidth); }
                }

                /// <summary>
                /// Determines the formatting mode of the text.
                /// </summary>
                public TextBuilderModes BuilderMode
                {
                    get { return (TextBuilderModes)GetOrSetMemberFunc(null, (int)TextBuilderAccessors.BuilderMode); }
                    set { GetOrSetMemberFunc(value, (int)TextBuilderAccessors.BuilderMode); }
                }

                protected readonly Func<object, int, object> GetOrSetMemberFunc;
                private readonly Func<int, int, object> GetLineMemberFunc;
                private readonly Func<int> GetLineCountFunc;
                private readonly Func<Vector2I, int, object> GetCharMemberFunc;
                private readonly Action<IList<RichStringMembers>, Vector2I> InsertTextAction;
                private readonly Action<IList<RichStringMembers>> SetTextAction;
                private readonly Action ClearAction;

                private readonly ReadOnlyApiCollection<ILine> lines;
                private RichText lastText;

                public TextBuilder(TextBuilderMembers data)
                {
                    GetLineMemberFunc = data.Item1.Item1;
                    GetLineCountFunc = data.Item1.Item2;

                    GetCharMemberFunc = data.Item2;
                    GetOrSetMemberFunc = data.Item3;
                    InsertTextAction = data.Item4;
                    SetTextAction = data.Item5;
                    ClearAction = data.Item6;

                    lines = new ReadOnlyApiCollection<ILine>(x => new LineData(this, x), GetLineCountFunc);
                }

                /// <summary>
                /// Replaces the current text with the <see cref="RichText"/> given
                /// </summary>
                public void SetText(RichText text)
                {
                    SetTextAction(text.apiData);
                    lastText = text;
                }

                /// <summary>
                /// Clears current text and appends a copy of the <see cref="StringBuilder"/> given.
                /// </summary>
                public void SetText(StringBuilder text, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(text, format ?? Format);
                    SetTextAction(lastText.apiData);
                }

                /// <summary>
                /// Clears current text and appends a copy of the <see cref="string"/> given.
                /// </summary>
                public void SetText(string text, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(text, format ?? Format);
                    SetTextAction(lastText.apiData);
                }

                /// <summary>
                /// Appends the given <see cref="RichText"/>
                /// </summary>
                public void Append(RichText text)
                {
                    InsertTextAction(text.apiData, GetLastIndex());
                }

                /// <summary>
                /// Appends a copy of the text in the <see cref="StringBuilder"/>
                /// </summary>
                public void Append(StringBuilder text, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(text, format ?? Format);
                    InsertTextAction(lastText.apiData, GetLastIndex());
                }

                /// <summary>
                /// Appends a copy of the <see cref="string"/>
                /// </summary>
                public void Append(string text, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(text, format ?? Format);
                    InsertTextAction(lastText.apiData, GetLastIndex());
                }

                /// <summary>
                /// Appends the given <see cref="char"/>
                /// </summary>
                public void Append(char ch, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(ch, format ?? Format);
                    InsertTextAction(lastText.apiData, GetLastIndex());
                }

                /// Inserts the given text to the end of the text at the specified starting index using the <see cref="GlyphFormat"/>ting specified in the <see cref="RichText"/>.
                /// </summary>
                public void Insert(RichText text, Vector2I start)
                {
                    InsertTextAction(text.apiData, start);
                }

                /// <summary>
                /// Inserts a copy of the given <see cref="StringBuilder"/> starting at the specified starting index
                /// </summary>
                public void Insert(StringBuilder text, Vector2I start, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(text, format ?? Format);
                    InsertTextAction(lastText.apiData, start);
                }

                /// <summary>
                /// Inserts a copy of the given <see cref="string"/> starting at the specified starting index
                /// </summary>
                public void Insert(string text, Vector2I start, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(text, format ?? Format);
                    InsertTextAction(lastText.apiData, start);
                }

                /// <summary>
                /// Inserts the given <see cref="char"/> starting at the specified starting index
                /// </summary>
                public void Insert(char ch, Vector2I start, GlyphFormat? format = null)
                {
                    if (lastText == null)
                        lastText = new RichText();

                    lastText.Clear();
                    lastText.Add(ch, format ?? Format);
                    InsertTextAction(lastText.apiData, start);
                }

                /// <summary>
                /// Returns the contents of the text as <see cref="RichText"/>.
                /// </summary>
                public RichText GetText() =>
                    GetTextRange(Vector2I.Zero, GetLastIndex() - new Vector2I(0, 1));

                /// <summary>
                /// Returns the specified range of characters from the text as <see cref="RichText"/>.
                /// </summary>
                public RichText GetTextRange(Vector2I start, Vector2I end)
                {
                    var textData = GetOrSetMemberFunc(new RangeData(start, end), (int)TextBuilderAccessors.GetRange) as List<RichStringMembers>;

                    if (lastText == null || lastText.apiData != textData)
                        lastText = new RichText(textData);

                    return lastText;
                }

                /// <summary>
                /// Changes the formatting for the whole text to the given format.
                /// </summary>
                public void SetFormatting(GlyphFormat format)
                {
                    GetOrSetMemberFunc(format.Data, (int)TextBuilderAccessors.Format);
                    GetOrSetMemberFunc(new RangeFormatData(Vector2I.Zero, GetLastIndex() - new Vector2I(0, 1), format.Data), (int)TextBuilderAccessors.SetFormatting);
                }

                /// <summary>
                /// Changes the formatting for the text within the given range to the given format.
                /// </summary>
                public void SetFormatting(Vector2I start, Vector2I end, GlyphFormat format) =>
                    GetOrSetMemberFunc(new RangeFormatData(start, end, format.Data), (int)TextBuilderAccessors.SetFormatting);

                /// <summary>
                /// Removes the character at the specified index.
                /// </summary>
                public void RemoveAt(Vector2I index) =>
                    GetOrSetMemberFunc(new RangeData(index, index), (int)TextBuilderAccessors.RemoveRange);

                /// <summary>
                /// Removes all text within the specified range.
                /// </summary>
                public void RemoveRange(Vector2I start, Vector2I end) =>
                    GetOrSetMemberFunc(new RangeData(start, end), (int)TextBuilderAccessors.RemoveRange);

                /// <summary>
                /// Clears all existing text.
                /// </summary>
                public void Clear() =>
                    ClearAction();

                /// <summary>
                /// Returns the contents of the <see cref="ITextBuilder"/> as an unformatted string.
                /// </summary>
                public override string ToString() =>
                    GetOrSetMemberFunc(null, (int)TextBuilderAccessors.ToString) as string;

                protected Vector2I GetLastIndex()
                {
                    int lineCount = GetLineCountFunc();
                    Vector2I start = new Vector2I(Math.Max(0, lineCount - 1), 0);

                    if (lineCount > 0)
                        start.Y = Math.Max(0, lines[start.X].Count);

                    return start;
                }

                protected class LineData : ILine
                {
                    public IRichChar this[int ch] => characters[ch];
                    public int Count => (int)parent.GetLineMemberFunc(index, (int)LineAccessors.Count);
                    public Vector2 Size => (Vector2)parent.GetLineMemberFunc(index, (int)LineAccessors.Size);
                    public float VerticalOffset => (float)parent.GetLineMemberFunc(index, (int)LineAccessors.VerticalOffset);

                    private readonly TextBuilder parent;
                    private readonly int index;
                    private readonly ReadOnlyApiCollection<IRichChar> characters;

                    public LineData(TextBuilder parent, int index)
                    {
                        this.parent = parent;
                        this.index = index;

                        characters = new ReadOnlyApiCollection<IRichChar>
                        (
                            x => new RichCharData(parent, new Vector2I(index, x)),
                            () => (int)parent.GetLineMemberFunc(index, (int)LineAccessors.Count)
                        );
                    }
                }

                protected class RichCharData : IRichChar
                {
                    public char Ch => (char)parent.GetCharMemberFunc(index, (int)RichCharAccessors.Ch);
                    public GlyphFormat Format => new GlyphFormat((GlyphFormatMembers)parent.GetCharMemberFunc(index, (int)RichCharAccessors.Format));
                    public Vector2 Size => (Vector2)parent.GetCharMemberFunc(index, (int)RichCharAccessors.Size);
                    public Vector2 Offset => (Vector2)parent.GetCharMemberFunc(index, (int)RichCharAccessors.Offset);

                    private readonly TextBuilder parent;
                    private readonly Vector2I index;

                    public RichCharData(TextBuilder parent, Vector2I index)
                    {
                        this.parent = parent;
                        this.index = index;
                    }
                }
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using AtlasMembers = VRage.MyTuple<string, VRageMath.Vector2>;
using GlyphMembers = VRage.MyTuple<int, VRageMath.Vector2, VRageMath.Vector2, float, float>;

namespace RichHudFramework
{
    using FontMembers = MyTuple<
        string, // Name
        int, // Index
        float, // PtSize
        float, // BaseScale
        Func<int, bool>, // IsStyleDefined
        ApiMemberAccessor
    >;

    namespace UI
    {
        namespace Rendering.Client
        {
            public sealed partial class FontManager
            {
                private class FontData : IFontMin
                {
                    /// <summary>
                    /// Font name
                    /// </summary>
                    public string Name { get; }

                    /// <summary>
                    /// Index of the font in the font manager
                    /// </summary>
                    public int Index { get; }

                    /// <summary>
                    /// Font size at which the textures were created.
                    /// </summary>
                    public float PtSize { get; }

                    /// <summary>
                    /// Default scaling applied to font. Used to normalize font size.
                    /// </summary>
                    public float BaseScale { get; }

                    /// <summary>
                    /// Returns the index for this font using regular styling
                    /// </summary>
                    public Vector2I Regular => new Vector2I(Index, 0);

                    /// <summary>
                    /// Returns the index for the bolded version of this font
                    /// </summary>
                    public Vector2I Bold => new Vector2I(Index, 1);

                    /// <summary>
                    /// Returns the index for the italicised version of this font
                    /// </summary>
                    public Vector2I Italic => new Vector2I(Index, 2);

                    /// <summary>
                    /// Returns the index for the bold italic version of this font
                    /// </summary>
                    public Vector2I BoldItalic => new Vector2I(Index, 3);

                    private readonly Func<int, bool> IsFontDefinedFunc;

                    public FontData(FontMembers members)
                    {
                        Name = members.Item1;
                        Index = members.Item2;
                        PtSize = members.Item3;
                        BaseScale = members.Item4;
                        IsFontDefinedFunc = members.Item5;
                    }

                    /// <summary>
                    /// Returns true if the font is defined for the given style.
                    /// </summary>
                    public bool IsStyleDefined(FontStyles styleEnum) =>
                        IsFontDefinedFunc((int)styleEnum);

                    /// <summary>
                    /// Returns true if the font is defined for the given style.
                    /// </summary>
                    public bool IsStyleDefined(int style) =>
                        IsFontDefinedFunc(style);

                    /// <summary>
                    /// Retrieves the full index of the font style
                    /// </summary>
                    public Vector2I GetStyleIndex(int style) =>
                        new Vector2I(Index, style);

                    /// <summary>
                    /// Retrieves the full index of the font style
                    /// </summary>
                    public Vector2I GetStyleIndex(FontStyles style) =>
                        new Vector2I(Index, (int)style);

                    public override int GetHashCode()
                    {
                        return Index.GetHashCode();
                    }

                    public override bool Equals(object obj)
                    {
                        var font = obj as FontData;

                        return font != null && font.Index == Index;
                    }
                }
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRageMath;
using VRage;
using VRage.Utils;
using AtlasMembers = VRage.MyTuple<string, VRageMath.Vector2>;
using GlyphMembers = VRage.MyTuple<int, VRageMath.Vector2, VRageMath.Vector2, float, float>;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    using Client;
    using FontMembers = MyTuple<
        string, // Name
        int, // Index
        float, // PtSize
        float, // BaseScale
        Func<int, bool>, // IsStyleDefined
        ApiMemberAccessor
    >;
    using FontStyleDefinition = MyTuple<
        int, // styleID
        float, // height
        float, // baseline
        AtlasMembers[], // atlases
        KeyValuePair<char, GlyphMembers>[], // glyphs
        KeyValuePair<uint, float>[] // kernings
    >;

    namespace UI
    {
        using FontDefinition = MyTuple<
            string, // Name
            float, // PtSize
            FontStyleDefinition[] // styles
        >;

        namespace Rendering.Client
        {
            using FontManagerMembers = MyTuple<
                MyTuple<Func<int, FontMembers>, Func<int>>, // Font List
                Func<FontDefinition, FontMembers?>, // TryAddFont
                Func<string, FontMembers?>, // GetFont
                ApiMemberAccessor
            >;

            /// <summary>
            /// Manages fonts used by the Rich Hud Framework
            /// </summary>
            public sealed partial class FontManager : RichHudClient.ApiModule<FontManagerMembers>
            {
                /// <summary>
                /// Retrieves default font for Space Engineers with regular styling.
                /// </summary>
                public static Vector2I Default => Vector2I.Zero;

                /// <summary>
                /// Read-only collection of all registered fonts.
                /// </summary>
                public static IReadOnlyList<IFontMin> Fonts => Instance.fonts;

                private static FontManager Instance
                {
                    get { Init(); return instance; }
                    set { instance = value; }
                }
                private static FontManager instance;

                private readonly ReadOnlyApiCollection<IFontMin> fonts;
                private readonly Func<FontDefinition, FontMembers?> TryAddFontFunc;
                private readonly Func<string, FontMembers?> GetFontFunc;

                private FontManager() : base(ApiModuleTypes.FontManager, false, true)
                {
                    var members = GetApiData();

                    Func<int, IFontMin> fontGetter = x => new FontData(members.Item1.Item1(x));
                    fonts = new ReadOnlyApiCollection<IFontMin>(fontGetter, members.Item1.Item2);

                    TryAddFontFunc = members.Item2;
                    GetFontFunc = members.Item3;
                }

                private static void Init()
                {
                    if (instance == null)
                        instance = new FontManager();
                }

                public override void Close()
                {
                    instance = null;
                }

                /// <summary>
                /// Attempts to register a new font using API data.
                /// </summary>
                public static bool TryAddFont(FontDefinition fontData) =>
                    Instance.TryAddFontFunc(fontData) != null;

                /// <summary>
                /// Attempts to register a new font using API data. Returns the font created.
                /// </summary>
                public static bool TryAddFont(FontDefinition fontData, out IFontMin font)
                {
                    FontMembers? members = Instance.TryAddFontFunc(fontData);

                    if (members != null)
                    {
                        font = new FontData(members.Value);
                        return true;
                    }
                    else
                    {
                        font = null;
                        return false;
                    }
                }

                /// <summary>
                /// Retrieves the font with the given name.
                /// </summary>
                public static IFontMin GetFont(string name)
                {
                    FontMembers? members = Instance.GetFontFunc(name);
                    IFontMin font = null;

                    if (members != null)
                        font = new FontData(members.Value);

                    return font;
                }

                /// <summary>
                /// Retrieves the font with the given name.
                /// </summary>
                public static IFontMin GetFont(int index) =>
                    Instance.fonts[index];

                /// <summary>
                /// Retrieves the font style index of the font with the given name and style.
                /// </summary>
                public static Vector2I GetStyleIndex(string name, FontStyles style = FontStyles.Regular)
                {
                    IFontMin font = GetFont(name);
                    return new Vector2I(font.Index, (int)style);
                }
            }
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;

    namespace UI.Client
    {
        /// <summary>
        /// Horizontally scrolling list of control tiles.
        /// </summary>
        public class ControlCategory : IControlCategory
        {
            /// <summary>
            /// Category name
            /// </summary>
            public string HeaderText
            {
                get { return GetOrSetMemberFunc(null, (int)ControlCatAccessors.HeaderText) as string; }
                set { GetOrSetMemberFunc(value, (int)ControlCatAccessors.HeaderText); }
            }

            /// <summary>
            /// Category description
            /// </summary>
            public string SubheaderText
            {
                get { return GetOrSetMemberFunc(null, (int)ControlCatAccessors.SubheaderText) as string; }
                set { GetOrSetMemberFunc(value, (int)ControlCatAccessors.SubheaderText); }
            }

            /// <summary>
            /// Read only collection of <see cref="ControlTile"/>s assigned to this category
            /// </summary>
            public IReadOnlyList<ControlTile> Tiles { get; }

            public IControlCategory TileContainer => this;

            /// <summary>
            /// Unique identifier
            /// </summary>
            public object ID => data.Item3;

            /// <summary>
            /// Determines whether or not the element will be drawn.
            /// </summary>
            public bool Enabled
            {
                get { return (bool)GetOrSetMemberFunc(null, (int)ControlCatAccessors.Enabled); }
                set { GetOrSetMemberFunc(value, (int)ControlCatAccessors.Enabled); }
            }

            private ApiMemberAccessor GetOrSetMemberFunc => data.Item1;
            private readonly ControlContainerMembers data;

            public ControlCategory() : this(RichHudTerminal.GetNewMenuCategory())
            { }

            public ControlCategory(ControlContainerMembers data)
            {
                this.data = data;

                var GetTileDataFunc = data.Item2.Item1 as Func<int, ControlContainerMembers>;
                Func<int, ControlTile> GetTileFunc = x => new ControlTile(GetTileDataFunc(x));

                Tiles = new ReadOnlyApiCollection<ControlTile>(GetTileFunc, data.Item2.Item2);
            }

            IEnumerator<ControlTile> IEnumerable<ControlTile>.GetEnumerator() =>
                Tiles.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                Tiles.GetEnumerator();

            /// <summary>
            /// Adds a <see cref="IControlTile"/> to the category
            /// </summary>
            public void Add(ControlTile tile) =>
                GetOrSetMemberFunc(tile.ID, (int)ControlCatAccessors.AddMember);

            public ControlContainerMembers GetApiData() =>
                data;
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;

    /// <summary>
    /// Small collection of terminal controls organized into a single block. No more than 1-3
    /// controls should be added to a tile. If a group of controls can't fit on a tile, then they
    /// will be drawn outside its bounds.
    /// </summary>
    public class ControlTile : IControlTile
    {
        /// <summary>
        /// Read only collection of <see cref="TerminalControlBase"/>s attached to the tile
        /// </summary>
        public IReadOnlyList<TerminalControlBase> Controls { get; }

        public IControlTile ControlContainer => this;

        /// <summary>
        /// Determines whether or not the tile will be rendered in the list.
        /// </summary>
        public bool Enabled
        {
            get { return (bool)GetOrSetMemberFunc(null, (int)ControlTileAccessors.Enabled); }
            set { GetOrSetMemberFunc(value, (int)ControlTileAccessors.Enabled); }
        }

        /// <summary>
        /// Unique identifier
        /// </summary>
        public object ID => tileMembers.Item3;

        private ApiMemberAccessor GetOrSetMemberFunc => tileMembers.Item1;
        private readonly ControlContainerMembers tileMembers;

        public ControlTile() : this(RichHudTerminal.GetNewMenuTile())
        { }

        public ControlTile(ControlContainerMembers data)
        {
            tileMembers = data;

            var GetControlDataFunc = data.Item2.Item1 as Func<int, ControlMembers>;
            Func<int, TerminalControlBase> GetControlFunc = (x => new TerminalControl(GetControlDataFunc(x)));

            Controls = new ReadOnlyApiCollection<TerminalControlBase>(GetControlFunc, data.Item2.Item2);
        }

        IEnumerator<ITerminalControl> IEnumerable<ITerminalControl>.GetEnumerator() =>
            Controls.GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() =>
            Controls.GetEnumerator();

        /// <summary>
        /// Adds a <see cref="TerminalControlBase"/> to the tile
        /// </summary>
        public void Add(TerminalControlBase control) =>
            GetOrSetMemberFunc(control.ID, (int)ControlTileAccessors.AddControl);

        /// <summary>
        /// Retrieves information needed by the Framework API 
        /// </summary>
        public ControlContainerMembers GetApiData() =>
            tileMembers;

        private class TerminalControl : TerminalControlBase
        {
            public TerminalControl(ControlMembers data) : base(data)
            { }
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework.UI
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using CollectionData = MyTuple<Func<int, ApiMemberAccessor>, Func<int>>;

    public class ListBoxData<T> : ReadOnlyApiCollection<EntryData<T>>
    {
        /// <summary>
        /// Current selection. Null if empty.
        /// </summary>
        public EntryData<T> Selection 
        {
            get 
            {
                var index = (int)GetOrSetMemberFunc(null, (int)ListBoxAccessors.SelectionIndex);
                return (index != -1) ? this[index] : null;
            }
        }

        /// <summary>
        /// Index of the current selection. -1 if empty.
        /// </summary>
        public int SelectionIndex
        {
            get
            {
                return (int)GetOrSetMemberFunc(null, (int)ListBoxAccessors.SelectionIndex);
            }
        }

        private readonly ApiMemberAccessor GetOrSetMemberFunc;

        public ListBoxData(ApiMemberAccessor GetOrSetMemberFunc) : base(GetListData(GetOrSetMemberFunc))
        {
            this.GetOrSetMemberFunc = GetOrSetMemberFunc;
        }

        private static MyTuple<Func<int, EntryData<T>>, Func<int>> GetListData(ApiMemberAccessor GetOrSetMemberFunc)
        {
            var listData = (CollectionData)GetOrSetMemberFunc(null, (int)ListBoxAccessors.ListMembers);
            Func<int, EntryData<T>> GetEntryFunc = x => new EntryData<T>(listData.Item1(x));

            return new MyTuple<Func<int, EntryData<T>>, Func<int>>()
            {
                Item1 = GetEntryFunc,
                Item2 = listData.Item2
            };
        }

        /// <summary>
        /// Adds a new member to the list box with the given name and associated
        /// object.
        /// </summary>
        public void Add(RichText text, T assocObject)
        {
            var data = new MyTuple<List<RichStringMembers>, object>()
            {
                Item1 = text.apiData,
                Item2 = assocObject
            };

            GetOrSetMemberFunc(data, (int)ListBoxAccessors.Add);
        }

        /// <summary>
        /// Inserts an entry at the given index.
        /// </summary>
        public void Insert(int index, RichText text, T assocObject)
        {
            var data = new MyTuple<int, List<RichStringMembers>, object>()
            {
                Item1 = index,
                Item2 = text.apiData,
                Item3 = assocObject
            };

            GetOrSetMemberFunc(data, (int)ListBoxAccessors.Insert);
        }

        /// <summary>
        /// Removes the member at the given index from the list box.
        /// </summary>
        public bool Remove(EntryData<T> entry) =>
            (bool)GetOrSetMemberFunc(entry.ID, (int)ListBoxAccessors.Remove);

        /// <summary>
        /// Removes the member at the given index from the list box.
        /// </summary>
        public void RemoveAt(int index) =>
            GetOrSetMemberFunc(index, (int)ListBoxAccessors.RemoveAt);

        /// <summary>
        /// Sets the selection to the specified entry.
        /// </summary>
        public void SetSelection(EntryData<T> entry) =>
            GetOrSetMemberFunc(entry.ID, (int)ListBoxAccessors.Selection);

        /// <summary>
        /// Sets the selection to the member associated with the given object.
        /// </summary>
        public void SetSelection(T assocMember) =>
            GetOrSetMemberFunc(assocMember, (int)ListBoxAccessors.SetSelectionAtData);

        /// <summary>
        /// Sets the selection to the member associated with the given object.
        /// </summary>
        public void SetSelection(int index) =>
            GetOrSetMemberFunc(index, (int)ListBoxAccessors.SelectionIndex);
    }

    public class EntryData<T>
    {
        /// <summary>
        /// Name of the list box entry as shown in the UI
        /// </summary>
        public RichText Text
        {
            get { return new RichText(GetOrSetMemberFunc(null, (int)ListBoxEntryAccessors.Name) as List<RichStringMembers>); }
            set { GetOrSetMemberFunc(value.apiData, (int)ListBoxEntryAccessors.Name); }
        }

        /// <summary>
        /// Indicates whether or not the element will appear in the list
        /// </summary>
        public bool Enabled
        {
            get { return (bool)GetOrSetMemberFunc(null, (int)ListBoxEntryAccessors.Enabled); }
            set { GetOrSetMemberFunc(value, (int)ListBoxEntryAccessors.Enabled); }
        }

        /// <summary>
        /// Object paired with the entry
        /// </summary>
        public T AssocObject
        {
            get { return (T)GetOrSetMemberFunc(null, (int)ListBoxEntryAccessors.AssocObject); }
            set { GetOrSetMemberFunc(value, (int)ListBoxEntryAccessors.AssocObject); }
        }

        /// <summary>
        /// Unique identifier
        /// </summary>
        public object ID => GetOrSetMemberFunc(null, (int)ListBoxEntryAccessors.ID);

        private readonly ApiMemberAccessor GetOrSetMemberFunc;

        public EntryData(ApiMemberAccessor GetOrSetMemberFunc)
        {
            this.GetOrSetMemberFunc = GetOrSetMemberFunc;
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;

    namespace UI.Client
    {

        public sealed partial class RichHudTerminal
        {
            private class ModControlRoot : TerminalPageCategoryBase, IModControlRoot
            {
                public IReadOnlyList<TerminalPageCategoryBase> Subcategories { get; }

                /// <summary>
                /// Invoked when a new page is selected
                /// </summary>
                public event EventHandler SelectionChanged;

                public ModControlRoot(ControlContainerMembers data) : base(data)
                {
                    GetOrSetMemberFunc(new Action(ModRootCallback), (int)ModControlRootAccessors.GetOrSetCallback);

                    var GetCategoryDataFunc = GetOrSetMemberFunc(null, (int)ModControlRootAccessors.GetCategoryAccessors)
                        as Func<int, ControlContainerMembers>;

                    Func<int, TerminalPageCategoryBase> GetPageFunc = (x => new TerminalPageCategoryWrapper(GetCategoryDataFunc(x)));
                    Subcategories = new ReadOnlyApiCollection<TerminalPageCategoryBase>(GetPageFunc, data.Item2.Item2);
                }

                protected void ModRootCallback()
                {
                    SelectionChanged?.Invoke(this, EventArgs.Empty);
                }

                public void Add(TerminalPageCategoryBase subcategory) =>
                    GetOrSetMemberFunc(subcategory.ID, (int)ModControlRootAccessors.AddSubcategory);

                public void AddRange(IReadOnlyList<IModRootMember> members)
                {
                    foreach (IModRootMember member in members)
                    {
                        if (member is TerminalPageBase)
                            GetOrSetMemberFunc(member.ID, (int)TerminalPageCategoryAccessors.AddPage);
                        else
                            GetOrSetMemberFunc(member.ID, (int)ModControlRootAccessors.AddSubcategory);
                    }
                }

                private class TerminalPageCategoryWrapper : TerminalPageCategoryBase
                {
                    public TerminalPageCategoryWrapper(ControlContainerMembers data) : base(data)
                    { }
                }
            }
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using Client;
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    namespace UI.Client
    {
        using SettingsMenuMembers = MyTuple<
            ApiMemberAccessor, // GetOrSetMembers
            ControlContainerMembers, // MenuRoot
            Func<int, ControlMembers>, // GetNewControl
            Func<int, ControlContainerMembers>, // GetNewContainer
            Func<int, ControlMembers> // GetNewModPage
        >;

        /// <summary>
        /// Windowed settings menu shared by mods using the framework.
        /// </summary>
        public sealed partial class RichHudTerminal : RichHudClient.ApiModule<SettingsMenuMembers>
        {
            /// <summary>
            /// Mod control root for the client.
            /// </summary>
            public static IModControlRoot Root => Instance.menuRoot;

            /// <summary>
            /// Determines whether or not the terminal is currently open.
            /// </summary>
            public static bool Open => (bool)Instance.GetOrSetMembersFunc(null, (int)TerminalAccessors.GetMenuOpen);

            private static RichHudTerminal Instance
            {
                get { Init(); return _instance; }
                set { _instance = value; }
            }
            private static RichHudTerminal _instance;

            private readonly ModControlRoot menuRoot;
            private readonly ApiMemberAccessor GetOrSetMembersFunc;
            private readonly Func<int, ControlMembers> GetNewControlFunc;
            private readonly Func<int, ControlContainerMembers> GetNewContainerFunc;
            private readonly Func<int, ControlMembers> GetNewPageFunc;
            private readonly Func<ControlContainerMembers> GetNewPageCategoryFunc;

            private RichHudTerminal() : base(ApiModuleTypes.SettingsMenu, false, true)
            {
                var data = GetApiData();

                GetOrSetMembersFunc = data.Item1;
                GetNewControlFunc = data.Item3;
                GetNewContainerFunc = data.Item4;
                GetNewPageFunc = data.Item5;

                GetNewPageCategoryFunc = 
                    GetOrSetMembersFunc(null, (int)TerminalAccessors.GetNewPageCategoryFunc) as Func<ControlContainerMembers>;

                menuRoot = new ModControlRoot(data.Item2);
            }

            public static void Init()
            {
                if (_instance == null)
                {
                    _instance = new RichHudTerminal();
                }
            }

            /// <summary>
            /// Toggles the menu between open and closed
            /// </summary>
            public static void ToggleMenu()
            {
                if (_instance == null)
                    Init();

                _instance.GetOrSetMembersFunc(null, (int)TerminalAccessors.ToggleMenu);
            }

            /// <summary>
            /// Open the menu if chat is visible
            /// </summary>
            public static void OpenMenu()
            {
                if (_instance == null)
                    Init();

                _instance.GetOrSetMembersFunc(null, (int)TerminalAccessors.OpenMenu);
            }

            /// <summary>
            /// Close the menu
            /// </summary>
            public static void CloseMenu()
            {
                if (_instance == null)
                    Init();

                _instance.GetOrSetMembersFunc(null, (int)TerminalAccessors.CloseMenu);
            }

            /// <summary>
            /// Sets the current page to the one given
            /// </summary>
            public static void OpenToPage(TerminalPageBase newPage)
            {
                _instance.GetOrSetMembersFunc(new MyTuple<object, object>(_instance.menuRoot.ID, newPage.ID), (int)TerminalAccessors.OpenToPage);
            }

            /// <summary>
            /// Sets the current page to the one given
            /// </summary>
            public static void SetPage(TerminalPageBase newPage)
            {
                _instance.GetOrSetMembersFunc(new MyTuple<object, object>(_instance.menuRoot.ID, newPage.ID), (int)TerminalAccessors.SetPage);
            }

            public override void Close()
            {
                _instance = null;
            }

            public static ControlMembers GetNewMenuControl(MenuControls controlEnum) =>
                Instance.GetNewControlFunc((int)controlEnum);

            public static ControlContainerMembers GetNewMenuTile() =>
                Instance.GetNewContainerFunc((int)ControlContainers.Tile);

            public static ControlContainerMembers GetNewMenuCategory() =>
                Instance.GetNewContainerFunc((int)ControlContainers.Category);

            public static ControlMembers GetNewMenuPage(ModPages pageEnum) =>
                Instance.GetNewPageFunc((int)pageEnum);

            public static ControlContainerMembers GetNewPageCategory() =>
                Instance.GetNewPageCategoryFunc();
        }
    }
}﻿using System;
using System.Collections;
using System.Collections.Generic;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;

    namespace UI.Client
    {
        public class TerminalPageCategory : TerminalPageCategoryBase
        { 
            public TerminalPageCategory() : base(RichHudTerminal.GetNewPageCategory())
            { }
        }

        public abstract class TerminalPageCategoryBase : ITerminalPageCategory
        {
            /// <summary>
            /// Name of the mod as it appears in the <see cref="RichHudTerminal"/> mod list
            /// </summary>
            public string Name
            {
                get { return GetOrSetMemberFunc(null, (int)TerminalPageCategoryAccessors.Name) as string; }
                set { GetOrSetMemberFunc(value, (int)TerminalPageCategoryAccessors.Name); }
            }

            /// <summary>
            /// Read only collection of <see cref="TerminalPageBase"/>s assigned to this object.
            /// </summary>
            public IReadOnlyList<TerminalPageBase> Pages { get; }

            public ITerminalPageCategory PageContainer => this;

            /// <summary>
            /// Unique identifer
            /// </summary>
            public object ID => data.Item3;

            /// <summary>
            /// Currently selected <see cref="TerminalPageBase"/>.
            /// </summary>
            public TerminalPageBase SelectedPage
            {
                get
                {
                    object id = GetOrSetMemberFunc(null, (int)TerminalPageCategoryAccessors.Selection);

                    if (id != null)
                    {
                        for (int n = 0; n < Pages.Count; n++)
                        {
                            if (id == Pages[n].ID)
                                return Pages[n];
                        }
                    }

                    return null;
                }
            }

            /// <summary>
            /// Determines whether or not the element will appear in the list.
            /// Disabled by default.
            /// </summary>
            public bool Enabled
            {
                get { return (bool)GetOrSetMemberFunc(null, (int)TerminalPageCategoryAccessors.Enabled); }
                set { GetOrSetMemberFunc(value, (int)TerminalPageCategoryAccessors.Enabled); }
            }

            protected ApiMemberAccessor GetOrSetMemberFunc => data.Item1;
            protected readonly ControlContainerMembers data;

            public TerminalPageCategoryBase(ControlContainerMembers data)
            {
                this.data = data;

                var GetPageDataFunc = data.Item2.Item1 as Func<int, ControlMembers>;
                Func<int, TerminalPageBase> GetPageFunc = (x => new TerminalPage(GetPageDataFunc(x)));
                Pages = new ReadOnlyApiCollection<TerminalPageBase>(GetPageFunc, data.Item2.Item2);
            }

            /// <summary>
            /// Adds the given <see cref="TerminalPageBase"/> to the object.
            /// </summary>
            public void Add(TerminalPageBase page) =>
                GetOrSetMemberFunc(page.ID, (int)TerminalPageCategoryAccessors.AddPage);

            /// <summary>
            /// Adds the given ranges of pages to the control root.
            /// </summary>
            public void AddRange(IReadOnlyList<TerminalPageBase> pages)
            {
                foreach (TerminalPageBase page in pages)
                    GetOrSetMemberFunc(page.ID, (int)TerminalPageCategoryAccessors.AddPage);
            }

            /// <summary>
            /// Retrieves data used by the Framework API
            /// </summary>
            public ControlContainerMembers GetApiData() =>
                data;

            public IEnumerator<TerminalPageBase> GetEnumerator() =>
                Pages.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                Pages.GetEnumerator();

            protected class TerminalPage : TerminalPageBase
            {
                public TerminalPage(ControlMembers data) : base(data)
                { }
            }
        }
    }
}﻿using System;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    /// <summary>
    /// Clickable button. Mimics the appearance of the terminal button in the SE terminal.
    /// </summary>
    public class TerminalButton : TerminalControlBase
    {
        public TerminalButton() : base(MenuControls.TerminalButton)
        { }
    }
}﻿using System;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    /// <summary>
    /// Labeled checkbox designed to mimic the appearance of checkboxes in the SE terminal.
    /// </summary>
    public class TerminalCheckbox : TerminalValue<bool>
    {
        public TerminalCheckbox() : base(MenuControls.Checkbox)
        { }
    }
}﻿using System;
using System.Text;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    /// <summary>
    /// An RGB color picker using sliders for each channel. Designed to mimic the appearance of the color picker
    /// in the SE terminal.
    /// </summary>
    public class TerminalColorPicker : TerminalValue<Color>
    {
        public TerminalColorPicker() : base(MenuControls.ColorPicker)
        { }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework.UI.Client
{
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    /// <summary>
    /// Base type for all controls in the Rich Hud Terminal.
    /// </summary>
    public abstract class TerminalControlBase : ITerminalControl
    {
        /// <summary>
        /// Invoked whenver a change occurs to a control that requires a response, like a change
        /// to a value.
        /// </summary>
        public event EventHandler ControlChanged;

        /// <summary>
        /// The name of the control as it appears in the terminal.
        /// </summary>
        public string Name
        {
            get { return GetOrSetMember(null, (int)TerminalControlAccessors.Name) as string; }
            set { GetOrSetMember(value, (int)TerminalControlAccessors.Name); }
        }

        /// <summary>
        /// Determines whether or not the control should be visible in the terminal.
        /// </summary>
        public bool Enabled
        {
            get { return (bool)GetOrSetMember(null, (int)TerminalControlAccessors.Enabled); }
            set { GetOrSetMember(value, (int)TerminalControlAccessors.Enabled); }
        }

        /// <summary>
        /// Optional tooltip for the control
        /// </summary>
        public ToolTip ToolTip
        {
            get { return _toolTip; }
            set { _toolTip = value; GetOrSetMember(value.GetToolTipFunc, (int)TerminalControlAccessors.ToolTip); }
        }

        /// <summary>
        /// Unique identifier
        /// </summary>
        public object ID { get; }

        public EventHandler ControlChangedHandler { get; set; }

        protected readonly ApiMemberAccessor GetOrSetMember;
        protected ToolTip _toolTip;

        public TerminalControlBase(MenuControls controlEnum) : this(RichHudTerminal.GetNewMenuControl(controlEnum))
        {
            // Register event callback
            GetOrSetMember(new Action(ControlChangedCallback), (int)TerminalControlAccessors.GetOrSetControlCallback);
        }

        protected virtual void ControlChangedCallback()
        {
            Internal.ExceptionHandler.Run(() => 
            {
                ControlChanged?.Invoke(this, EventArgs.Empty);
                ControlChangedHandler?.Invoke(this, EventArgs.Empty);
            });
        }

        public TerminalControlBase(ControlMembers data)
        {
            GetOrSetMember = data.Item1;
            ID = data.Item2;
        }

        public ControlMembers GetApiData()
        {
            return new ControlMembers()
            {
                Item1 = GetOrSetMember,
                Item2 = ID
            };
        }
    }

    /// <summary>
    /// Base type for settings menu controls associated with a value of a given type.
    /// </summary>
    public abstract class TerminalValue<TValue> : TerminalControlBase, ITerminalValue<TValue>
    {
        /// <summary>
        /// Value associated with the control.
        /// </summary>
        public virtual TValue Value
        {
            get { return (TValue)GetOrSetMember(null, (int)TerminalControlAccessors.Value); }
            set { GetOrSetMember(value, (int)TerminalControlAccessors.Value); }
        }

        /// <summary>
        /// Used to periodically update the value associated with the control. Optional.
        /// </summary>
        public Func<TValue> CustomValueGetter
        {
            get { return GetOrSetMember(null, (int)TerminalControlAccessors.ValueGetter) as Func<TValue>; }
            set { GetOrSetMember(value, (int)TerminalControlAccessors.ValueGetter); }
        }

        public TerminalValue(MenuControls controlEnum) : base(controlEnum)
        { }
    }
}﻿using System;
using System.Text;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    public enum DragBoxAccessors : int
    {
        BoxSize = 16,
        AlignToEdge = 17,
    }

    /// <summary>
    /// A terminal control that uses a draggable window to indicate a position on the screen.
    /// </summary>
    public class TerminalDragBox : TerminalValue<Vector2>
    {
        /// <summary>
        /// Size of the window spawned by the control.
        /// </summary>
        public Vector2 BoxSize
        {
            get { return (Vector2)GetOrSetMember(null, (int)DragBoxAccessors.BoxSize); }
            set { GetOrSetMember(value, (int)DragBoxAccessors.BoxSize); }
        }

        /// <summary>
        /// Determines whether or not the window will automatically align itself to one side of the screen
        /// or the other.
        /// </summary>
        public bool AlignToEdge
        {
            get { return (bool)GetOrSetMember(null, (int)DragBoxAccessors.AlignToEdge); }
            set { GetOrSetMember(value, (int)DragBoxAccessors.AlignToEdge); }
        }

        public TerminalDragBox() : base(MenuControls.DragBox)
        { }
    }
}﻿using System;
using System.Text;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework.UI.Client
{
    using CollectionData = MyTuple<Func<int, ApiMemberAccessor>, Func<int>>;

    /// <summary>
    /// A dropdown list with a label. Designed to mimic the appearance of the dropdown in the SE terminal.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class TerminalDropdown<T> : TerminalValue<EntryData<T>>
    {
        /// <summary>
        /// Currently selected list member.
        /// </summary>
        public override EntryData<T> Value
        {
            get { return List.Selection; }
            set { List.SetSelection(value); }
        }

        public ListBoxData<T> List { get; }

        public TerminalDropdown() : base(MenuControls.DropdownControl)
        {
            var listData = GetOrSetMember(null, (int)ListControlAccessors.ListAccessors) as ApiMemberAccessor;
            
            List = new ListBoxData<T>(listData);
        }
    }
}﻿using System;
using System.Text;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using CollectionData = MyTuple<Func<int, ApiMemberAccessor>, Func<int>>;

    public enum ListControlAccessors : int
    {
        ListAccessors = 16,
    }

    /// <summary>
    /// A fixed size list box with a label. Designed to mimic the appearance of the list box in the SE terminal.
    /// </summary>
    public class TerminalList<T> : TerminalValue<EntryData<T>>
    {
        /// <summary>
        /// Currently selected list member.
        /// </summary>
        public override EntryData<T> Value
        {
            get { return List.Selection; }
            set { List.SetSelection(value); }
        }

        public ListBoxData<T> List { get; }

        public TerminalList() : base(MenuControls.ListControl)
        {
            var listData = GetOrSetMember(null, (int)ListControlAccessors.ListAccessors) as ApiMemberAccessor;

            List = new ListBoxData<T>(listData);
        }
    }
}﻿using System;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    /// <summary>
    /// On/Off toggle designed to mimic the appearance of the On/Off button in the SE Terminal.
    /// </summary>
    public class TerminalOnOffButton : TerminalValue<bool>
    {
        public TerminalOnOffButton() : base(MenuControls.OnOffButton)
        { }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    public enum SliderSettingsAccessors : int
    {
        /// <summary>
        /// Float
        /// </summary>
        Min = 16,

        /// <summary>
        /// Float
        /// </summary>
        Max = 17,

        /// <summary>
        /// Float
        /// </summary>
        Percent = 18,

        /// <summary>
        /// RichStringMembers[]
        /// </summary>
        ValueText = 19,
    }

    /// <summary>
    /// Labeled slider used to set float values in the settings menu. Mimics the appearance of the slider in the
    /// SE terminal.
    /// </summary>
    public class TerminalSlider : TerminalValue<float>
    {
        /// <summary>
        /// Minimum configurable value for the slider.
        /// </summary>
        public float Min
        {
            get { return (float)GetOrSetMember(null, (int)SliderSettingsAccessors.Min); }
            set { GetOrSetMember(value, (int)SliderSettingsAccessors.Min); }
        }

        /// <summary>
        /// Maximum configurable value for the slider.
        /// </summary>
        public float Max
        {
            get { return (float)GetOrSetMember(null, (int)SliderSettingsAccessors.Max); }
            set { GetOrSetMember(value, (int)SliderSettingsAccessors.Max); }
        }

        /// <summary>
        /// Current slider value expreseed as a percentage between the min and maximum values.
        /// </summary>
        public float Percent
        {
            get { return (float)GetOrSetMember(null, (int)SliderSettingsAccessors.Percent); }
            set { GetOrSetMember(value, (int)SliderSettingsAccessors.Percent); }
        }

        /// <summary>
        /// Text indicating the current value of the slider. Does not automatically reflect changes to the slider value.
        /// </summary>
        public string ValueText
        {
            get { return GetOrSetMember(null, (int)SliderSettingsAccessors.ValueText) as string; }
            set { GetOrSetMember(value, (int)SliderSettingsAccessors.ValueText); }
        }

        public TerminalSlider() : base(MenuControls.SliderSetting)
        { }
    }
}﻿using System;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework.UI.Client
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    public enum TextFieldAccessors : int
    {
        CharFilterFunc = 16,
    }

    /// <summary>
    /// One-line text field with a configurable input filter delegate. Designed to mimic the appearance of the text field
    /// in the SE terminal.
    /// </summary>
    public class TerminalTextField : TerminalValue<string>
    {
        /// <summary>
        /// Restricts the range of characters allowed for input.
        /// </summary>
        public Func<char, bool> CharFilterFunc
        {
            get { return GetOrSetMember(null, (int)TextFieldAccessors.CharFilterFunc) as Func<char, bool>; }
            set { GetOrSetMember(value, (int)TextFieldAccessors.CharFilterFunc); }
        }

        public TerminalTextField() : base(MenuControls.TextField)
        { }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;

    namespace UI.Client
    {
        /// <summary>
        /// Vertically scrolling collection of control categories.
        /// </summary>
        public class ControlPage : TerminalPageBase, IControlPage
        {
            /// <summary>
            /// List of control categories registered to the page.
            /// </summary>
            public IReadOnlyList<ControlCategory> Categories { get; }

            public IControlPage<ControlCategory, ControlTile> CategoryContainer => this;

            public ControlPage() : base(ModPages.ControlPage)
            {
                var catData = (MyTuple<object, Func<int>>)GetOrSetMemberFunc(null, (int)ControlPageAccessors.CategoryData);
                var GetCatDataFunc = catData.Item1 as Func<int, ControlContainerMembers>;

                Func<int, ControlCategory> GetCatFunc = (x => new ControlCategory(GetCatDataFunc(x)));
                Categories = new ReadOnlyApiCollection<ControlCategory>(GetCatFunc, catData.Item2);
            }

            IEnumerator<ControlCategory> IEnumerable<ControlCategory>.GetEnumerator() =>
                Categories.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                Categories.GetEnumerator();

            /// <summary>
            /// Adds the given control category to the page.
            /// </summary>
            public void Add(ControlCategory category) =>
                GetOrSetMemberFunc(category.ID, (int)ControlPageAccessors.AddCategory);
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;
using BindDefinitionData = VRage.MyTuple<string, string[]>;

namespace RichHudFramework
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;

    namespace UI.Client
    {
        /// <summary>
        /// Scrollable list of bind group controls.
        /// </summary>
        public class RebindPage : TerminalPageBase, IRebindPage
        {
            /// <summary>
            /// List of bind groups registered to the page.
            /// </summary>
            public IReadOnlyList<IBindGroup> BindGroups => bindGroups;

            public RebindPage GroupContainer => this;

            private readonly List<IBindGroup> bindGroups;

            public RebindPage() : base(ModPages.RebindPage)
            {
                bindGroups = new List<IBindGroup>();
            }

            /// <summary>
            /// Adds the given bind group to the page.
            /// </summary>
            public void Add(IBindGroup bindGroup)
            {
                GetOrSetMemberFunc(bindGroup.ID, (int)RebindPageAccessors.Add);
                bindGroups.Add(bindGroup);
            }

            /// <summary>
            /// Adds the given bind group to the page along with its associated default configuration.
            /// </summary>
            public void Add(IBindGroup bindGroup, BindDefinition[] defaultBinds)
            {
                BindDefinitionData[] data = new BindDefinitionData[defaultBinds.Length];

                for (int n = 0; n < defaultBinds.Length; n++)
                    data[n] = defaultBinds[n];

                GetOrSetMemberFunc(new MyTuple<object, BindDefinitionData[]>(bindGroup.ID, data), (int)RebindPageAccessors.Add);
                bindGroups.Add(bindGroup);
            }

            public IEnumerator<IBindGroup> GetEnumerator() =>
                bindGroups.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                bindGroups.GetEnumerator();
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;
using EventAccessor = VRage.MyTuple<bool, System.Action>;

namespace RichHudFramework
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;
    using ControlContainerMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember,
        MyTuple<object, Func<int>>, // Member List
        object // ID
    >;

    namespace UI.Client
    {
        public abstract class TerminalPageBase : ITerminalPage
        {
            /// <summary>
            /// Name of the <see cref="ITerminalPage"/> as it appears in the dropdown of the <see cref="IModControlRoot"/>.
            /// </summary>
            public string Name
            {
                get { return GetOrSetMemberFunc(null, (int)TerminalPageAccessors.Name) as string; }
                set { GetOrSetMemberFunc(value, (int)TerminalPageAccessors.Name); }
            }

            /// <summary>
            /// Unique identifier
            /// </summary>
            public object ID => data.Item2;

            /// <summary>
            /// Determines whether or not the <see cref="ITerminalPage"/> will be visible in the mod root.
            /// </summary>
            public bool Enabled
            {
                get { return (bool)GetOrSetMemberFunc(null, (int)TerminalPageAccessors.Enabled); }
                set { GetOrSetMemberFunc(value, (int)TerminalPageAccessors.Enabled); }
            }

            protected ApiMemberAccessor GetOrSetMemberFunc => data.Item1;
            protected readonly ControlMembers data;

            public TerminalPageBase(ModPages pageEnum)
            {
                data = RichHudTerminal.GetNewMenuPage(pageEnum);
            }

            public TerminalPageBase(ControlMembers data)
            {
                this.data = data;
            }

            /// <summary>
            /// Retrieves information used by the Framework API
            /// </summary>
            public ControlMembers GetApiData() =>
                data;
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using RichHudFramework.UI.Rendering.Client;
using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    namespace UI.Client
    {
        using TextBuilderMembers = MyTuple<
            MyTuple<Func<int, int, object>, Func<int>>, // GetLineMember, GetLineCount
            Func<Vector2I, int, object>, // GetCharMember
            Func<object, int, object>, // GetOrSetMember
            Action<IList<RichStringMembers>, Vector2I>, // Insert
            Action<IList<RichStringMembers>>, // SetText
            Action // Clear
        >;

        /// <summary>
        /// Scrollable text page used in the terminal.
        /// </summary>
        public class TextPage : TerminalPageBase, ITextPage
        {
            /// <summary>
            /// Gets/sets header text
            /// </summary>
            public RichText HeaderText
            {
                get { return new RichText(GetOrSetMemberFunc(null, (int)TextPageAccessors.GetOrSetHeader) as List<RichStringMembers>); }
                set { GetOrSetMemberFunc(value.apiData, (int)TextPageAccessors.GetOrSetHeader); }
            }

            /// <summary>
            /// Gets/sets subheader text
            /// </summary>
            public RichText SubHeaderText
            {
                get { return new RichText(GetOrSetMemberFunc(null, (int)TextPageAccessors.GetOrSetSubheader) as List<RichStringMembers>); }
                set { GetOrSetMemberFunc(value.apiData, (int)TextPageAccessors.GetOrSetSubheader); }
            }

            /// <summary>
            /// Contents of the text box.
            /// </summary>
            public RichText Text
            {
                get { return new RichText(GetOrSetMemberFunc(null, (int)TextPageAccessors.GetOrSetText) as List<RichStringMembers>); }
                set { GetOrSetMemberFunc(value.apiData, (int)TextPageAccessors.GetOrSetText); }
            }

            /// <summary>
            /// Text builder used to control the contents of the page
            /// </summary>
            public ITextBuilder TextBuilder { get; }

            public TextPage() : base(ModPages.TextPage)
            {
                TextBuilder = new BasicTextBuilder((TextBuilderMembers)GetOrSetMemberFunc(null, (int)TextPageAccessors.GetTextBuilder));
            }

            private class BasicTextBuilder : TextBuilder
            {
                public BasicTextBuilder(TextBuilderMembers members) : base(members)
                { }
            }
        }
    }
}﻿namespace RichHudFramework
{
    public enum MsgTypes : int
    {
        RegistrationRequest = 1,
        RegistrationSuccessful = 2,
        RegistrationFailed = 3,
    }

    public enum ApiModuleTypes : int
    {
        BindManager = 1,
        HudMain = 2,
        FontManager = 3,
        SettingsMenu = 4,
        BillBoardUtils = 5
    }

    public enum ClientDataAccessors : int
    {   
        GetVersionID = 1,
        GetSubtype = 2
    }

    public enum ClientSubtypes : int
    {
        Full = 1,
        NoLib = 2,
        Terminal = 3,
        FontManager = 4,
        BindManager = 5
    }
}﻿using System.Collections;
using System.Collections.Generic;
using VRage;
using VRageMath;
using System;

namespace RichHudFramework
{
    /// <summary>
    /// Read-only collection of cached and indexed RHF API wrappers
    /// </summary>
    public class ReadOnlyApiCollection<TValue> : IReadOnlyList<TValue>, IIndexedCollection<TValue>
    {
        /// <summary>
        /// Returns the element at the given index.
        /// </summary>
        public virtual TValue this[int index]
        {
            get 
            {
                int count = GetCountFunc();

                if (index >= count)
                    throw new Exception($"Index ({index}) was out of Range. Must be non-negative and less than {count}.");

                while (wrapperList.Count < count)
                {
                    for (int n = wrapperList.Count; wrapperList.Count < count; n++)
                        wrapperList.Add(GetNewWrapperFunc(n));
                }

                if (count > 9 && wrapperList.Count > count * 3)
                {
                    wrapperList.RemoveRange(count, wrapperList.Count - count);
                    wrapperList.TrimExcess();
                }

                return wrapperList[index];
            }
        }

        /// <summary>
        /// Returns the number of elements in the collection
        /// </summary>
        public virtual int Count => GetCountFunc();

        protected readonly Func<int, TValue> GetNewWrapperFunc;
        protected readonly Func<int> GetCountFunc;
        protected readonly List<TValue> wrapperList;
        protected readonly CollectionDataEnumerator<TValue> enumerator;

        public ReadOnlyApiCollection(Func<int, TValue> GetNewWrapper, Func<int> GetCount)
        {
            this.GetNewWrapperFunc = GetNewWrapper;
            this.GetCountFunc = GetCount;

            wrapperList = new List<TValue>();
            enumerator = new CollectionDataEnumerator<TValue>(x => this[x], GetCount);
        }

        public ReadOnlyApiCollection(MyTuple<Func<int, TValue>, Func<int>> tuple)
            : this(tuple.Item1, tuple.Item2)
        { }

        public virtual IEnumerator<TValue> GetEnumerator() =>
            enumerator;

        IEnumerator IEnumerable.GetEnumerator() =>
            GetEnumerator();
    }

    /// <summary>
    /// Read-only collection backed by delegates
    /// </summary>
    public class ReadOnlyCollectionData<TValue> : IReadOnlyList<TValue>, IIndexedCollection<TValue>
    {
        /// <summary>
        /// Returns the element at the given index.
        /// </summary>
        public virtual TValue this[int index] => Getter(index);

        /// <summary>
        /// Returns the number of elements in the collection
        /// </summary>
        public virtual int Count => GetCountFunc();

        protected readonly Func<int, TValue> Getter;
        protected readonly Func<int> GetCountFunc;
        protected readonly CollectionDataEnumerator<TValue> enumerator;

        public ReadOnlyCollectionData(Func<int, TValue> Getter, Func<int> GetCount)
        {
            this.Getter = Getter;
            this.GetCountFunc = GetCount;
            enumerator = new CollectionDataEnumerator<TValue>(x => this[x], GetCount);
        }

        public ReadOnlyCollectionData(MyTuple<Func<int, TValue>, Func<int>> tuple)
            : this(tuple.Item1, tuple.Item2)
        { }

        public virtual IEnumerator<TValue> GetEnumerator() =>
            enumerator;

        IEnumerator IEnumerable.GetEnumerator() =>
            GetEnumerator();
    }
}﻿using System.Collections;
using System.Collections.Generic;
using VRage;
using System;

namespace RichHudFramework
{
    /// <summary>
    /// Interface for collections with an indexer and a count property.
    /// </summary>
    public interface IIndexedCollection<T>
    {
        /// <summary>
        /// Returns the element associated with the given index.
        /// </summary>
        T this[int index] { get; }

        /// <summary>
        /// The number of elements in the collection
        /// </summary>
        int Count { get; }
    }

    /// <summary>
    /// Generic enumerator using delegates.
    /// </summary>
    public class CollectionDataEnumerator<T> : IEnumerator<T>
    {
        /// <summary>
        /// Returns the element at the enumerator's current position
        /// </summary>
        object IEnumerator.Current => Current;

        /// <summary>
        /// Returns the element at the enumerator's current position
        /// </summary>
        public T Current => Getter(index);

        protected readonly Func<int, T> Getter;
        protected readonly Func<int> CountFunc;
        protected int index;

        public CollectionDataEnumerator(Func<int, T> Getter, Func<int> CountFunc)
        {
            this.Getter = Getter;
            this.CountFunc = CountFunc;
            index = -1;
        }

        public void Dispose()
        { }

        public bool MoveNext()
        {
            index++;
            return index < CountFunc();
        }

        public void Reset()
        {
            index = -1;
        }
    }
}﻿using System.Collections;
using System.Collections.Generic;
using System.Collections.Concurrent;
using VRage;
using System;

namespace RichHudFramework
{
    /// <summary>
    /// Interface used to define the instantiation/reset behavior of types, T, in 
    /// ObjectPool(T)
    /// </summary>
    public interface IPooledObjectPolicy<T>
    {
        /// <summary>
        /// Instantiates a new object instance of type T
        /// </summary>
        T GetNewObject();

        /// <summary>
        /// Resets the object for later reuse before being added back to the pool
        /// </summary>
        void ResetObject(T obj);

        /// <summary>
        /// Resets the range of objects in the given collection
        /// </summary>
        void ResetRange(IReadOnlyList<T> objects, int index, int count);

        /// <summary>
        /// Resets the range of objects in the given collection
        /// </summary>
        void ResetRange<T2>(IReadOnlyList<MyTuple<T, T2>> objects, int index, int count);
    }

    /// <summary>
    /// Generic pooled object policy using delegates
    /// </summary>
    public class PooledObjectPolicy<T> : IPooledObjectPolicy<T>
    {
        private readonly Func<T> GetNewObjectFunc;
        private readonly Action<T> ResetObjectAction;

        public PooledObjectPolicy(Func<T> GetNewObjectFunc, Action<T> ResetObjectAction)
        {
            if (GetNewObjectFunc == null || ResetObjectAction == null)
                throw new Exception("Neither GetNewObjectFunc nor ResetObjectAction can be null.");
        
            this.GetNewObjectFunc = GetNewObjectFunc;
            this.ResetObjectAction = ResetObjectAction;
        }

        /// <summary>
        /// Instantiates a new object instance of type T
        /// </summary>
        public T GetNewObject()
        {
            return GetNewObjectFunc();
        }

        /// <summary>
        /// Resets the object for later reuse before being added back to the pool
        /// </summary>
        public void ResetObject(T obj)
        {
            ResetObjectAction(obj);
        }

        /// <summary>
        /// Resets the range of objects in the given collection
        /// </summary>
        public void ResetRange(IReadOnlyList<T> objects, int index, int count)
        {
            for (int n = 0; (n < count && (index + n) < objects.Count); n++)
                ResetObjectAction(objects[index + n]);
        }

        /// <summary>
        /// Resets the range of objects in the given collection
        /// </summary>
        public void ResetRange<T2>(IReadOnlyList<MyTuple<T, T2>> objects, int index, int count)
        {
            for (int n = 0; (n < count && (index + n) < objects.Count); n++)
                ResetObjectAction(objects[index + n].Item1);
        }
    }

    /// <summary>
    /// Maintains a pool of reusable reference types. Based on List(T); not thread safe.
    /// </summary>
    public class ObjectPool<T>
    {
        public int Count => pooledObjects.Count;

        public int Capacity => pooledObjects.Capacity;

        protected readonly List<T> pooledObjects;
        protected readonly IPooledObjectPolicy<T> objectPolicy;

        /// <summary>
        /// Creates a new ObjectPool with the given object policy
        /// </summary>
        public ObjectPool(IPooledObjectPolicy<T> objectPolicy)
        {
            if (objectPolicy == null)
                throw new Exception("Pooled object policy cannot be null.");

            pooledObjects = new List<T>();
            this.objectPolicy = objectPolicy;
        }

        /// <summary>
        /// Creates a new ObjectPool with an generic object policy defined by the given delegates
        /// </summary>
        public ObjectPool(Func<T> GetNewObjectFunc, Action<T> ResetObjectAction)
        {
            if (GetNewObjectFunc == null || ResetObjectAction == null)
                throw new Exception("Neither GetNewObjectFunc nor ResetObjectAction can be null.");

            this.pooledObjects = new List<T>();
            this.objectPolicy = new PooledObjectPolicy<T>(GetNewObjectFunc, ResetObjectAction);
        }

        /// <summary>
        /// Removes and returns and object from the pool or creates
        /// a new one if none are available.
        /// </summary>
        public T Get()
        {
            T obj;

            if (pooledObjects.Count > 0)
            {
                int last = pooledObjects.Count - 1;
                obj = pooledObjects[last];
                pooledObjects.RemoveAt(last);
            }
            else
            {
                obj = objectPolicy.GetNewObject();
            }

            return obj;
        }

        /// <summary>
        /// Adds the given object back to the pool for later reuse.
        /// </summary>
        public void Return(T obj)
        {
            objectPolicy.ResetObject(obj);
            pooledObjects.EnsureCapacity(Capacity);
            pooledObjects.Add(obj);
        }

        /// <summary>
        /// Returns the specified range of objects in the collection to the pool.
        /// </summary>
        public void ReturnRange(IReadOnlyList<T> objects, int index = -1, int count = -1)
        {
            if (index == -1)
                index = 0;

            if (count == -1)
                count = objects.Count;

            objectPolicy.ResetRange(objects, index, count);
            pooledObjects.EnsureCapacity(Capacity);

            for (int n = 0; (n < count && (index + n) < objects.Count); n++)
                pooledObjects.Add(objects[index + n]);
        }

        /// <summary>
        /// Returns the specified range of objects in the collection to the pool.
        /// </summary>
        public void ReturnRange<T2>(IReadOnlyList<MyTuple<T, T2>> objects, int index = -1, int count = -1)
        {
            if (index == -1)
                index = 0;

            if (count == -1)
                count = objects.Count;

            objectPolicy.ResetRange(objects, index, count);
            pooledObjects.EnsureCapacity(Capacity);

            for (int n = 0; (n < count && (index + n) < objects.Count); n++)
                pooledObjects.Add(objects[index + n].Item1);
        }

        /// <summary>
        /// Sets the capacity of the pool equal to the number of members
        /// </summary>
        public void TrimExcess()
        {
            pooledObjects.TrimExcess();
        }

        /// <summary>
        /// Clears all objects from the pool
        /// </summary>
        public void Clear()
        {
            pooledObjects.Clear();
        }
    }
}﻿using ParallelTasks;
using RichHudFramework.Internal;
using Sandbox.ModAPI;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;
using VRageMath;

namespace RichHudFramework
{
    /// <summary>
    /// Simple aggregate exception class. Feed it a list of exceptions and out pops a new exception with their contents
    /// crammed into one message.
    /// </summary>
    public class AggregateException : Exception
    {
        public AggregateException(string aggregatedMsg) : base(aggregatedMsg)
        { }

        public AggregateException(IReadOnlyList<Exception> exceptions) : base(GetExceptionMessages(exceptions))
        { }

        public AggregateException(IReadOnlyList<AggregateException> exceptions) : base(GetExceptionMessages(exceptions))
        { }

        private static string GetExceptionMessages<T>(IReadOnlyList<T> exceptions) where T : Exception
        {
            StringBuilder sb = new StringBuilder(exceptions[0].Message.Length * exceptions.Count);

            for (int n = 0; n < exceptions.Count; n++)
                if (n != exceptions.Count - 1)
                    sb.Append(exceptions[n].ToString() + "\n");
                else
                    sb.Append(exceptions[n].ToString());

            return sb.ToString();
        }
    }

    /// <summary>
    /// Used to separate exceptions thrown manually in response to expected exceptions. Usually used in conjunction 
    /// with IO/serialization operations.
    /// </summary>
    public class KnownException : Exception
    {
        public KnownException() : base()
        { }

        public KnownException(string message) : base(message)
        { }

        public KnownException(string message, Exception innerException) : base(message, innerException)
        { }
    }

    public class TaskPool : RichHudComponentBase
    {
        /// <summary>
        /// Sets the limit for the total number of tasks running in all <see cref="TaskPool"/>s.
        /// </summary>
        public static int MaxTasksRunning { get { return maxTasksRunning; } set { maxTasksRunning = MathHelper.Clamp(value, 1, 10); } }
        private static int maxTasksRunning = 1, tasksRunningCount = 0;

        private readonly List<Task> tasksRunning;
        private readonly Queue<Action> tasksWaiting;
        private readonly ConcurrentQueue<Action> actions;
        private readonly Action<List<KnownException>, AggregateException> errorCallback;

        public TaskPool(Action<List<KnownException>, AggregateException> errorCallback) : base(true, true)
        {
            this.errorCallback = errorCallback;

            tasksRunning = new List<Task>();
            actions = new ConcurrentQueue<Action>();
            tasksWaiting = new Queue<Action>();
        }

        public override void Close()
        {
            tasksRunningCount = 0;
        }

        /// <summary>
        /// Updates public task/action queues and runs exception handling.
        /// </summary>
        public override void Draw()
        {
            TryStartWaitingTasks();
            UpdateRunningTasks();
            RunTaskActions();
        }

        /// <summary>
        /// Enqueues an action to run in parallel. Not thread safe; must be called from the main thread.
        /// </summary>
        public void EnqueueTask(Action action)
        {
            if (Parent == null && RichHudCore.Instance != null)
                RegisterComponent(RichHudCore.Instance);
            else if (ExceptionHandler.Unloading)
                throw new Exception("New tasks cannot be started while the mod is being unloaded.");

            tasksWaiting.Enqueue(action);
        }

        /// <summary>
        /// Enqueues an action to run on the main thread. Meant to be used by threads other than the main.
        /// </summary>
        public void EnqueueAction(Action action)
        {
            if (Parent == null && RichHudCore.Instance != null)
                RegisterComponent(RichHudCore.Instance);
            else if (ExceptionHandler.Unloading)
                throw new Exception("New tasks cannot be started while the mod is being unloaded.");

            actions.Enqueue(action);
        }

        /// <summary>
        /// Attempts to start any tasks in the waiting queue if the number of tasks running
        /// is below a set threshold.
        /// </summary>
        private void TryStartWaitingTasks()
        {
            Action action;

            while (tasksRunningCount < maxTasksRunning && (tasksWaiting.Count > 0) && tasksWaiting.TryDequeue(out action))
            {
                tasksRunning.Add(MyAPIGateway.Parallel.Start(action));
                tasksRunningCount++;
            }
        }

        /// <summary>
        /// Checks the task list for invalid tasks and tasks with exceptions then logs and throws exceptions as needed.
        /// </summary>
        private void UpdateRunningTasks()
        {
            List<KnownException> knownExceptions = new List<KnownException>();
            List<Exception> otherExceptions = new List<Exception>(); //unknown exceptions
            AggregateException unknownExceptions = null;

            for (int n = 0; n < tasksRunning.Count; n++)
            {
                Task task = tasksRunning[n];

                if (task.Exceptions != null && task.Exceptions.Length > 0)
                {
                    foreach (Exception exception in task.Exceptions)
                    {
                        if (exception is KnownException)
                            knownExceptions.Add((KnownException)exception);
                        else
                            otherExceptions.Add(exception);
                    }
                }

                if (!task.valid || task.IsComplete || (task.Exceptions != null && task.Exceptions.Length > 0))
                {
                    tasksRunning.Remove(task);
                    tasksRunningCount--;
                }
            }

            if (otherExceptions.Count > 0)
                unknownExceptions = new AggregateException(otherExceptions);

            errorCallback(knownExceptions, unknownExceptions);
        }

        /// <summary>
        /// Checks actions queue for any actions sent from tasks to be executed on the main 
        /// thread and executes them.
        /// </summary>
        private void RunTaskActions()
        {
            Action action;

            while (actions.Count > 0)
                if (actions.TryDequeue(out action))
                    action();
        }
    }
}﻿using System.Collections.Generic;
using VRageMath;

namespace RichHudFramework
{
    public static class CollectionExtensions
    {
        /// <summary>
        /// Generates subarray that starts from a given index and continues to the end.
        /// </summary>
        public static T[] GetSubarray<T>(this T[] arr, int start)
        {
            T[] trimmed = new T[arr.Length - start];

            for (int n = start; n < arr.Length; n++)
                trimmed[n - start] = arr[n];

            return trimmed;
        }

        /// <summary>
        /// Generates subarray that starts from a given index and continues to the end.
        /// </summary>
        public static T[] GetSubarray<T>(this T[] arr, int start, int end)
        {
            T[] trimmed;

            end = MathHelper.Clamp(end, 0, arr.Length);
            trimmed = new T[end - start];

            for (int n = start; n < end; n++)
                trimmed[n - start] = arr[n];

            return trimmed;
        }

        /// <summary>
        /// Returns an array containing only unique entries from the collection.
        /// </summary>
        public static T[] GetUnique<T>(this IReadOnlyList<T> original)
        {
            var unique = new List<T>(original.Count);

            foreach (T item in original)
            {
                if (!unique.Contains(item))
                    unique.Add(item);
            }

            return unique.ToArray();
        }
    }
}
﻿using System;

namespace RichHudFramework
{
    public static class MathExtensions
    {
        /// <summary>
        /// Rounds a double-precision floating-point value to a specified number of fractional 
        /// digits, and rounds midpoint values to the nearest even number.
        /// </summary>
        public static double Round(this double value, int digits = 0) =>
            Math.Round(value, digits);

        /// <summary>
        /// Rounds a single-precision floating-point value to a specified number of fractional 
        /// digits, and rounds midpoint values to the nearest even number.
        /// </summary>
        public static float Round(this float value, int digits = 0) =>
            (float)Math.Round(value, digits);

        /// <summary>
        /// Returns the absolute value of a single-precision floating-point number.
        /// </summary>
        public static float Abs(this float value) =>
            Math.Abs(value);

        /// <summary>
        /// Converts a floating point value given in radians to an fp value in degrees.
        /// </summary>
        public static float RadiansToDegrees(this float value) =>
            (value / (float)Math.PI) * 180f;

        /// <summary>
        /// Converts a floating point value given in degrees to an fp value in radians.
        /// </summary>
        public static float DegreesToRadians(this float value) =>
            (value * (float)Math.PI) / 180f;
    }
}
﻿using VRageMath;

namespace RichHudFramework
{
    public static class VectorExtensions
    {
        /// <summary>
        /// Converts a <see cref="Vector2"/> to a <see cref="Vector2D"/>
        /// </summary>
        public static Vector2D ToDouble(this Vector2 vec) =>
            new Vector2D(vec.X, vec.Y);

        /// <summary>
        /// Converts a <see cref="Vector2D"/> to a <see cref="Vector2"/>
        /// </summary>
        public static Vector2 ToSingle(this Vector2D vec) =>
            new Vector2((float)vec.X, (float)vec.Y);

        /// <summary>
        /// Calculates the alpha of the color based on a float value between 0 and 1 and returns the new color.
        /// </summary>
        public static Color SetAlphaPct(this Color color, float alphaPercent) =>
            new Color(color.R, color.G, color.B, (byte)(alphaPercent * 255f));

        /// <summary>
        /// Retrieves the channel of a given <see cref="Color"/> by its index. R = 0, G = 1, B = 2, A = 3.
        /// </summary>
        public static byte GetChannel(this Color color, int channel)
        {
            switch (channel)
            {
                case 0:
                    return color.R;
                case 1:
                    return color.G;
                case 2:
                    return color.B;
                case 3:
                    return color.A;
            }

            return 0;
        }

        /// <summary>
        /// Sets the channel of a given <see cref="Color"/> by its index to the given value. R = 0, G = 1, B = 2, A = 3.
        /// </summary>
        public static Color SetChannel(this Color color, int channel, byte value)
        {
            switch(channel)
            {
                case 0:
                    color.R = value;
                    break;
                case 1:
                    color.G = value;
                    break;
                case 2:
                    color.B = value;
                    break;
                case 3:
                    color.A = value;
                    break;
            }

            return color;
        }
    }
}
﻿using System.Collections.Generic;
using VRage;

namespace RichHudFramework
{
    /// <summary>
    /// Pool policy for use with generic lists.
    /// </summary>
    public class ListPoolPolicy<T> : IPooledObjectPolicy<List<T>>
    {
        public List<T> GetNewObject()
        {
            return new List<T>();
        }

        public void ResetObject(List<T> list)
        {
            list.Clear();
        }

        public void ResetRange(IReadOnlyList<List<T>> lists, int index, int count)
        {
            for (int i = 0; (i < count && (index + i) < lists.Count); i++)
                lists[index + i].Clear();
        }

        public void ResetRange<T2>(IReadOnlyList<MyTuple<List<T>, T2>> lists, int index, int count)
        {
            for (int i = 0; (i < count && (index + i) < lists.Count); i++)
                lists[index + i].Item1.Clear();
        }

        /// <summary>
        /// Returns a new <see cref="ObjectPool{T}"/> using <see cref="ListPoolPolicy{T}"/>
        /// </summary>
        public static ObjectPool<List<T>> GetNewPool()
        {
            return new ObjectPool<List<T>>(new ListPoolPolicy<T>());
        }
    }
}﻿using System.Collections.Generic;
using VRage;
using System.Text;

namespace RichHudFramework
{
    /// <summary>
    /// Pool policy for use with <see cref="StringBuilder"/>
    /// </summary>
    public class StringBuilderPoolPolicy : IPooledObjectPolicy<StringBuilder>
    {
        public StringBuilder GetNewObject()
        {
            return new StringBuilder();
        }

        public void ResetObject(StringBuilder obj)
        {
            obj.Clear();
        }

        public void ResetRange(IReadOnlyList<StringBuilder> objects, int index, int count)
        {
            for (int n = 0; (n < count && (index + n) < objects.Count); n++)
            {
                objects[index + n].Clear();
            }
        }

        public void ResetRange<T2>(IReadOnlyList<MyTuple<StringBuilder, T2>> objects, int index, int count)
        {
            for (int n = 0; (n < count && (index + n) < objects.Count); n++)
            {
                objects[index + n].Item1.Clear();
            }
        }

        /// <summary>
        /// Returns a new <see cref="ObjectPool{T}"/> using <see cref="StringBuilderPoolPolicy"/>
        /// </summary>
        public static ObjectPool<StringBuilder> GetNewPool()
        {
            return new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());
        }
    }
}﻿using System;
using System.Text.RegularExpressions;

namespace RichHudFramework
{
    public static partial class Utils
    {
        public static class Color
        {
            private static readonly Regex colorParser = new Regex(@"(\s*,?(\d{1,3})\s*,?){3,4}");

            /// <summary>
            /// Determines whether a string can be parsed into a <see cref="VRageMath.Color"/> and returns true if so.
            /// </summary>
            public static bool CanParseColor(string colorData)
            {
                Match match = colorParser.Match(colorData);
                CaptureCollection captures = match.Groups[2].Captures;
                byte r, g, b, a;

                if (captures.Count > 2)
                {
                    if (!byte.TryParse(captures[0].Value, out r))
                        return false;

                    if (!byte.TryParse(captures[1].Value, out g))
                        return false;

                    if (!byte.TryParse(captures[2].Value, out b))
                        return false;

                    if (captures.Count > 3)
                    {
                        if (!byte.TryParse(captures[3].Value, out a))
                            return false;
                    }

                    return true;
                }
                else
                    return false;
            }

            /// <summary>
            /// Tries to convert a string of color values to its <see cref="VRageMath.Color"/> equivalent.
            /// </summary>
            public static bool TryParseColor(string colorData, out VRageMath.Color value, bool ignoreAlpha = false)
            {
                bool successful;

                try
                {
                    value = ParseColor(colorData, ignoreAlpha);
                    successful = true;
                }
                catch
                {
                    value = VRageMath.Color.White;
                    successful = false;
                }

                return successful;
            }

            /// <summary>
            /// Converts a string of color values to its <see cref="VRageMath.Color"/> equivalent.
            /// </summary>
            public static VRageMath.Color ParseColor(string colorData, bool ignoreAlpha = false)
            {
                Match match = colorParser.Match(colorData);
                CaptureCollection captures = match.Groups[2].Captures;
                VRageMath.Color value = new VRageMath.Color();

                if (captures.Count > 2)
                {
                    value.R = byte.Parse(captures[0].Value);
                    value.G = byte.Parse(captures[1].Value);
                    value.B = byte.Parse(captures[2].Value);

                    if (captures.Count > 3 || ignoreAlpha)
                        value.A = byte.Parse(captures[3].Value);
                    else
                        value.A = 255;

                    return value;
                }
                else
                    throw new Exception("Color string must contain at least 3 values.");
            }

            public static string GetColorString(VRageMath.Color color, bool includeAlpha = true)
            {
                if (includeAlpha)
                    return $"{color.R},{color.G},{color.B},{color.A}";
                else
                    return $"{color.R},{color.G},{color.B}";
            }
        }
    }
}
﻿using System;

namespace RichHudFramework
{
    public static partial class Utils
    {
        public static class Debug
        {
            public static void AssertNotNull<T>(T obj, string message = "")
            {
                Assert(obj != null, $"Object of type {typeof(T).ToString()} is null. " + message);
            }

            public static void Assert(bool condition, string message = "")
            {
                if (!condition)
                    throw new Exception("Assertion failed. " + message);
            }
        }
    }
}
﻿using Sandbox.ModAPI;
using System;

namespace RichHudFramework
{
    public static partial class Utils
    {
        public static class ProtoBuf
        {
            /// <summary>
            /// Attempts to serialize an object to a byte array.
            /// </summary>
            public static KnownException TrySerialize<T>(T obj, out byte[] dataOut)
            {
                KnownException exception = null;
                dataOut = null;

                try
                {
                    dataOut = MyAPIGateway.Utilities.SerializeToBinary(obj);
                }
                catch (Exception e)
                {
                    exception = new KnownException($"IO Error. Failed to generate binary from {typeof(T).Name}.", e);
                }

                return exception;
            }

            /// <summary>
            /// Attempts to deserialize an a byte array to an object of a given type.
            /// </summary>
            public static KnownException TryDeserialize<T>(byte[] dataIn, out T obj)
            {
                KnownException exception = null;
                obj = default(T);

                try
                {
                    obj = MyAPIGateway.Utilities.SerializeFromBinary<T>(dataIn);
                }
                catch (Exception e)
                {
                    exception = new KnownException($"IO Error. Failed to deserialize to {typeof(T).Name}.", e);
                }

                return exception;
            }
        }
    }
}
﻿using Sandbox.ModAPI;
using System;

namespace RichHudFramework
{
    public static partial class Utils
    {
        public static class Xml
        {
            /// <summary>
            /// Attempts to serialize an object to an Xml string.
            /// </summary>
            public static KnownException TrySerialize<T>(T obj, out string xmlOut)
            {
                KnownException exception = null;
                xmlOut = null;

                try
                {
                    xmlOut = MyAPIGateway.Utilities.SerializeToXML(obj);
                }
                catch (Exception e)
                {
                    exception = new KnownException("IO Error. Failed to generate XML.", e);
                }

                return exception;
            }

            /// <summary>
            /// Attempts to deserialize an Xml string to an object of a given type.
            /// </summary>
            public static KnownException TryDeserialize<T>(string xmlIn, out T obj)
            {
                KnownException exception = null;
                obj = default(T);

                try
                {
                    obj = MyAPIGateway.Utilities.SerializeFromXML<T>(xmlIn);
                }
                catch (Exception e)
                {
                    exception = new KnownException("IO Error. Unable to interpret XML.", e);
                }

                return exception;
            }
        }
    }
}
﻿using RichHudFramework.IO;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRage.Game;
using VRage.Utils;

namespace RichHudFramework.Internal
{
    /// <summary>
    /// Handles exceptions for session components extending from ModBase.
    /// </summary>
    [MySessionComponentDescriptor(MyUpdateOrder.NoUpdate)]
    public sealed class ExceptionHandler : MySessionComponentBase
    {
        /// <summary>
        /// Sets the mod name to be used in chat messages, popups and anything else that might require it.
        /// </summary>
        public static string ModName { get; set; }

        /// <summary>
        /// The maximum number of times the mod will be allowed to reload as a result of an unhandled exception.
        /// </summary>
        public static int RecoveryLimit { get; set; }

        /// <summary>
        /// The number of times the handler has reloaded its clients in response to unhandled exceptions.
        /// </summary>
        public static int RecoveryAttempts { get; private set; }

        /// <summary>
        /// If set to true, the user will be given the option to reload in the event of an
        /// unhandled exception.
        /// </summary>
        public static bool PromptForReload { get; set; }

        /// <summary>
        /// True if the handler is currently in the process of reloading its clients.
        /// </summary>
        public static bool Reloading { get; private set; }

        /// <summary>
        /// True if the handler is currently in the process of unloading its clients.
        /// </summary>
        public static bool Unloading { get; private set; }

        /// <summary>
        /// If true, the mod is currently running on a client.
        /// </summary>
        public static bool IsClient { get; private set; }

        /// <summary>
        /// If true, the mod is currently running on a server.
        /// </summary>
        public static bool IsServer { get; private set; }

        /// <summary>
        /// If true, the mod is currently running on a dedicated server.
        /// </summary>
        public static bool IsDedicated { get; private set; }

        /// <summary>
        /// If true, then clients will not be updated (draw/sim/input).
        /// </summary>
        public static bool ClientsPaused { get; private set; }

        /// <summary>
        /// If enabled, then debug messages will appear in the SE log.
        /// </summary>
        public static bool DebugLogging { get; set; }

        private static ExceptionHandler instance;
        private const long exceptionReportInterval = 100, exceptionLoopTime = 50;
        private const int exceptionLoopCount = 10;

        private int exceptionCount;
        private readonly List<ModBase> clients;
        private readonly List<string> exceptionMessages;
        private readonly Stopwatch errorTimer;

        private Action lastMissionScreen;

        public ExceptionHandler()
        {
            if (instance == null)
                instance = this;
            else
                throw new Exception("Only one instance of ExceptionHandler can exist at any given time.");

            ModName = DebugName;
            RecoveryLimit = 1;

            exceptionMessages = new List<string>();
            errorTimer = new Stopwatch();
            clients = new List<ModBase>();
        }

        public override void LoadData()
        {
            IsDedicated = MyAPIGateway.Utilities.IsDedicated;
            IsServer = MyAPIGateway.Session.OnlineMode == MyOnlineModeEnum.OFFLINE || MyAPIGateway.Multiplayer.IsServer || IsDedicated;
            IsClient = !IsDedicated;

            WriteToLogAndConsole($"Exception Handler Init. Dedicated: {IsDedicated}, IsServer: {IsServer}, IsClient: {IsClient}", true);
        }

        /// <summary>
        /// Registers the <see cref="ModBase"/> with the handler if it isn't already registered.
        /// </summary>
        public static void RegisterClient(ModBase client)
        {
            if (!instance.clients.Contains(client))
            {
                instance.clients.Add(client);
                WriteToLog($"[{client.GetType().Name}] Session component registered.", true);
            }
        }

        public override void Draw()
        {
            if (errorTimer.ElapsedMilliseconds > exceptionReportInterval)
                HandleExceptions();

            // This is a workaround. If you try to create a mission screen while the chat is open, 
            // the UI will become unresponsive.
            if (lastMissionScreen != null && !MyAPIGateway.Gui.ChatEntryVisible)
            {
                lastMissionScreen();
                lastMissionScreen = null;
            }

            if (Reloading)
                FinishReload();
        }

        /// <summary>
        /// Executes a given <see cref="Action"/> in a try-catch block. If an exception occurs, it will attempt
        /// to log it, display an error message to the user and reload or unload the mod depending on the configuration.
        /// </summary>
        public static void Run(Action Action)
        {
            try
            {
                Action();
            }
            catch (Exception e)
            {
                if (instance != null)
                    instance.ReportExceptionInternal(e);
                else
                    WriteToLog("Mod encountered an unhandled exception.\n" + e.ToString() + '\n');
            }
        }

        /// <summary>
        /// Executes a given <see cref="Func{TResult}"/> in a try-catch block. If an exception occurs, it will attempt
        /// to log it, display an error message to the user and reload or unload the mod depending on the configuration.
        /// </summary>
        public static TResult Run<TResult>(Func<TResult> Func)
        {
            TResult value = default(TResult);

            try
            {
                value = Func();
            }
            catch (Exception e)
            {
                if (instance != null)
                    instance.ReportExceptionInternal(e);
                else
                    WriteToLog("Mod encountered an unhandled exception.\n" + e.ToString() + '\n');
            }

            return value;
        }

        /// <summary>
        /// Records exceptions to be handled. Duplicate stack traces are excluded from the log entry.
        /// </summary>
        public static void ReportException(Exception e) =>
            instance.ReportExceptionInternal(e);

        /// <summary>
        /// Records exceptions to be handled. Duplicate stack traces are excluded from the log entry.
        /// </summary>
        private void ReportExceptionInternal(Exception e)
        {
            if (e == null)
                e = new Exception("Null exception reported.");

            lock (exceptionMessages)
            {
                string message = e.ToString();

                if (!exceptionMessages.Contains(message))
                    exceptionMessages.Add(message);

                if (exceptionCount == 0)
                    errorTimer.Restart();

                exceptionCount++;

                // Exception loop, respond immediately
                if (exceptionCount > exceptionLoopCount && errorTimer.ElapsedMilliseconds < exceptionLoopTime)
                    PauseClients();
            }
        }

        /// <summary>
        /// Generates an single log entry from the stack traces recorded within the logging interval
        /// and reloads or unloads the clients depending on the handler's current configuration and
        /// the number of recovery attempts.
        /// </summary>
        private void HandleExceptions()
        {
            if (exceptionCount > 0)
            {
                string exceptionText = GetExceptionText();
                exceptionCount = 0;

                WriteToLog("Mod encountered an unhandled exception.\n" + exceptionText + '\n');
                exceptionMessages.Clear();

                if (!Unloading && !Reloading)
                {
                    if (IsClient && PromptForReload)
                    {
                        if (RecoveryAttempts < RecoveryLimit)
                        {
                            PauseClients();
                            ShowErrorPrompt(exceptionText, true);
                        }
                        else
                        {
                            UnloadClients();
                            ShowErrorPrompt(exceptionText, false);
                        }
                    }
                    else
                    {
                        if (RecoveryAttempts < RecoveryLimit)
                            StartReload();
                        else
                            UnloadClients();
                    }

                    RecoveryAttempts++;
                }
            }
        }

        /// <summary>
        /// Generates final exception text from the list of messages recorded.
        /// </summary>
        private string GetExceptionText()
        {
            StringBuilder errorMessage = new StringBuilder();

            if (exceptionCount > exceptionLoopCount && errorTimer.ElapsedMilliseconds < exceptionLoopTime)
                errorMessage.AppendLine($"[Exception Loop Detected] {exceptionCount} exceptions were reported within a span of {errorTimer.ElapsedMilliseconds}ms.");

            for (int n = 0; n < exceptionMessages.Count - 1; n++)
                errorMessage.AppendLine(exceptionMessages[n]);

            errorMessage.Append(exceptionMessages[exceptionMessages.Count - 1]);

            errorMessage.Replace("--->", "\n   --->");
            return errorMessage.ToString();
        }

        /// <summary>
        /// If canReload == true, the user will be prompted to choose to either reload or cancel reload.
        /// If canReload == false, it will still show the user the error message, but wont give them an option
        /// to reload.
        /// </summary>
        private void ShowErrorPrompt(string errorMessage, bool canReload)
        {
            if (canReload)
            {
                ShowMissionScreen
                (
                    "Debug",
                    $"{ModName} has encountered a problem and will need to reload. Press the X in the upper right hand corner " +
                    "to cancel.\n\n" +
                    "Error Details:\n" +
                    errorMessage,
                    AllowReload,
                    "Reload"
                );
            }
            else
            {
                ShowMissionScreen
                (
                    "Debug",
                    $"{ModName} has encountered an error and was unable to recover.\n\n" +
                    "Error Details:\n" +
                    errorMessage,
                    null,
                    "Close"
                );

                SendChatMessage($"{ModName} has encountered an error and was unable to recover. See log for details.");
            }
        }

        /// <summary>
        /// Error prompt callback. If reload is clicked, it will unpause the clients and reload. Otherwise, the
        /// clients will unload.
        /// </summary>
        private void AllowReload(ResultEnum response)
        {
            if (response == ResultEnum.OK)
                StartReload();
            else
                UnloadClients();
        }

        public static void ReloadClients() =>
            instance.StartReload();

        /// <summary>
        /// Creates a message window using the mod name, a given subheading and a message.
        /// </summary>
        public static void ShowMissionScreen(string subHeading = null, string message = null, Action<ResultEnum> callback = null, string okButtonCaption = null)
        {
            Action messageAction = () => MyAPIGateway.Utilities.ShowMissionScreen(ModName, subHeading, null, message, callback, okButtonCaption);
            instance.lastMissionScreen = messageAction;
        }

        /// <summary>
        /// Creates a message window using the mod name, a given subheading and a message.
        /// </summary>
        public static void ShowMessageScreen(string subHeading, string message) =>
            ShowMissionScreen(subHeading, message, null, "Close");

        /// <summary>
        /// Sends chat message using the mod name as the sender.
        /// </summary>
        public static void SendChatMessage(string message)
        {
            if (!IsDedicated)
            {
                try
                {
                    MyAPIGateway.Utilities.ShowMessage(ModName, message);
                }
                catch { }
            }
        }

        /// <summary>
        /// Writes text to SE log with the mod name prepended to it.
        /// </summary>
        public static void WriteToLog(string message, bool debugOnly = false)
        {
            if (!(debugOnly && !DebugLogging))
            {
                try
                {
                    MyLog.Default.WriteLine($"[{ModName}] {message}");
                }
                catch { }
            }
        }

        /// <summary>
        /// Writes text to SE console with mod name prepended to it.
        /// </summary>
        public static void WriteToConsole(string message, bool debugOnly = false)
        {
            if (!(debugOnly && !DebugLogging))
            {
                try
                {
                    MyLog.Default.WriteLineToConsole($"[{ModName}] {message}");
                }
                catch { }
            }
        }

        /// <summary>
        /// Writes text to SE log with the mod name prepended to it.
        /// </summary>
        public static void WriteToLogAndConsole(string message, bool debugOnly = false)
        {
            if (!(debugOnly && !DebugLogging))
            {
                try
                {
                    MyLog.Default.WriteLineAndConsole($"[{ModName}] {message}");
                }
                catch { }
            }
        }

        /// <summary>
        /// Stops clients from updating
        /// </summary>
        private void PauseClients()
        {
            for (int n = 0; n < clients.Count; n++)
                clients[n].CanUpdate = false;

            ClientsPaused = true;
        }

        /// <summary>
        /// Allows clients to resume updating
        /// </summary>
        private void UnpauseClients()
        {
            for (int n = 0; n < clients.Count; n++)
                clients[n].CanUpdate = true;

            ClientsPaused = false;
        }

        /// <summary>
        /// Closes all clients in preparation for reload
        /// </summary>
        private void StartReload()
        {
            if (!Reloading)
            {
                WriteToLog("Reloading mod...");
                Reloading = true;

                CloseClients();
            }
        }

        /// <summary>
        /// Restarts clients after reload start
        /// </summary>
        private void FinishReload()
        {
            if (Reloading)
            {
                for (int n = 0; n < clients.Count; n++)
                {
                    bool success = true;
                    string typeName = clients[n].GetType().Name;

                    Run(() => 
                    {
                        WriteToLog($"[{typeName}] Restarting session component...", true);
                        clients[n].ManualStart();
                        success = clients[n].Loaded;
                    });

                    if (success)
                        WriteToLog($"[{typeName}] Session component started.", true);
                    else
                        WriteToLog($"[{typeName}] Failed to start session component.");
                }

                Reloading = false;
                ClientsPaused = false;
                WriteToLog("Mod reloaded.");
            }
        }

        /// <summary>
        /// Unloads all registered clients
        /// </summary>
        private void UnloadClients()
        {
            if (!Unloading)
            {
                WriteToLog("Unloading mod...");
                Unloading = true;
                Reloading = false;

                CloseClients();
            }

            WriteToLog("Mod unloaded.");
        }

        private void CloseClients()
        {
            for (int n = 0; n < clients.Count; n++)
            {
                bool success = false;
                string typeName = clients[n].GetType().Name;
                WriteToLog($"[{typeName}] Stopping session component...", true);

                Run(() =>
                {
                    if (clients[n].CanUpdate)
                        clients[n].BeforeClose();

                    success = true;
                });

                clients[n].CanUpdate = false;

                if (success)
                    WriteToLog($"[{typeName}] Session component stopped.", true);
                else
                    WriteToLog($"[{typeName}] Failed to stop session component.");
            }

            ClientsPaused = true;

            for (int n = 0; n < clients.Count; n++)
            {
                bool success = false;
                string typeName = clients[n].GetType().Name;
                WriteToLog($"[{typeName}] Closing session component...", true);

                Run(() =>
                {
                    clients[n].Close();
                    success = true;
                });

                if (success)
                    WriteToLog($"[{typeName}] Session component closed.", true);
                else
                    WriteToLog($"[{typeName}] Failed to close session component.");
            }
        }

        protected override void UnloadData()
        {
            UnloadClients();
            HandleExceptions();
            instance = null;

            WriteToLog("Exception Handler unloaded.", true);
        }
    }
}
﻿using RichHudFramework.IO;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using VRage.Game;
using VRage.Game.Components;
using VRage.Game.ModAPI;

namespace RichHudFramework.Internal
{
    /// <summary>
    /// Extends <see cref="MySessionComponentBase"/> to include built-in exception handling, logging and a component
    /// system.
    /// </summary>
    public abstract partial class ModBase : MySessionComponentBase
    {
        /// <summary>
        /// Determines whether or not the main class will be allowed to run on a dedicated server.
        /// </summary>
        public bool RunOnServer { get; }

        /// <summary>
        /// If true, then the mod will be allowed to run on a client.
        /// </summary>
        public bool RunOnClient { get; }

        /// <summary>
        /// If true, the mod is currently loaded.
        /// </summary>
        public new bool Loaded { get; private set; }

        /// <summary>
        /// If true, then the session component will be allowed to update.
        /// </summary>
        public bool CanUpdate
        {
            get { return _canUpdate && ((RunOnClient && ExceptionHandler.IsClient) || (RunOnServer && ExceptionHandler.IsDedicated)); }
            set { _canUpdate = value; }
        }

        private readonly List<ModuleBase> modules;
        private bool _canUpdate, closing;

        protected ModBase(bool runOnServer, bool runOnClient)
        {
            modules = new List<ModuleBase>();
            RunOnServer = runOnServer;
            RunOnClient = runOnClient;
        }

        public sealed override void LoadData()
        {
            if (!Loaded && !ExceptionHandler.Unloading && !closing)
            {
                CanUpdate = true;
                ExceptionHandler.RegisterClient(this);

                if (CanUpdate)
                    AfterLoadData();
            }
        }

        protected new virtual void AfterLoadData() { }

        public sealed override void Init(MyObjectBuilder_SessionComponent sessionComponent)
        {
            if (!Loaded && !ExceptionHandler.Unloading && !closing)
            {
                if (CanUpdate)
                    AfterInit();

                Loaded = true;
            }
        }

        protected virtual void AfterInit() { }

        public void ManualStart()
        {
            if (!Loaded && !ExceptionHandler.Unloading && !closing)
            {
                LoadData();
                Init(null);
            }
        }

        public override void Draw()
        {
            if (Loaded && CanUpdate)
            {
                ExceptionHandler.Run(() =>
                {
                    for (int n = 0; n < modules.Count; n++)
                    {
                        bool updateClient = modules[n].runOnClient && ExceptionHandler.IsClient,
                            updateServer = modules[n].runOnServer && ExceptionHandler.IsDedicated;

                        if (updateClient || updateServer)
                            modules[n].Draw();
                    }
                });
            }
        }

        public override void HandleInput()
        {
            if (Loaded && CanUpdate)
            {
                ExceptionHandler.Run(() =>
                {
                    for (int n = 0; n < modules.Count; n++)
                    {
                        bool updateClient = modules[n].runOnClient && ExceptionHandler.IsClient,
                            updateServer = modules[n].runOnServer && ExceptionHandler.IsDedicated;

                        if (updateClient || updateServer)
                            modules[n].HandleInput();
                    }
                });
            }
        }

        public sealed override void UpdateBeforeSimulation() =>
            BeforeUpdate();

        public sealed override void Simulate() =>
            BeforeUpdate();

        public sealed override void UpdateAfterSimulation() =>
            BeforeUpdate();

        /// <summary>
        /// The update function used (Before/Sim/After) is determined by the settings used by
        /// the MySessionComponentDescriptorAttribute applied to the child class.
        /// </summary>
        protected virtual void BeforeUpdate()
        {
            if (Loaded && CanUpdate)
            {
                ExceptionHandler.Run(() =>
                {
                    for (int n = 0; n < modules.Count; n++)
                    {
                        bool updateClient = modules[n].runOnClient && ExceptionHandler.IsClient,
                            updateServer = modules[n].runOnServer && ExceptionHandler.IsDedicated;

                        if (updateClient || updateServer)
                            modules[n].Update();
                    }

                    Update();
                });
            }
        }

        /// <summary>
        /// Sim update.
        /// </summary>
        protected virtual void Update() { }

        /// <summary>
        /// Called before close used to stop, clean up and save before other components
        /// start to unload.
        /// </summary>
        public virtual void BeforeClose() { }

        /// <summary>
        /// Called for final cleanup. Other components may have already unloaded by this point.
        /// </summary>
        public virtual void Close()
        {
            if (!closing)
            {
                Loaded = false;
                CanUpdate = false;
                closing = true;

                CloseModules();
                modules.Clear();

                closing = false;
            }
        }

        private void CloseModules()
        {
            string typeName = GetType().Name;

            for (int n = modules.Count - 1; n >= 0; n--)
            {
                var module = modules[n];
                bool success = false;

                ExceptionHandler.Run(() =>
                {
                    ExceptionHandler.WriteToLog($"[{typeName}] Closing {module.GetType().Name} module...", true);
                    module.Close();
                    success = true;
                });

                if (success)
                    ExceptionHandler.WriteToLog($"[{typeName}] Closed {module.GetType().Name} module.", true);
                else
                    ExceptionHandler.WriteToLog($"[{typeName}] Failed to close {module.GetType().Name} module.");

                module.UnregisterComponent(n);
            }
        }

        protected override void UnloadData()
        { }

        /// <summary>
        /// Base class for ModBase components.
        /// </summary>
        public abstract class ModuleBase
        {
            protected ModBase Parent { get; private set; }

            /// <summary>
            /// Determines whether or not this component will run on a dedicated server and/or client.
            /// </summary>
            public readonly bool runOnServer, runOnClient;

            protected ModuleBase(bool runOnServer, bool runOnClient, ModBase parent)
            {
                this.runOnServer = runOnServer;
                this.runOnClient = runOnClient;

                RegisterComponent(parent);
            }

            public void RegisterComponent(ModBase parent)
            {
                if (Parent == null)
                {
                    parent.modules.Add(this);

                    Parent = parent;
                    ExceptionHandler.WriteToLog($"[{Parent.GetType().Name}] Registered {GetType().Name} module.", true);
                }
            }

            /// <summary>
            /// Used to manually remove object from update queue. This should only be used for objects that
            /// need to be closed while the mod is running.
            /// </summary>
            public void UnregisterComponent()
            {
                if (Parent != null)
                {
                    Parent.modules.Remove(this);

                    ExceptionHandler.WriteToLog($"[{Parent.GetType().Name}] Unregistered {GetType().Name} module.", true);
                    Parent = null;
                }
            }

            /// <summary>
            /// Used to manually remove object from update queue. This should only be used for objects that
            /// need to be closed while the mod is running.
            /// </summary>
            public void UnregisterComponent(int index)
            {
                if (Parent != null && index < Parent.modules.Count && Parent.modules[index] == this)
                {
                    Parent.modules.RemoveAt(index);

                    ExceptionHandler.WriteToLog($"[{Parent.GetType().Name}] Unregistered {GetType().Name} module.", true);
                    Parent = null;
                }
            }

            public virtual void Draw() { }

            public virtual void HandleInput() { }

            public virtual void Update() { }

            public virtual void Close() { }
        }

        /// <summary>
        /// Extension of <see cref="ModuleBase"/> that includes a task pool.
        /// </summary>
        public abstract class ParallelModuleBase : ModuleBase
        {
            private readonly TaskPool taskPool;

            protected ParallelModuleBase(bool runOnServer, bool runOnClient, ModBase parent) : base(runOnServer, runOnClient, parent)
            {
                taskPool = new TaskPool(ErrorCallback);
            }

            /// <summary>
            /// Called in the event an exception occurs in one of the component's tasks with a list of <see cref="KnownException"/>s
            /// and a single aggregate exception of all other exceptions.
            /// </summary>
            protected virtual void ErrorCallback(List<KnownException> knownExceptions, AggregateException aggregate)
            {
                if (knownExceptions.Count > 0)
                    ExceptionHandler.ReportException(new AggregateException(knownExceptions));

                if (aggregate != null)
                    ExceptionHandler.ReportException(aggregate);
            }

            /// <summary>
            /// Enqueues an action to run in parallel. Not thread safe; must be called from the main thread.
            /// </summary>
            protected void EnqueueTask(Action action) =>
                taskPool.EnqueueTask(action);

            /// <summary>
            /// Enqueues an action to run on the main thread. Meant to be used by threads other than the main.
            /// </summary>
            protected void EnqueueAction(Action action) =>
                taskPool.EnqueueAction(action);
        }
    }
}
﻿using Sandbox.ModAPI;
using System;
using System.Diagnostics;
using VRage;
using VRage.Game.Components;
using VRage.Game.ModAPI;
using VRageMath;
using RichHudFramework.UI;

namespace RichHudFramework.Internal
{
    [MySessionComponentDescriptor(MyUpdateOrder.NoUpdate)]
    public sealed class RichHudCore : ModBase
    {
        public static RichHudCore Instance { get; private set; }

        /// <summary>
        /// Chat input event regestered later that the rest
        /// </summary>
        public static event MessageEnteredDel LateMessageEntered;

        private readonly Stopwatch handlerRegTimer;

        public RichHudCore() : base(false, true)
        {
            if (Instance == null)
                Instance = this;
            else
                throw new Exception("Only one instance of RichHudCore can exist at any given time.");

            handlerRegTimer = new Stopwatch();
        }

        public override void BeforeStart()
        {
            handlerRegTimer.Start();
        }

        private void MessageHandler(string message, ref bool sendToOthers)
        {
            LateMessageEntered?.Invoke(message, ref sendToOthers);
        }

        public override void Draw()
        {
            // It seems there's some kind of bug in the game's session component system that prevents the Before/Sim/After
            // update methods from being called on more than one component with the same fully qualified name, update order
            // and priority, but for some reason, Draw and HandleInput still work.
            //
            // It would be really nice if I didn't have to work around this issue like this, but here we are.         
            BeforeUpdate();
            base.Draw();

            // Because some people are just bad neighbors
            if (handlerRegTimer.IsRunning && handlerRegTimer.ElapsedMilliseconds > 10000)
            {
                MyAPIGateway.Utilities.MessageEntered += MessageHandler;
                handlerRegTimer.Stop();
            }
        }

        public override void Close()
        {
            base.Close();

            if (ExceptionHandler.Unloading)
            {
                MyAPIGateway.Utilities.MessageEntered -= MessageHandler;
                Instance = null;
            }
        }

        protected override void UnloadData()
        {
            LateMessageEntered = null;
        }
    }

    public abstract class RichHudComponentBase : ModBase.ModuleBase
    {
        public RichHudComponentBase(bool runOnServer, bool runOnClient) : base(runOnServer, runOnClient, RichHudCore.Instance)
        { }
    }

    public abstract class RichHudParallelComponentBase : ModBase.ParallelModuleBase
    {
        public RichHudParallelComponentBase(bool runOnServer, bool runOnClient) : base(runOnServer, runOnClient, RichHudCore.Instance)
        { }
    }
}﻿using Sandbox.ModAPI;
using System;
using System.IO;

namespace RichHudFramework.IO
{
    /// <summary>
    /// Handles basic file I/O operations in local storage. Will not allow multiple threads to operate on the same file object concurrently.
    /// </summary>
    public class LocalFileIO
    {
        public bool FileExists => MyAPIGateway.Utilities.FileExistsInLocalStorage(file, typeof(LocalFileIO));
        public readonly string file;
        private readonly object fileLock;

        public LocalFileIO(string file)
        {
            this.file = file;
            fileLock = new object();
        }

        /// <summary>
        /// Creates a local duplicate of a file with a given name.
        /// </summary>
        public KnownException TryDuplicate(string newName)
        {
            string data;
            KnownException exception = TryRead(out data);
            LocalFileIO newFile;

            if (exception == null && data != null)
            {
                newFile = new LocalFileIO(newName);
                exception = newFile.TryWrite(data);
            }

            return exception;
        }

        /// <summary>
        /// Attempts to append string to an existing local file.
        /// </summary>
        public KnownException TryAppend(string data)
        {
            string current;
            KnownException exception = TryRead(out current);

            if (exception == null && current != null)
            {
                current += data;
                exception = TryWrite(current);
            }
            else
                exception = TryWrite(data);

            return exception;
        }

        /// <summary>
        /// Attempts to retrieve the file data as a byte array. Requires data stream to begin with array size.
        /// </summary>
        public KnownException TryRead(out byte[] stream)
        {
            KnownException exception = null;
            BinaryReader reader = null;
            
            lock (fileLock)
            {
                try
                {
                    reader = MyAPIGateway.Utilities.ReadBinaryFileInLocalStorage(file, typeof(LocalFileIO));
                    stream = reader.ReadBytes(reader.ReadInt32());
                }
                catch (Exception e)
                {
                    stream = null;
                    exception = new KnownException($"IO Error. Unable to read from {file}.", e);
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }
            }

            return exception;
        }

        /// <summary>
        /// Attempts to retrieve the file data as a string.
        /// </summary>
        public KnownException TryRead(out string data)
        {
            KnownException exception = null;
            TextReader reader = null;
            data = null;

            lock (fileLock)
            {
                try
                {
                    reader = MyAPIGateway.Utilities.ReadFileInLocalStorage(file, typeof(LocalFileIO));
                    data = reader.ReadToEnd();
                }
                catch (Exception e)
                {
                    data = null;
                    exception = new KnownException($"IO Error. Unable to read from {file}.", e);
                }
                finally
                {
                    if (reader != null)
                        reader.Close();
                }
            }

            return exception;
        }

        /// <summary>
        /// Attempts to write a byte array to the file. Byte array size will be prepended to the data stream.
        /// </summary>
        public KnownException TryWrite(byte[] stream)
        {
            KnownException exception = null;
            BinaryWriter writer = null;

            lock (fileLock)
            {
                try
                {
                    writer = MyAPIGateway.Utilities.WriteBinaryFileInLocalStorage(file, typeof(LocalFileIO));
                    writer.Write(stream.Length);
                    writer.Write(stream);
                    writer.Flush();
                }
                catch (Exception e)
                {
                    exception = new KnownException($"IO Error. Unable to write to {file}.", e);
                }
                finally
                {
                    if (writer != null)
                        writer.Close();
                }
            }

            return exception;
        }

        /// <summary>
        /// Attempts to write a string to the file.
        /// </summary>
        public KnownException TryWrite(string data)
        {
            KnownException exception = null;
            TextWriter writer = null;

            lock (fileLock)
            {
                try
                {
                    writer = MyAPIGateway.Utilities.WriteFileInLocalStorage(file, typeof(LocalFileIO));
                    writer.Write(data);
                    writer.Flush();
                }
                catch (Exception e)
                {
                    exception = new KnownException($"IO Error. Unable to write to {file}.", e);
                }
                finally
                {
                    if (writer != null)
                        writer.Close();
                }
            }

            return exception;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using RichHudFramework.Internal;

namespace RichHudFramework.IO
{
    /// <summary>
    /// Handles logging to separate file in local storage
    /// </summary>
    public sealed class LogIO : RichHudParallelComponentBase
    {
        public static bool Accessible => Instance.accessible;
        public static string FileName 
        { 
            get { return _fileName; } 
            set 
            {
                if (value != _fileName)
                    Instance.logFile = new LocalFileIO(value);

                _fileName = value;
            }
        }

        private static LogIO Instance
        { 
            get 
            {
                if (_instance == null)
                    _instance = new LogIO();
                else if (_instance.Parent == null && RichHudCore.Instance != null)
                    _instance.RegisterComponent(RichHudCore.Instance);

                return _instance; 
            } 
            set { _instance = value; }
        }

        private static LogIO _instance;
        private static string _fileName;

        public bool accessible;
        private LocalFileIO logFile;

        private LogIO() : base(true, true)
        {
            accessible = true;
            _fileName = "modLog.txt";
            logFile = new LocalFileIO(_fileName);
        }

        protected override void ErrorCallback(List<KnownException> known, AggregateException unknown)
        {
            if ((known != null && known.Count > 0) || unknown != null)
            {
                WriteToLogFinish(false);

                if (known != null && known.Count > 0)
                    foreach (Exception e in known)
                        ExceptionHandler.SendChatMessage(e.Message);

                if (unknown != null)
                    throw unknown;
            }
        }

        public static bool TryWriteToLog(string message) =>
            Instance.TryWriteToLogInternal(message);

        public static void WriteToLogStart(string message) =>
            Instance.WriteToLogStartInternal(message);

        /// <summary>
        /// Attempts to synchronously update log with message and adds a time stamp.
        /// </summary>
        public bool TryWriteToLogInternal(string message)
        {
            if (accessible)
            {
                message = $"[{DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss:ms")}] {message}";
                KnownException exception = logFile.TryAppend(message);

                if (exception != null)
                {
                    ExceptionHandler.SendChatMessage("Unable to update log; please check your file access permissions.");
                    accessible = false;
                    throw exception;
                }
                else
                {
                    ExceptionHandler.SendChatMessage("Log updated.");
                    accessible = true;
                    return true;
                }
            }
            else
                return false;
        }

        /// <summary>
        /// Attempts to update log in parallel with message and adds a time stamp.
        /// </summary>
        public void WriteToLogStartInternal(string message)
        {
            if (accessible)
            {
                message = $"[{DateTime.Now.ToString("MM/dd/yyyy HH:mm:ss:ms")}] {message}";

                EnqueueTask(() =>
                {
                    KnownException exception = logFile.TryAppend(message);

                    if (exception != null)
                    {
                        EnqueueAction(() => WriteToLogFinish(false));
                        throw exception;
                    }
                    else
                        EnqueueAction(() => WriteToLogFinish(true));
                });
            }
        }

        private void WriteToLogFinish(bool success)
        {
            if (!success)
            {
                if (accessible)
                    ExceptionHandler.SendChatMessage("Unable to update log; please check your file access permissions.");

                accessible = false;
            }
            else
            {
                if (accessible)
                    ExceptionHandler.SendChatMessage("Log updated.");

                accessible = true;
            }
        }
    }
}﻿using RichHudFramework.Internal;
using Sandbox.ModAPI;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using VRage;
using VRage.Game;
using VRage.Game.Components;

namespace RichHudFramework.UI
{
    public interface ICommandGroup: IIndexedCollection<IChatCommand>
    {
        string Prefix { get; }

        bool TryAdd(string name, Action<string[]> callback = null, int argsRequired = 0);
        void AddCommands(CmdGroupInitializer newCommands);
    }

    public interface IChatCommand
    {
        event Action<string[]> CommandInvoked;

        string CmdName { get; }
        int ArgsRequired { get; }
    }

    public class CmdGroupInitializer : IReadOnlyList<MyTuple<string, Action<string[]>, int>>
    {
        public MyTuple<string, Action<string[]>, int> this[int index] => data[index];
        public int Count => data.Count;

        private readonly List<MyTuple<string, Action<string[]>, int>> data;

        public CmdGroupInitializer(int capacity = 0)
        {
            data = new List<MyTuple<string, Action<string[]>, int>>(capacity);
        }

        public void Add(string cmdName, Action<string[]> callback = null, int argsRequrired = 0)
        {
            data.Add(new MyTuple<string, Action<string[]>, int>(cmdName, callback, argsRequrired));
        }

        public IEnumerator<MyTuple<string, Action<string[]>, int>> GetEnumerator() =>
            data.GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() =>
            data.GetEnumerator();
    }

    /// <summary>
    /// Manages chat commands. Independent session component. Use only after load data.
    /// </summary>
    [MySessionComponentDescriptor(MyUpdateOrder.NoUpdate, 0)]
    public sealed class CmdManager : MySessionComponentBase
    {
        /// <summary>
        /// List of command groups registered;
        /// </summary>
        public static IReadOnlyList<ICommandGroup> CommandGroups => instance?.commandGroups;

        private static CmdManager instance;
        private readonly Regex cmdParser;
        private readonly List<CommandGroup> commandGroups;
        private readonly Dictionary<string, Command> commands;

        public CmdManager()
        {
            if (instance == null)
                instance = this;
            else
                throw new Exception("Only one instance of CmdManager can exist at any given time.");

            commandGroups = new List<CommandGroup>();
            commands = new Dictionary<string, Command>();
            cmdParser = new Regex(@"((\s*?[\s,;|]\s*?)((\w+)|("".+"")))+");
            RichHudCore.LateMessageEntered += MessageHandler;
        }

        protected override void UnloadData()
        {
            RichHudCore.LateMessageEntered -= MessageHandler;
            instance = null;
        }

        public static ICommandGroup GetOrCreateGroup(string prefix, CmdGroupInitializer groupInitializer = null)
        {
            prefix = prefix.ToLower();
            CommandGroup group = instance.commandGroups.Find(x => x.Prefix == prefix);

            if (group == null)
            {
                group = new CommandGroup(prefix);
                instance.commandGroups.Add(group);
                group.AddCommands(groupInitializer);
            }

            return group;
        }

        /// <summary>
        /// Recieves chat commands and attempts to execute them.
        /// </summary>
        private void MessageHandler(string message, ref bool sendToOthers)
        {
            message = message.ToLower();
            CommandGroup group = commandGroups.Find(x => message.StartsWith(x.Prefix));

            if (group != null)
            {
                sendToOthers = false;
                ExceptionHandler.Run(() => group.TryRunCommand(message));
            }
        }

        /// <summary>
        /// Parses list of arguments and their associated command name.
        /// </summary>
        public static bool TryParseCommand(string cmd, out string[] matches)
        {
            Match match = instance.cmdParser.Match(cmd);
            CaptureCollection captures = match.Groups[3].Captures;
            matches = new string[captures.Count];

            for (int n = 0; n < captures.Count; n++)
            {
                matches[n] = captures[n].Value;

                if (matches[n][0] == '"' && matches[n][matches[n].Length - 1] == '"')
                    matches[n] = matches[n].Substring(1, matches[n].Length - 2);
            }

            return matches.Length > 0;
        }

        private class CommandGroup : ICommandGroup
        {
            public IChatCommand this[int index] => commands[index];
            public int Count => commands.Count;
            public ICommandGroup Commands => this;
            public string Prefix { get; }

            private readonly List<Command> commands;

            public CommandGroup(string prefix)
            {
                commands = new List<Command>();
                this.Prefix = prefix;
            }

            public bool TryRunCommand(string message)
            {
                bool cmdFound = false, success = false;
                string[] matches;

                if (TryParseCommand(message, out matches))
                {
                    string cmdName = matches[0];
                    Command command;

                    if (instance.commands.TryGetValue($"{Prefix}.{cmdName}", out command))
                    {
                        string[] args = matches.GetSubarray(1);
                        cmdFound = true;

                        if (args.Length >= command.ArgsRequired)
                        {
                            command.InvokeCommand(args);
                            success = true;
                        }
                        else
                            ExceptionHandler.SendChatMessage($"Error: {cmdName} command requires at least {command.ArgsRequired} argument(s).");

                    }
                }

                if (!cmdFound)
                    ExceptionHandler.SendChatMessage("Command not recognised.");

                return success;
            }

            public bool TryAdd(string name, Action<string[]> callback = null, int argsRequired = 0)
            {
                name = name.ToLower();
                string key = $"{Prefix}.{name}";

                if (instance != null && !instance.commands.ContainsKey(key))
                {
                    Command command = new Command(name, argsRequired);
                    commands.Add(command);
                    instance.commands.Add(key, command);

                    if (callback != null)
                        command.CommandInvoked += callback;

                    return true;
                }
                else
                    return false;
            }

            public void AddCommands(CmdGroupInitializer newCommands)
            {
                for (int n = 0; n < newCommands.Count; n++)
                {
                    var cmd = newCommands[n];
                    TryAdd(cmd.Item1, cmd.Item2, cmd.Item3);
                }
            }
        }

        private class Command : IChatCommand
        {
            public event Action<string[]> CommandInvoked;
            public string CmdName { get; }
            public int ArgsRequired { get; }

            public Command(string cmdName, int argsRequired)
            {
                CmdName = cmdName.ToLower();
                ArgsRequired = argsRequired;
            }

            public void InvokeCommand(string[] args) =>
                CommandInvoked?.Invoke(args);
        }
    }
}﻿using RichHudFramework.Internal;
using VRage.Input;

namespace RichHudFramework.UI
{
    using Client;
    using Server;

    /// <summary>
    /// Wrapper used to provide easy access to library key binds.
    /// </summary>
    public sealed class SharedBinds : RichHudComponentBase
    {
        public static IBind LeftButton { get { return Instance.sharedMain[0]; } }
        public static IBind RightButton { get { return Instance.sharedMain[1]; } }
        public static IBind MousewheelUp { get { return Instance.sharedMain[2]; } }
        public static IBind MousewheelDown { get { return Instance.sharedMain[3]; } }

        public static IBind Enter { get { return Instance.sharedMain[4]; } }
        public static IBind Back { get { return Instance.sharedMain[5]; } }
        public static IBind Delete { get { return Instance.sharedMain[6]; } }
        public static IBind Escape { get { return Instance.sharedMain[7]; } }

        public static IBind SelectAll { get { return Instance.sharedMain[8]; } }
        public static IBind Copy { get { return Instance.sharedMain[9]; } }
        public static IBind Cut { get { return Instance.sharedMain[10]; } }
        public static IBind Paste { get { return Instance.sharedMain[11]; } }

        public static IBind UpArrow { get { return Instance.sharedMain[12]; } }
        public static IBind DownArrow { get { return Instance.sharedMain[13]; } }
        public static IBind LeftArrow { get { return Instance.sharedMain[14]; } }
        public static IBind RightArrow { get { return Instance.sharedMain[15]; } }

        public static IBind PageUp { get { return Instance.sharedMain[16]; } }
        public static IBind PageDown { get { return Instance.sharedMain[17]; } }
        public static IBind Space { get { return Instance.sharedMain[18]; } }

        public static IBind Control { get { return Instance.sharedModifiers[0]; } }
        public static IBind Shift { get { return Instance.sharedModifiers[1]; } }
        public static IBind Alt { get { return Instance.sharedModifiers[2]; } }

        private static SharedBinds Instance
        {
            get { Init(); return instance; }
            set { instance = value; }
        }
        private static SharedBinds instance;
        private readonly IBindGroup sharedMain, sharedModifiers;

        private SharedBinds() : base(false, true)
        {
            sharedMain = BindManager.GetOrCreateGroup("SharedBinds");
            sharedMain.RegisterBinds(new BindGroupInitializer
            {
                { "leftbutton", MyKeys.LeftButton },
                { "rightbutton", MyKeys.RightButton },
                { "mousewheelup", RichHudControls.MousewheelUp },
                { "mousewheeldown", RichHudControls.MousewheelDown },

                { "enter", MyKeys.Enter },
                { "back", MyKeys.Back },
                { "delete", MyKeys.Delete },
                { "escape", MyKeys.Escape },

                { "selectall", MyKeys.Control, MyKeys.A },
                { "copy", MyKeys.Control, MyKeys.C },
                { "cut", MyKeys.Control, MyKeys.X },
                { "paste", MyKeys.Control, MyKeys.V },

                { "uparrow", MyKeys.Up },
                { "downarrow", MyKeys.Down },
                { "leftarrow", MyKeys.Left },
                { "rightarrow", MyKeys.Right },
                
                { "pageup", MyKeys.PageUp },
                { "pagedown", MyKeys.PageDown },
                { "space", MyKeys.Space },
            });
            sharedModifiers = BindManager.GetOrCreateGroup("SharedModifiers");
            sharedModifiers.RegisterBinds(new BindGroupInitializer
            {
                { "shift", MyKeys.Shift },
                { "control", MyKeys.Control },
                { "alt", MyKeys.Alt },
            });
        }

        private static void Init()
        {
            if (instance == null)
                instance = new SharedBinds();
        }

        public override void Close()
        {
            Instance = null;
        }
    }
}﻿
using RichHudFramework.UI.Rendering;
using Sandbox.ModAPI;
using System.Text;
using VRage.Collections;
using System;
using VRageMath;

namespace RichHudFramework.UI
{
    public class TextInput
    {
        public Func<char, bool> IsCharAllowedFunc;

        private readonly Action<char> OnAppendAction;
        private readonly Action OnBackspaceAction;

        public TextInput(Action<char> OnAppendAction, Action OnBackspaceAction, Func<char, bool> IsCharAllowedFunc = null) 
        {
            this.OnAppendAction = OnAppendAction;
            this.OnBackspaceAction = OnBackspaceAction;
            this.IsCharAllowedFunc = IsCharAllowedFunc;
        }

        private void Backspace()
        {
            OnBackspaceAction?.Invoke();
        }

        public void HandleInput()
        {
            ListReader<char> input = MyAPIGateway.Input.TextInput;

            if (SharedBinds.Back.IsPressedAndHeld || SharedBinds.Back.IsNewPressed)
                Backspace();

            for (int n = 0; n < input.Count; n++)
            {
                if (input[n] != '\b' && (IsCharAllowedFunc == null || IsCharAllowedFunc(input[n])))
                {
                    OnAppendAction?.Invoke(input[n]);
                }
            }
        }
    }
}﻿using System;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Flags used to block input for the game's controls. Useful for modifying normal
    /// input behavior. Does not affect all binds.
    /// </summary>
    [Flags]
    public enum SeBlacklistModes : int
    {
        /// <summary>
        /// Default: no blacklist.
        /// </summary>
        None = 0x0,

        /// <summary>
        /// Set flag to disable mouse button keybinds. 
        /// </summary>
        Mouse = 0x1,

        /// <summary>
        /// Set flag to blacklist every blacklist-able bind. 
        /// Keep in mind that not every SE bind can be disabled.
        /// </summary>
        AllKeys = 0x2 | Mouse,

        /// <summary>
        /// Set flag to disable camera rotation (does not disable look with alt)
        /// </summary>
        CameraRot = 0x4,

        /// <summary>
        /// Set flag to disable mouse buttons as well as camera rotation.
        /// </summary>
        MouseAndCam = Mouse | CameraRot,

        /// <summary>
        /// Set flag to disable all key binds as well as camera rotation
        /// </summary>
        Full = AllKeys | CameraRot
    }

    public enum BindClientAccessors : int
    {
        /// <summary>
        /// in: string, out: int
        /// </summary>
        GetOrCreateGroup = 1,

        /// <summary>
        /// in: string, out: int
        /// </summary>
        GetBindGroup = 2,

        /// <summary>
        /// in: IReadOnlyList{string}, out: int[]
        /// </summary>
        GetComboIndices = 3,

        /// <summary>
        /// in: string, out: int
        /// </summary>
        GetControlByName = 4,

        /// <summary>
        /// void
        /// </summary>
        ClearBindGroups = 5,

        /// <summary>
        /// void
        /// </summary>
        Unload = 6,

        /// <summary>
        /// in/out: SeBlacklistModes
        /// </summary>
        RequestBlacklistMode = 7,

        /// <summary>
        /// out: bool
        /// </summary>
        IsChatOpen = 8,
    }
}﻿using System.Xml.Serialization;
using VRage;
using BindDefinitionData = VRage.MyTuple<string, string[]>;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Stores data for serializing individual key binds to XML.
        /// </summary>
        [XmlType(TypeName = "Bind")]
        public struct BindDefinition
        {
            [XmlAttribute]
            public string name;

            [XmlArray("Controls")]
            public string[] controlNames;

            public BindDefinition(string name, string[] controlNames)
            {
                this.name = name;
                this.controlNames = controlNames;
            }

            public static implicit operator BindDefinition(BindDefinitionData value)
            {
                return new BindDefinition(value.Item1, value.Item2);
            }

            public static implicit operator MyTuple<string, string[]>(BindDefinition value)
            {
                return new BindDefinitionData(value.name, value.controlNames);
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using VRage.Input;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;
        using System.Collections;

        /// <summary>
        /// Bind data container used to simplify bind registration.
        /// </summary>
        public class BindGroupInitializer : IReadOnlyList<MyTuple<string, IReadOnlyList<int>>>
        {
            public MyTuple<string, IReadOnlyList<int>> this[int index] => bindData[index];

            public int Count => bindData.Count;

            private readonly List<MyTuple<string, IReadOnlyList<int>>> bindData;

            public BindGroupInitializer()
            {
                bindData = new List<MyTuple<string, IReadOnlyList<int>>>();
            }

            public IEnumerator<MyTuple<string, IReadOnlyList<int>>> GetEnumerator() =>
                bindData.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                GetEnumerator();

            /// <summary>
            /// Adds a bind with the given name and the given key combo.
            /// </summary>
            public void Add(string bindName, string con1, string con2 = null, string con3 = null)
            {
                var names = new List<string>();

                if (con1 != null)
                    names.Add(con1);

                if (con2 != null)
                    names.Add(con2);

                if (con3 != null)
                    names.Add(con3);

                bindData.Add(new MyTuple<string, IReadOnlyList<int>>(bindName, BindManager.GetComboIndices(names)));
            }

            /// <summary>
            /// Adds a bind with the given name and the given key combo.
            /// </summary>
            public void Add(string bindName, int con1, int con2 = -1, int con3 = -1)
            {
                var indices = new List<int>();

                if (con1 != -1)
                    indices.Add(con1);

                if (con2 != -1)
                    indices.Add(con2);

                if (con3 != -1)
                    indices.Add(con3);

                bindData.Add(new MyTuple<string, IReadOnlyList<int>>(bindName, indices));
            }

            /// <summary>
            /// Adds a bind with the given name and the given key combo.
            /// </summary>
            public void Add(string bindName, ControlData con1 = null, ControlData con2 = null, ControlData con3 = null)
            {
                var indices = new List<int>();

                if (con1 != null)
                    indices.Add(con1);

                if (con2 != null)
                    indices.Add(con2);

                if (con3 != null)
                    indices.Add(con3);

                bindData.Add(new MyTuple<string, IReadOnlyList<int>>(bindName, indices));
            }

            /// <summary>
            /// Returns group data as a serializable array of BindDefinitions.
            /// </summary>
            public BindDefinition[] GetBindDefinitions()
            {
                var definitions = new BindDefinition[bindData.Count];

                for (int a = 0; a < definitions.Length; a++)
                {
                    var controlNames = new string[bindData[a].Item2.Count];

                    for (int b = 0; b < controlNames.Length; b++)
                        controlNames[b] = BindManager.Controls[bindData[a].Item2[b]].Name;

                    definitions[a] = new BindDefinition(bindData[a].Item1, controlNames);
                }

                return definitions;
            }
        }

        public class ControlData
        {
            public readonly int index;

            public ControlData(MyKeys key)
            {
                index = BindManager.GetControl(key).Index;
            }

            public ControlData(RichHudControls key)
            {
                index = BindManager.GetControl(key).Index;
            }

            public static implicit operator int(ControlData control) =>
                control.index;

            public static implicit operator ControlData(MyKeys key) =>
                new ControlData(key);

            public static implicit operator ControlData(RichHudControls key) =>
                new ControlData(key);
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;

namespace RichHudFramework
{
    namespace UI
    {
        public enum RichHudControls : int
        {
            MousewheelUp = 256,
            MousewheelDown = 257,
        }
    }
}﻿using System;
using System.Collections.Generic;

namespace RichHudFramework
{
    namespace UI
    {
        public interface IBind
        {
            /// <summary>
            /// Name of the keybind
            /// </summary>
            string Name { get; }

            /// <summary>
            /// Index of the bind within its group
            /// </summary>
            int Index { get; }

            /// <summary>
            /// True if any controls in the bind are marked analog. For these types of binds, IsPressed == IsNewPressed.
            /// </summary>
            bool Analog { get; }

            /// <summary>
            /// True if just pressed.
            /// </summary>
            bool IsNewPressed { get; }

            /// <summary>
            /// True if currently pressed.
            /// </summary>
            bool IsPressed { get; }

            /// <summary>
            /// True after being held for more than 500ms.
            /// </summary>
            bool IsPressedAndHeld { get; }

            /// <summary>
            /// True if just released.
            /// </summary>
            bool IsReleased { get; }

            /// <summary>
            /// Invoked when the bind is first pressed.
            /// </summary>
            event EventHandler NewPressed;

            /// <summary>
            /// Invoked after the bind has been held and pressed for at least 500ms.
            /// </summary>
            event EventHandler PressedAndHeld;

            /// <summary>
            /// Invoked after the bind has been released.
            /// </summary>
            event EventHandler Released;

            /// <summary>
            /// Returns a list of the current key combo for this bind.
            /// </summary>
            List<IControl> GetCombo();

            /// <summary>
            /// Returns a list of control indices for the current bind combo
            /// </summary>
            List<int> GetComboIndices();

            /// <summary>
            /// Attempts to set the binds combo to the given controls. Returns true if successful.
            /// </summary>
            bool TrySetCombo(IReadOnlyList<IControl> combo, bool strict = true, bool silent = true);

            /// <summary>
            /// Attempts to set the binds combo to the given controls. Returns true if successful.
            /// </summary>
            bool TrySetCombo(IReadOnlyList<int> combo, bool strict = true, bool silent = true);

            /// <summary>
            /// Attempts to set the binds combo to the given controls. Returns true if successful.
            /// </summary>
            bool TrySetCombo(IReadOnlyList<string> combo, bool strict = true, bool silent = true);

            /// <summary>
            /// Clears the current key combination.
            /// </summary>
            void ClearCombo();

            /// <summary>
            /// Clears all event subscibers for this bind.
            /// </summary>
            void ClearSubscribers();
        }

        public enum BindAccesssors : int
        {
            /// <summary>
            /// out: <see cref="string"/>
            /// </summary>
            Name = 1,

            /// <summary>
            /// out: <see cref="bool"/>
            /// </summary>
            Analog = 2,

            /// <summary>
            /// out: index
            /// </summary>
            Index = 3,

            /// <summary>
            /// out: bool
            /// </summary>
            IsPressed = 4,

            /// <summary>
            /// out: bool
            /// </summary>
            IsNewPressed = 5,

            /// <summary>
            /// out: bool
            /// </summary>
            IsPressedAndHeld = 6,

            /// <summary>
            /// out: bool
            /// </summary>
            IsReleased = 7,

            /// <summary>
            /// in: MyTuple(bool, Action)
            /// </summary>
            OnNewPress = 8,

            /// <summary>
            /// in: MyTuple(bool, Action)
            /// </summary>
            OnPressAndHold = 9,

            /// <summary>
            /// in: MyTuple(bool, Action)
            /// </summary>
            OnRelease = 10,

            /// <summary>
            /// out: <see cref="List{T}(int)"/>
            /// </summary>
            GetCombo = 11,

            /// <summary>
            /// in: MyTuple{List{int}, bool}, out: bool"
            /// </summary>
            TrySetComboWithIndices = 12,

            /// <summary>
            /// in: MyTuple{List{string}, bool}, out: bool"
            /// </summary>
            TrySetComboWithNames = 13,

            /// <summary>
            /// void
            /// </summary>
            ClearCombo = 14,

            /// <summary>
            /// void
            /// </summary>
            ClearSubscribers = 15,
        }

    }
}﻿using System.Collections.Generic;
using VRage;
using BindDefinitionData = VRage.MyTuple<string, string[]>;

namespace RichHudFramework
{
    namespace UI
    {
        // <summary>
        /// A collection of unique keybinds.
        /// </summary>
        public interface IBindGroup : IReadOnlyList<IBind>
        {
            /// <summary>
            /// Returns the bind with the name given, if it exists.
            /// </summary>
            IBind this[string name] { get; }

            /// <summary>
            /// Bind group name
            /// </summary>
            string Name { get; }

            /// <summary>
            /// Index of the bind group in its associated client
            /// </summary>
            int Index { get; }

            /// <summary>
            /// Unique identifer
            /// </summary>
            object ID { get; }

            /// <summary>
            /// Returns true if the group contains a bind with the given name.
            /// </summary>
            bool DoesBindExist(string name);

            /// <summary>
            /// Returns true if the given list of controls conflicts with any existing binds.
            /// </summary>
            bool DoesComboConflict(IReadOnlyList<IControl> newCombo, IBind exception = null);

            /// <summary>
            /// Determines if given combo is equivalent to any existing binds.
            /// </summary>
            bool DoesComboConflict(IReadOnlyList<int> newCombo, int exception = -1);

            /// <summary>
            /// Replaces current bind combos with combos based on the given <see cref="BindDefinition"/>[]. Does not register new binds.
            /// </summary>
            bool TryLoadBindData(IReadOnlyList<BindDefinitionData> bindData);

            /// <summary>
            /// Attempts to load bind combinations from bind data. Will not register new binds.
            /// </summary>
            bool TryLoadBindData(IReadOnlyList<BindDefinition> bindData);

            /// <summary>
            /// Registers a list of binds using the names given paired with associated control indices.
            /// </summary>
            void RegisterBinds(BindGroupInitializer bindData);

            /// <summary>
            /// Registers a list of binds using the names given paired with associated control indices.
            /// </summary>
            void RegisterBinds(IReadOnlyList<MyTuple<string, IReadOnlyList<int>>> bindData);

            /// <summary>
            /// Registers a list of binds using the names given.
            /// </summary>
            void RegisterBinds(IReadOnlyList<string> bindNames);

            /// <summary>
            /// Registers and loads bind combinations from BindDefinitions.
            /// </summary>
            void RegisterBinds(IReadOnlyList<BindDefinition> bindData);

            /// <summary>
            /// Registers and loads bind combinations from BindDefinitionData.
            /// </summary>
            void RegisterBinds(IReadOnlyList<BindDefinitionData> bindData);

            /// <summary>
            /// Returns the bind with the name given, if it exists.
            /// </summary>
            IBind GetBind(string name);

            /// <summary>
            /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
            /// </summary>
            IBind AddBind(string bindName, IReadOnlyList<string> combo);

            /// <summary>
            /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
            /// </summary>
            IBind AddBind(string bindName, IReadOnlyList<ControlData> combo = null);

            /// <summary>
            /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
            /// </summary>
            IBind AddBind(string bindName, IReadOnlyList<int> combo);

            /// <summary>
            /// Adds a bind with the given name and the given key combo. Throws an exception if the bind is invalid.
            /// </summary>
            IBind AddBind(string bindName, IReadOnlyList<IControl> combo = null);

            /// <summary>
            /// Tries to register an empty bind using the given name.
            /// </summary>
            bool TryRegisterBind(string bindName, out IBind newBind);

            /// <summary>
            /// Tries to register a bind using the given name and the given key combo.
            /// </summary>
            bool TryRegisterBind(string bindName, IReadOnlyList<int> combo, out IBind newBind);

            /// <summary>
            /// Tries to register a bind using the given name and the given key combo.
            /// </summary>
            bool TryRegisterBind(string bindName, out IBind newBind, IReadOnlyList<int> combo);

            /// <summary>
            /// Tries to register a bind using the given name and the given key combo.
            /// </summary>
            bool TryRegisterBind(string bindName, out IBind bind, IReadOnlyList<string> combo);

            /// <summary>
            /// Tries to register a bind using the given name and the given key combo.
            /// </summary>
            bool TryRegisterBind(string bindName, out IBind newBind, IReadOnlyList<IControl> combo);

            /// <summary>
            /// Retrieves the set of key binds as an array of BindDefinition
            /// </summary>
            BindDefinition[] GetBindDefinitions();

            /// <summary>
            /// Retrieves the set of key binds as an array of BindDefinition
            /// </summary>
            BindDefinitionData[] GetBindData();

            /// <summary>
            /// Clears bind subscribers for the entire group
            /// </summary>
            void ClearSubscribers();
        }

        public enum BindGroupAccessors : int
        {
            /// <summary>
            /// out: string
            /// </summary>
            Name = 1,

            /// <summary>
            /// object
            /// </summary>
            ID = 2,

            /// <summary>
            /// in: MyTuple{IReadOnlyList{int}, int}, out: bool
            /// </summary>
            DoesComboConflict = 3,

            /// <summary>
            /// in: string, out: int
            /// </summary>
            TryRegisterBindName = 4,

            /// <summary>
            /// in:  MyTuple{string, int[]}, out: int
            /// </summary>
            TryRegisterBindWithIndices = 5,

            /// <summary>
            /// in: MyTuple{string, string[]}, out: int
            /// </summary>
            TryRegisterBindWithNames = 6,

            /// <summary>
            /// in: IReadOnlyList{BindDefinitionData}, Out: BindMembers[]
            /// </summary>
            TryLoadBindData = 7,

            /// <summary>
            /// out: BindDefinitionData[]
            /// </summary>
            GetBindData = 8,

            /// <summary>
            /// in: int, out: bool
            /// </summary>
            DoesBindExist = 9,

            /// <summary>
            /// in: string, out: Vector2I
            /// </summary>
            GetBindFromName = 10,

            /// <summary>
            /// in: IReadOnlyList{string}
            /// </summary>
            RegisterBindNames = 11,

            /// <summary>
            /// in: IReadOnlyList{MyTuple{string, IReadOnlyList{int}}}
            /// </summary>
            RegisterBindIndices = 12,

            /// <summary>
            /// in: IReadOnlyList{BindDefinitionData}
            /// </summary>
            RegisterBindDefinitions = 13,

            /// <summary>
            /// in: MyTuple{string, IReadOnlyList{int}}, out: Vector2I
            /// </summary>
            AddBindWithIndices = 14,

            /// <summary>
            /// in: MyTuple{string, IReadOnlyList{string}}, out: Vector2I
            /// </summary>
            AddBindWithNames = 15,

            /// <summary>
            /// void
            /// </summary>
            ClearSubscribers = 16,
        }
    }
}﻿namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Interface for controls used by the bind manager
        /// </summary> 
        public interface IControl
        {
            /// <summary>
            /// Name of the control
            /// </summary>
            string Name { get; }

            /// <summary>
            /// Name of the control as displayed in bind menu
            /// </summary>
            string DisplayName { get; }

            /// <summary>
            /// Index of the control in the bind manager
            /// </summary>
            int Index { get; }

            /// <summary>
            /// Returns true if the control is being pressed
            /// </summary>
            bool IsPressed { get; }

            /// <summary>
            /// Returns true if the control was just pressed
            /// </summary>
            bool IsNewPressed { get; }

            /// <summary>
            /// Returns true if the control was just released
            /// </summary>
            bool IsReleased { get; }

            // <summary>
            /// Returns true if the control doesn't represent a boolean value. For example, MwUp/Dn
            /// represent scroll wheel movement, but don't return an exact position/displacement.
            /// </summary>
            bool Analog { get; }
        }

        public enum ControlAccessors : int
        {
            /// <summary>
            /// out: string
            /// </summary>
            Name = 1,

            /// <summary>
            /// out: string
            /// </summary>
            DisplayName = 2,

            /// <summary>
            /// out: int
            /// </summary>
            Index = 3,

            /// <summary>
            /// out: bool
            /// </summary>
            IsPressed = 4,

            /// <summary>
            /// out: bool
            /// </summary>
            Analog = 5,

            /// <summary>
            /// out: bool
            /// </summary>
            IsNewPressed = 6,

            /// <summary>
            /// out: bool
            /// </summary>
            IsReleased = 7
        }
    }
}﻿using System;
using VRage;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        [Flags]
        public enum DimAlignments : byte
        {
            None = 0x0,

            /// <summary>
            /// Match parent width
            /// </summary>
            Width = 0x1,

            /// <summary>
            /// Match parent height
            /// </summary>
            Height = 0x2,

            /// <summary>
            /// Match parent size
            /// </summary>
            Both = Width | Height,

            /// <summary>
            /// Matches parent size less padding
            /// </summary>
            IgnorePadding = 0x4,
        }

        /// <summary>
        /// Used to determine the default position of an element relative to its parent.
        /// </summary>
        [Flags]
        public enum ParentAlignments : byte
        {
            /// <summary>
            /// The element's origin is at the center of its parent.
            /// </summary>
            Center = 0x0,

            /// <summary>
            /// The element will start with its right edge aligned to its parent's left edge.
            /// If the flag InnerH is set, then its left edge will be aligned to its parent's
            /// left edge.
            /// </summary>
            Left = 0x1,

            /// <summary>
            /// The element will start with its bottom edge aligned to its parent's top edge.
            /// If the flag InnerV is set, then its top edge will be aligned to its parent's
            /// top edge.
            /// </summary>
            Top = 0x2,

            /// <summary>
            /// The element will start with its left edge aligned to its parent's right edge.
            /// If the flag InnerH is set, then its right edge will be aligned to its parent's
            /// right edge.
            /// </summary>
            Right = 0x4,

            /// <summary>
            /// The element will start with its top edge aligned to its parent's bottom edge.
            /// If the flag InnerV is set, then its bottom edge will be aligned to its parent's
            /// bottom edge.
            /// </summary>
            Bottom = 0x8,

            /// <summary>
            /// Modifier flag to be used in conjunction with the Left/Right flags. If this flag is set,
            /// then the element will be horizontally aligned to the interior of its parent.
            /// </summary>
            InnerH = 0x10,

            /// <summary>
            /// Modifier flag to be used in conjunction with the Top/Bottom flags. If this flag is set,
            /// then the element will be vertically aligned to the interior of its parent.
            /// </summary>
            InnerV = 0x20,

            /// <summary>
            /// InnerH + InnerV. If this flag is set then the element will be aligned to the interior of
            /// its parent.
            /// </summary>
            Inner = InnerH | InnerV,

            /// <summary>
            /// If set, this flag will cause the element's alignment to be calculated taking the
            /// parent's padding into account.
            /// </summary>
            UsePadding = 0x40,
        }
    }
}﻿using System;

namespace RichHudFramework
{
    public delegate void EventHandler(object sender, EventArgs e);

    namespace UI
    {
        public enum HudMainAccessors : int
        {
            /// <summary>
            /// out: float
            /// </summary>
            ScreenWidth = 1,

            /// <summary>
            /// out: float
            /// </summary>
            ScreenHeight = 2,

            /// <summary>
            /// out: float
            /// </summary>
            AspectRatio = 3,

            /// <summary>
            /// out: float
            /// </summary>
            ResScale = 4,

            /// <summary>
            /// out: float
            /// </summary>
            Fov = 5,

            /// <summary>
            /// out: float
            /// </summary>
            FovScale = 6,

            /// <summary>
            /// out: MatrixD
            /// </summary>
            PixelToWorldTransform = 7,

            /// <summary>
            /// in/out: RichText
            /// </summary>
            ClipBoard = 8,

            /// <summary>
            /// out: float
            /// </summary>
            UiBkOpacity = 9,

            /// <summary>
            /// in/out: bool
            /// </summary>
            EnableCursor = 10,

            /// <summary>
            /// in/out: bool
            /// </summary>
            RefreshDrawList = 11,

            /// <summary>
            /// in/out: Action<List<HudUpdateAccessors>, byte>
            /// </summary>
            GetUpdateAccessors = 12,

            /// <summary>
            /// out: byte, in: Action{byte}
            /// </summary>
            GetFocusOffset = 13,

            /// <summary>
            /// out: HudSpaceDelegate
            /// </summary>
            GetPixelSpaceFunc = 14,

            /// <summary>
            /// out: Func{Vector3D}
            /// </summary>
            GetPixelSpaceOriginFunc = 15,

            /// <summary>
            /// in: Action
            /// </summary>
            GetInputFocus = 16,

            /// <summary>
            /// out: int
            /// </summary>
            TreeRefreshRate = 17,

            /// <summary>
            /// out: HudInputMode (int)
            /// </summary>
            InputMode = 18,

            /// <summary>
            /// in: Action
            /// </summary>
            SetBeforeDrawCallback = 19,

            /// <summary>
            /// in: Action
            /// </summary>
            SetAfterDrawCallback = 20,

            /// <summary>
            /// in: Action
            /// </summary>
            SetBeforeInputCallback = 21,

            /// <summary>
            /// in: Action
            /// </summary>
            SetAfterInputCallback = 22,
        }

        public enum HudInputMode : int
        {
            NoInput = 0,

            /// <summary>
            /// Cursor is enabled and visible
            /// </summary>
            CursorOnly = 1,

            /// <summary>
            /// Cursor and text input enabled
            /// </summary>
            Full = 2
        }

        public enum ListBoxEntryAccessors : int
        {
            /// <summary>
            /// IList<RichStringMembers>
            /// </summary>
            Name = 1,

            /// <summary>
            /// bool
            /// </summary>
            Enabled = 2,

            /// <summary>
            /// Object
            /// </summary>
            AssocObject = 3,

            /// <summary>
            /// Object
            /// </summary>
            ID = 4,
        }

        public enum ListBoxAccessors : int
        {
            /// <summary>
            /// CollectionData
            /// </summary>
            ListMembers = 1,

            /// <summary>
            /// in: MyTuple<IList<RichStringMembers>, T>, out: ApiMemberAccessor
            /// </summary>
            Add = 2,

            /// <summary>
            /// out: ListBoxEntry
            /// </summary>
            Selection = 3,

            /// <summary>
            /// out: int
            /// </summary>
            SelectionIndex = 4,

            /// <summary>
            /// in: T (AssocObject)
            /// </summary>
            SetSelectionAtData = 5,

            /// <summary>
            /// in: MyTuple<int, IList<RichStringMembers>, T>
            /// </summary>
            Insert = 6,

            /// <summary>
            /// in: ListBoxEntry, out: bool
            /// </summary>
            Remove = 7,

            /// <summary>
            /// in: int
            /// </summary>
            RemoveAt = 8,

            /// <summary>
            /// void
            /// </summary>
            ClearEntries = 9
        }
    }
}

namespace RichHudFramework.UI.Server { }
namespace RichHudFramework.UI.Rendering.Server { }﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;
using RichStringMembers = VRage.MyTuple<System.Text.StringBuilder, VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>>;

namespace RichHudFramework
{
    namespace UI
    {
        public enum HudCursorAccessors : int
        {
            /// <summary>
            /// out: bool
            /// </summary>
            Visible = 0,

            /// <summary>
            /// out: bool
            /// </summary>
            IsCaptured = 1,

            /// <summary>
            /// out: Vector2
            /// </summary>
            ScreenPos = 2,

            /// <summary>
            /// out: Vector3D
            /// </summary>
            WorldPos = 3,

            /// <summary>
            /// out: LineD
            /// </summary>
            WorldLine = 4,

            /// <summary>
            /// in: Func<ToolTipMembers>
            /// </summary>
            RegisterToolTip = 5,

            /// <summary>
            /// out: bool
            /// </summary>
            IsToolTipRegistered = 6,
        }

        /// <summary>
        /// Interface for the cursor rendered by the Rich HUD Framework
        /// </summary>
        public interface ICursor
        {
            /// <summary>
            /// Indicates whether the cursor is currently visible
            /// </summary>
            bool Visible { get; }

            /// <summary>
            /// Returns true if the cursor has been captured by a UI element
            /// </summary>
            bool IsCaptured { get; }

            /// <summary>
            /// Returns true if a tooltip has been registered
            /// </summary>
            bool IsToolTipRegistered { get; }

            /// <summary>
            /// The position of the cursor in pixels in screen space
            /// </summary>
            Vector2 ScreenPos { get; }

            /// <summary>
            /// Position of the cursor in world space.
            /// </summary>
            Vector3D WorldPos { get; }

            /// <summary>
            /// Line projected from the cursor into world space on the -Z axis 
            /// correcting for apparent warping due to perspective projection.
            /// </summary>
            LineD WorldLine { get; }

            /// <summary>
            /// Returns true if the given HUD space is being captured by the cursor
            /// </summary>
            bool IsCapturingSpace(HudSpaceDelegate GetHudSpaceFunc);

            /// <summary>
            /// Attempts to capture the cursor at the given depth with the given HUD space. If drawInHudSpace
            /// is true, then the cursor will be drawn in the given space.
            /// </summary>
            bool TryCaptureHudSpace(float depthSquared, HudSpaceDelegate GetHudSpaceFunc);

            /// <summary>
            /// Attempts to capture the cursor at the given depth with the given HUD space. If drawInHudSpace
            /// is true, then the cursor will be drawn in the given space.
            /// </summary>
            void CaptureHudSpace(float depthSquared, HudSpaceDelegate GetHudSpaceFunc);

            /// <summary>
            /// Attempts to capture the cursor with the given object
            /// </summary>
            void Capture(ApiMemberAccessor capturedElement);

            /// <summary>
            /// Indicates whether the cursor is being captured by the given element.
            /// </summary>
            bool IsCapturing(ApiMemberAccessor capturedElement);

            /// <summary>
            /// Attempts to capture the cursor using the given object. Returns true on success.
            /// </summary>
            bool TryCapture(ApiMemberAccessor capturedElement);

            /// <summary>
            /// Attempts to release the cursor from the given element. Returns false if
            /// not capture or if not captured by the object given.
            /// </summary>
            bool TryRelease(ApiMemberAccessor capturedElement);

            /// <summary>
            /// Registers a callback delegate to set the tooltip for the next frame. Tooltips are reset
            /// every tick and must be reregistered in HandleInput() every tick. The first tooltip registered
            /// takes precedence.
            /// </summary>
            void RegisterToolTip(ToolTip toolTip);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using VRageMath;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Contains colors and text formatting used in styling the Rich HUD Terminal
    /// </summary>
    public static class TerminalFormatting
    {
        public static readonly GlyphFormat HeaderFormat = new GlyphFormat(Color.White, TextAlignment.Center, 1.15f);
        public static readonly GlyphFormat ControlFormat = GlyphFormat.Blueish.WithSize(1.08f);
        public static readonly GlyphFormat InvControlFormat = ControlFormat.WithColor(Charcoal);
        public static readonly GlyphFormat WarningFormat = new GlyphFormat(new Color(200, 55, 55));

        /// <summary>
        /// A dark blue grey commonly used for background colors for buttons and lists in the SE
        /// terminal.
        /// </summary>
        public static readonly Color OuterSpace = new Color(42, 55, 62);

        /// <summary>
        /// Dark slate grey used for list backgrounds
        /// </summary>
        public static readonly Color DarkSlateGrey = new Color(41, 54, 62);

        public static readonly Color Gunmetal = new Color(39, 50, 57);

        public static readonly Color Dark = new Color(32, 39, 45);

        /// <summary>
        /// Darker medium blue-grey used for borders around buttons, sliders, etc in the SE terminal.
        /// </summary>
        public static readonly Color LimedSpruce = new Color(61, 70, 78);

        /// <summary>
        /// Dark medium grey used for background highlights for moused-over elements
        /// </summary>
        public static readonly Color Atomic = new Color(60, 76, 82);

        /// <summary>
        /// Medium blue-grey used for scroll bar slider buttons
        /// </summary>
        public static readonly Color MistBlue = new Color(103, 109, 123);

        /// <summary>
        /// Medium blue-grey used for tick boxes
        /// </summary>
        public static readonly Color StormGrey = new Color(114, 121, 136);

        /// <summary>
        /// Darker medium blue-grey used for scroll bars (the actual bar, not the slider)
        /// </summary>
        public static readonly Color MidGrey = new Color(86, 93, 104);

        public static readonly Color EbonyClay = new Color(34, 44, 53);

        /// <summary>
        /// White with a hint of blue. Used for selection tabs in the SE terminal.
        /// </summary>
        public static readonly Color Mercury = new Color(225, 230, 236);

        /// <summary>
        /// A very dark blue-grey used for sliders that have input focus
        /// </summary>
        public static readonly Color BlackPerl = new Color(29, 37, 40);

        /// <summary>
        /// A slightly-different very dark blue-grey used for sliders and check boxes that have input focus
        /// </summary>
        public static readonly Color Cinder = new Color(33, 41, 45);

        /// <summary>
        /// Dark slightly-blue color used for buttons that have focus (were last clicked). Used in combination in SE with a 
        /// bright blue background.
        /// </summary>
        public static readonly Color Charcoal = new Color(39, 49, 55);

        /// <summary>
        /// Bright blue background use for controls that have focus (last clicked). Usually used in combinatination in SE
        /// with Charcoal as the text color.
        /// </summary>
        public static readonly Color Mint = new Color(142, 188, 206);

        /// <summary>
        /// A light blue-grey used to indicate selections for things like on/off buttons in the SE terminal.
        /// </summary>
        public static readonly Color DullMint = new Color(91, 115, 123);
    }
}
﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using RichStringMembers = VRage.MyTuple<System.Text.StringBuilder, VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>>;

namespace RichHudFramework
{
    namespace UI
    {
        using ToolTipMembers = MyTuple<
            List<RichStringMembers>, // Text
            Color? // BgColor
        >;

        /// <summary>
        /// Class used to define tooltips attached to the RHF cursor. Tooltips must be
        /// registered in HandleInput() every input tick. The first tooltip registered
        /// takes precedence.
        /// </summary>
        public class ToolTip
        {
            public static readonly GlyphFormat DefaultText = GlyphFormat.Blueish.WithSize(.75f);
            public static readonly Color DefaultBG = new Color(73, 86, 95),
                orangeWarningBG = new Color(180, 110, 0),
                redWarningBG = new Color(126, 39, 44);

            /// <summary>
            /// Text to be assigned to the tooltip. Multiline tooltips are allowed, but
            /// are not wrapped.
            /// </summary>
            public RichText text;

            /// <summary>
            /// Color of the text background
            /// </summary>
            public Color? bgColor;

            /// <summary>
            /// Callback delegate used by the API to retrieve tooltip information
            /// </summary>
            public readonly Func<ToolTipMembers> GetToolTipFunc;

            public ToolTip()
            {
                bgColor = DefaultBG;

                GetToolTipFunc = () => new ToolTipMembers()
                {
                    Item1 = text?.apiData,
                    Item2 = bgColor,
                };
            }

            public ToolTip(Func<ToolTipMembers> GetToolTipFunc)
            {
                bgColor = DefaultBG;
                this.GetToolTipFunc = GetToolTipFunc;
            }

            /// <summary>
            /// Implicitly converts <see cref="RichText"/> to <see cref="ToolTip"/>
            /// </summary>
            public static implicit operator ToolTip(RichText text) =>
                new ToolTip() { text = text };

            /// <summary>
            /// Implicitly converts <see cref="string"/> to <see cref="ToolTip"/>
            /// </summary>
            public static implicit operator ToolTip(string text) =>
                new ToolTip() { text = new RichText(text, DefaultText) };
        }
    }
}
﻿using System;
using VRage;
using VRageMath;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;
        using Internal;

        /// <summary>
        /// Base type for all hud elements with definite size and position. Inherits from HudParentBase and HudNodeBase.
        /// </summary>
        public abstract class HudElementBase : HudNodeBase, IReadOnlyHudElement
        {
            protected const float minMouseBounds = 8f;
            protected const HudElementStates elementNotVisible = ~(HudElementStates.IsVisible | HudElementStates.IsMousedOver | HudElementStates.IsMouseInBounds);

            public override bool Visible
            {
                set
                {
                    if (value)
                        State |= HudElementStates.IsVisible;
                    else
                        State &= elementNotVisible;
                }
            }

            /// <summary>
            /// Parent object of the node.
            /// </summary>
            public sealed override HudParentBase Parent
            {
                protected set
                {
                    _parent = value;
                    _parentFull = value as HudElementBase;
                }
            }

            /// <summary>
            /// Size of the element. Units in pixels by default.
            /// </summary>
            public Vector2 Size
            {
                get { return new Vector2(Width, Height); }
                set { Width = value.X; Height = value.Y; }
            }

            /// <summary>
            /// Width of the hud element. Units in pixels by default.
            /// </summary>
            public virtual float Width
            {
                get { return _size.X + Padding.X; }
                set
                {
                    if (value > Padding.X)
                        value -= Padding.X;

                    _size.X = value;
                }
            }

            /// <summary>
            /// Height of the hud element. Units in pixels by default.
            /// </summary>
            public virtual float Height
            {
                get { return _size.Y + Padding.Y; }
                set
                {
                    if (value > Padding.Y)
                        value -= Padding.Y;

                    _size.Y = value;
                }
            }

            /// <summary>
            /// Border size. Included in total element size.
            /// </summary>
            public virtual Vector2 Padding
            {
                get { return _padding; }
                set { _padding = value; }
            }

            /// <summary>
            /// Starting position of the hud element.
            /// </summary>
            public Vector2 Origin => (_parentFull == null) ? Vector2.Zero : _parentFull.cachedPosition + originAlignment;

            /// <summary>
            /// Position of the element relative to its origin.
            /// </summary>
            public Vector2 Offset { get; set; }

            /// <summary>
            /// Current position of the hud element. Origin + Offset.
            /// </summary>
            public Vector2 Position => Origin + Offset;

            /// <summary>
            /// Determines the starting position of the hud element relative to its parent.
            /// </summary>
            public ParentAlignments ParentAlignment { get; set; }

            /// <summary>
            /// Determines how/if an element will copy its parent's dimensions. 
            /// </summary>
            public DimAlignments DimAlignment { get; set; }

            /// <summary>
            /// If set to true the hud element will be allowed to capture the cursor.
            /// </summary>
            public bool UseCursor
            {
                get { return (State & HudElementStates.CanUseCursor) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.CanUseCursor;
                    else
                        State &= ~HudElementStates.CanUseCursor;
                }
            }

            /// <summary>
            /// If set to true the hud element will share the cursor with other elements.
            /// </summary>
            public bool ShareCursor
            {
                get { return (State & HudElementStates.CanShareCursor) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.CanShareCursor;
                    else
                        State &= ~HudElementStates.CanShareCursor;
                }
            }

            /// <summary>
            /// If set to true, the hud element will act as a clipping mask for child elements.
            /// False by default. Masking parent elements can still affect non-masking children.
            /// </summary>
            public bool IsMasking
            {
                get { return (State & HudElementStates.IsMasking) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.IsMasking;
                    else
                        State &= ~HudElementStates.IsMasking;
                }
            }

            /// <summary>
            /// If set to true, the hud element will treat its parent as a clipping mask, whether
            /// it's configured as a mask or not.
            /// </summary>
            public bool IsSelectivelyMasked
            {
                get { return (State & HudElementStates.IsSelectivelyMasked) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.IsSelectivelyMasked;
                    else
                        State &= ~HudElementStates.IsSelectivelyMasked;
                }
            }

            /// <summary>
            /// If set to true, then the element can ignore any bounding masks imposed by its parents.
            /// Superceeds selective masking flag.
            /// </summary>
            public bool CanIgnoreMasking
            {
                get { return (State & HudElementStates.CanIgnoreMasking) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.CanIgnoreMasking;
                    else
                        State &= ~HudElementStates.CanIgnoreMasking;
                }
            }

            /// <summary>
            /// Indicates whether or not the element is capturing the cursor.
            /// </summary>
            public virtual bool IsMousedOver => (State & HudElementStates.IsMousedOver) > 0;

            /// <summary>
            /// Element size
            /// </summary>
            protected Vector2 _size;

            /// <summary>
            /// Element padding
            /// </summary>
            protected Vector2 _padding;

            /// <summary>
            /// Values used internally to minimize property calls. Should be treated as read only.
            /// </summary>
            protected Vector2 cachedOrigin, cachedPosition, cachedSize, cachedPadding;

            protected BoundingBox2? maskingBox;
            protected HudElementBase _parentFull;
            private Vector2 originAlignment;

            /// <summary>
            /// Initializes a new hud element with cursor sharing enabled and scaling set to 1f.
            /// </summary>
            public HudElementBase(HudParentBase parent) : base(parent)
            {
                DimAlignment = DimAlignments.None;
                ParentAlignment = ParentAlignments.Center;
            }

            /// <summary>
            /// Used to check whether the cursor is moused over the element and whether its being
            /// obstructed by another element.
            /// </summary>
            protected override void InputDepth()
            {
                State &= ~HudElementStates.IsMouseInBounds;

                if (HudMain.InputMode != HudInputMode.NoInput && (HudSpace?.IsFacingCamera ?? false))
                {
                    Vector3 cursorPos = HudSpace.CursorPos;
                    Vector2 halfSize = Vector2.Max(cachedSize, new Vector2(minMouseBounds)) * .5f;
                    BoundingBox2 box = new BoundingBox2(cachedPosition - halfSize, cachedPosition + halfSize);
                    bool mouseInBounds;

                    if (maskingBox == null)
                        mouseInBounds = box.Contains(new Vector2(cursorPos.X, cursorPos.Y)) == ContainmentType.Contains;
                    else
                        mouseInBounds = box.Intersect(maskingBox.Value).Contains(new Vector2(cursorPos.X, cursorPos.Y)) == ContainmentType.Contains;

                    if (mouseInBounds)
                    {
                        State |= HudElementStates.IsMouseInBounds;
                        HudMain.Cursor.TryCaptureHudSpace(cursorPos.Z, HudSpace.GetHudSpaceFunc);
                    }
                }
            }

            /// <summary>
            /// Updates input for the element and its children. Overriding this method is rarely necessary.
            /// If you need to update input, use HandleInput().
            /// </summary>
            public override void BeginInput()
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        State &= ~(HudElementStates.IsMousedOver | HudElementStates.WasParentInputEnabled);

                        if (_parent != null)
                            State |= _parent.InputEnabled ? HudElementStates.WasParentInputEnabled : HudElementStates.None;

                        if (Visible && InputEnabled)
                        {
                            Vector3 cursorPos = HudSpace.CursorPos;
                            bool mouseInBounds = (State & HudElementStates.IsMouseInBounds) > 0;

                            if (UseCursor && mouseInBounds && !HudMain.Cursor.IsCaptured && HudMain.Cursor.IsCapturingSpace(HudSpace.GetHudSpaceFunc))
                            {
                                bool isMousedOver = mouseInBounds;

                                if (isMousedOver)
                                    State |= HudElementStates.IsMousedOver;

                                HandleInput(new Vector2(cursorPos.X, cursorPos.Y));

                                if (!ShareCursor)
                                    HudMain.Cursor.Capture(accessorDelegates.Item1);
                            }
                            else
                            {
                                HandleInput(new Vector2(cursorPos.X, cursorPos.Y));
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Updates layout for the element and its children. Overriding this method is rarely necessary. 
            /// If you need to update layout, use Layout().
            /// </summary>
            public override void BeginLayout(bool refresh)
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        layerData.fullZOffset = ParentUtils.GetFullZOffset(layerData, _parent);

                        if (_parent == null)
                        {
                            ParentVisible = false;
                        }
                        else
                        {
                            ParentVisible = _parent.Visible;
                        }

                        if (Visible || refresh)
                        {
                            UpdateCache();
                            Layout();

                            // Update cached values for use on draw and by child nodes
                            cachedPadding = Padding;
                            cachedSize = new Vector2(Width, Height);
                            cachedPosition = cachedOrigin + Offset;

                            UpdateMasking();
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Used to immediately draw billboards. Overriding this method is rarely necessary. 
            /// If you need to draw something, use Draw().
            /// </summary>
            public override void BeginDraw()
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        if (Visible)
                        {
                            UpdateCache();
                            Draw();
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Updates cached values as well as parent and dim alignment.
            /// </summary>
            protected void UpdateCache()
            {
                cachedPadding = Padding;

                if (_parentFull != null)
                {
                    GetDimAlignment();
                    originAlignment = GetParentAlignment();
                    cachedOrigin = _parentFull.cachedPosition + originAlignment;
                    cachedPosition = cachedOrigin + Offset;
                }
                else
                {
                    cachedSize = new Vector2(Width, Height);
                    cachedOrigin = Vector2.Zero;
                    cachedPosition = cachedOrigin + Offset;
                }
            }

            /// <summary>
            /// Updates masking state and bounding boxes used to mask billboards
            /// </summary>
            private void UpdateMasking()
            {
                if (_parentFull != null &&
                    (_parentFull.State & HudElementStates.IsMasked) > 0 &&
                    (State & HudElementStates.CanIgnoreMasking) == 0
                )
                    State |= HudElementStates.IsMasked;
                else
                    State &= ~HudElementStates.IsMasked;

                if ((State & HudElementStates.IsMasking) > 0 || (_parentFull != null && (State & HudElementStates.IsSelectivelyMasked) > 0))
                {
                    State |= HudElementStates.IsMasked;
                    BoundingBox2? parentBox, box = null;

                    if ((State & HudElementStates.CanIgnoreMasking) > 0)
                    {
                        parentBox = null;
                    }
                    else if (_parentFull != null && (State & HudElementStates.IsSelectivelyMasked) > 0)
                    {
                        Vector2 halfParent = .5f * _parentFull.cachedSize;
                        parentBox = new BoundingBox2(
                            -halfParent + _parentFull.cachedPosition,
                            halfParent + _parentFull.cachedPosition
                        );

                        if (_parentFull.maskingBox != null)
                            parentBox = parentBox.Value.Intersect(_parentFull.maskingBox.Value);
                    }
                    else
                        parentBox = _parentFull?.maskingBox;

                    if ((State & HudElementStates.IsMasking) > 0)
                    {
                        Vector2 halfSize = .5f * cachedSize;
                        box = new BoundingBox2(
                            -halfSize + cachedPosition,
                            halfSize + cachedPosition
                        );
                    }

                    if (parentBox != null && box != null)
                        box = box.Value.Intersect(parentBox.Value);
                    else if (box == null)
                        box = parentBox;

                    maskingBox = box;
                }
                else if ((State & HudElementStates.IsMasked) > 0)
                {
                    maskingBox = _parentFull?.maskingBox;
                }
                else
                {
                    maskingBox = null;
                }
            }

            /// <summary>
            /// Updates element dimensions to match those of its parent in accordance
            /// with its DimAlignment.
            /// </summary>
            private void GetDimAlignment()
            {
                float width = Width, height = Height;

                if (DimAlignment != DimAlignments.None)
                {
                    float parentWidth = _parentFull.cachedSize.X, parentHeight = _parentFull.cachedSize.Y;

                    if ((DimAlignment & DimAlignments.IgnorePadding) == DimAlignments.IgnorePadding)
                    {
                        Vector2 parentPadding = _parentFull.cachedPadding;

                        if ((DimAlignment & DimAlignments.Width) == DimAlignments.Width)
                            width = parentWidth - parentPadding.X;

                        if ((DimAlignment & DimAlignments.Height) == DimAlignments.Height)
                            height = parentHeight - parentPadding.Y;
                    }
                    else
                    {
                        if ((DimAlignment & DimAlignments.Width) == DimAlignments.Width)
                            width = parentWidth;

                        if ((DimAlignment & DimAlignments.Height) == DimAlignments.Height)
                            height = parentHeight;
                    }

                    Width = width;
                    Height = height;
                }

                cachedSize = new Vector2(width, height);
            }

            /// <summary>
            /// Calculates the offset necessary to achieve the alignment specified by the
            /// ParentAlignment property.
            /// </summary>
            private Vector2 GetParentAlignment()
            {
                Vector2 alignment = Vector2.Zero,
                    max = (_parentFull.cachedSize + cachedSize) * .5f,
                    min = -max;

                if ((ParentAlignment & ParentAlignments.UsePadding) == ParentAlignments.UsePadding)
                {
                    min += _parentFull.cachedPadding * .5f;
                    max -= _parentFull.cachedPadding * .5f;
                }

                if ((ParentAlignment & ParentAlignments.InnerV) == ParentAlignments.InnerV)
                {
                    min.Y += cachedSize.Y;
                    max.Y -= cachedSize.Y;
                }

                if ((ParentAlignment & ParentAlignments.InnerH) == ParentAlignments.InnerH)
                {
                    min.X += cachedSize.X;
                    max.X -= cachedSize.X;
                }

                if ((ParentAlignment & ParentAlignments.Bottom) == ParentAlignments.Bottom)
                    alignment.Y = min.Y;
                else if ((ParentAlignment & ParentAlignments.Top) == ParentAlignments.Top)
                    alignment.Y = max.Y;

                if ((ParentAlignment & ParentAlignments.Left) == ParentAlignments.Left)
                    alignment.X = min.X;
                else if ((ParentAlignment & ParentAlignments.Right) == ParentAlignments.Right)
                    alignment.X = max.X;

                return alignment;
            }

            protected override object GetOrSetApiMember(object data, int memberEnum)
            {
                switch ((HudElementAccessors)memberEnum)
                {
                    case HudElementAccessors.Position:
                        return Position;
                    case HudElementAccessors.Size:
                        return Size;
                }

                return base.GetOrSetApiMember(data, memberEnum);
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    namespace UI
    {
        using Client;
        using Server;
        using Internal;
        using HudUpdateAccessors = MyTuple<
            ApiMemberAccessor,
            MyTuple<Func<ushort>, Func<Vector3D>>, // ZOffset + GetOrigin
            Action, // DepthTest
            Action, // HandleInput
            Action<bool>, // BeforeLayout
            Action // BeforeDraw
        >;

        /// <summary>
        /// Base class for hud elements that can be parented to other elements.
        /// </summary>
        public abstract partial class HudNodeBase : HudParentBase, IReadOnlyHudNode
        {
            protected const HudElementStates nodeVisible = HudElementStates.IsVisible | HudElementStates.WasParentVisible | HudElementStates.IsRegistered,
                nodeInputEnabled = HudElementStates.IsInputEnabled | HudElementStates.WasParentInputEnabled;
            protected const int maxPreloadDepth = 5;

            /// <summary>
            /// Read-only parent object of the node.
            /// </summary>
            IReadOnlyHudParent IReadOnlyHudNode.Parent => _parent;

            /// <summary>
            /// Parent object of the node.
            /// </summary>
            public virtual HudParentBase Parent { get { return _parent; } protected set { _parent = value; } }

            /// <summary>
            /// Determines whether or not an element will be drawn or process input. Visible by default.
            /// </summary>
            public override bool Visible => (State & nodeVisible) == nodeVisible;

            /// <summary>
            /// Returns true if input is enabled can update
            /// </summary>
            public override bool InputEnabled => (State & nodeInputEnabled) == nodeInputEnabled;

            /// <summary>
            /// Indicates whether or not the element has been registered to a parent.
            /// </summary>
            public bool Registered => (State & HudElementStates.IsRegistered) > 0;

            protected bool ParentVisible
            {
                get { return (State & HudElementStates.WasParentVisible) > 0; }
                set 
                { 
                    if (value)
                        State |= HudElementStates.WasParentVisible; 
                    else
                        State &= ~HudElementStates.WasParentVisible;
                }
            }

            protected HudParentBase _parent;

            public HudNodeBase(HudParentBase parent)
            {
                State &= ~HudElementStates.IsRegistered;
                ParentVisible = true;

                Register(parent);
            }

            /// <summary>
            /// Starts input update in a try-catch block. Useful for manually updating UI elements.
            /// Exceptions are reported client-side. Do not override this unless you have a good reason for it.
            /// If you need to update input, use HandleInput().
            /// </summary>
            public override void BeginInput()
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        State &= ~HudElementStates.WasParentInputEnabled;

                        if (_parent != null)
                            State |= _parent.InputEnabled ? HudElementStates.WasParentInputEnabled : HudElementStates.None;

                        if (Visible && InputEnabled)
                        {
                            Vector3 cursorPos = HudSpace.CursorPos;
                            HandleInput(new Vector2(cursorPos.X, cursorPos.Y));
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Updates layout for the element and its children. Overriding this method is rarely necessary. 
            /// If you need to update layout, use Layout().
            /// </summary>
            public override void BeginLayout(bool refresh)
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        layerData.fullZOffset = ParentUtils.GetFullZOffset(layerData, _parent);

                        if (_parent == null)
                        {
                            ParentVisible = false;
                        }
                        else
                        {
                            ParentVisible = _parent.Visible;
                        }

                        if (Visible || refresh)
                            Layout();
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Adds update delegates for members in the order dictated by the UI tree
            /// </summary>
            public override void GetUpdateAccessors(List<HudUpdateAccessors> UpdateActions, byte preloadDepth)
            {
                bool wasSetVisible = (State & HudElementStates.IsVisible) > 0;
                State |= HudElementStates.WasParentVisible;

                if (!wasSetVisible && (State & HudElementStates.CanPreload) > 0)
                    preloadDepth++;

                if (preloadDepth < maxPreloadDepth && (State & HudElementStates.CanPreload) > 0)
                    State |= HudElementStates.IsVisible;

                if (Visible)
                {
                    HudSpace = _parent?.HudSpace;
                    layerData.fullZOffset = ParentUtils.GetFullZOffset(layerData, _parent);

                    UpdateActions.EnsureCapacity(UpdateActions.Count + children.Count + 1);
                    accessorDelegates.Item2.Item2 = HudSpace.GetNodeOriginFunc;

                    UpdateActions.Add(accessorDelegates); ;

                    for (int n = 0; n < children.Count; n++)
                        children[n].GetUpdateAccessors(UpdateActions, preloadDepth);
                }

                if (!wasSetVisible)
                    State &= ~HudElementStates.IsVisible;
            }

            /// <summary>
            /// Registers the element to the given parent object.
            /// </summary>
            /// <param name="canPreload">Indicates whether or not the element's accessors can be loaded into the update tree
            /// before the element is visible. Useful for preventing flicker in scrolling lists.</param>
            public virtual bool Register(HudParentBase newParent, bool canPreload = false)
            {
                if (newParent == this)
                    throw new Exception("Types of HudNodeBase cannot be parented to themselves!");

                if (newParent != null)
                {
                    Parent = newParent;

                    if (_parent.RegisterChild(this))
                        State |= HudElementStates.IsRegistered;
                    else
                        State &= ~HudElementStates.IsRegistered;
                }

                if ((State & HudElementStates.IsRegistered) > 0)
                {
                    if (canPreload)
                        State |= HudElementStates.CanPreload;
                    else
                        State &= ~HudElementStates.CanPreload;

                    return true;
                }
                else
                    return false;
            }

            /// <summary>
            /// Unregisters the element from its parent, if it has one.
            /// </summary>
            public virtual bool Unregister()
            {
                if (Parent != null)
                {
                    HudParentBase lastParent = Parent;
                    Parent = null;

                    lastParent.RemoveChild(this);
                    State &= ~(HudElementStates.IsRegistered | HudElementStates.WasParentVisible);
                }

                return !((State & HudElementStates.IsRegistered) > 0);
            }
        }
    }
}using RichHudFramework.Internal;
using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    namespace UI
    {
        using HudUpdateAccessors = MyTuple<
            ApiMemberAccessor,
            MyTuple<Func<ushort>, Func<Vector3D>>, // ZOffset + GetOrigin
            Action, // DepthTest
            Action, // HandleInput
            Action<bool>, // BeforeLayout
            Action // BeforeDraw
        >;

        /// <summary>
        /// Base class for HUD elements to which other elements are parented. Types deriving from this class cannot be
        /// parented to other elements; only types of <see cref="HudNodeBase"/> can be parented.
        /// </summary>
        public abstract partial class HudParentBase : IReadOnlyHudParent
        {
            /// <summary>
            /// Node defining the coordinate space used to render the UI element
            /// </summary>
            public virtual IReadOnlyHudSpaceNode HudSpace { get; protected set; }

            /// <summary>
            /// Returns true if the element can be drawn and/or accept input
            /// </summary>
            public virtual bool Visible
            {
                get { return (State & HudElementStates.IsVisible) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.IsVisible;
                    else
                        State &= ~HudElementStates.IsVisible;
                }
            }

            /// <summary>
            /// Returns true if input is enabled can update
            /// </summary>
            public virtual bool InputEnabled
            {
                get { return (State & HudElementStates.IsInputEnabled) > 0; }
                set
                {
                    if (value)
                        State |= HudElementStates.IsInputEnabled;
                    else
                        State &= ~HudElementStates.IsInputEnabled;
                }
            }

            /// <summary>
            /// Determines whether the UI element will be drawn in the Back, Mid or Foreground
            /// </summary>
            public sbyte ZOffset
            {
                get { return layerData.zOffset; }
                set { layerData.zOffset = value; }
            }

            public HudElementStates State { get; protected set; }

            protected HudLayerData layerData;
            protected readonly List<HudNodeBase> children;
            protected HudUpdateAccessors accessorDelegates;

            public HudParentBase()
            {
                State |= HudElementStates.IsRegistered;
                InputEnabled = true;
                Visible = true;
                children = new List<HudNodeBase>();

                accessorDelegates = new HudUpdateAccessors()
                {
                    Item1 = GetOrSetApiMember,
                    Item2 = new MyTuple<Func<ushort>, Func<Vector3D>>(() => layerData.fullZOffset, null),
                    Item3 = BeginInputDepth,
                    Item4 = BeginInput,
                    Item5 = BeginLayout,
                    Item6 = BeginDraw
                };
            }

            /// <summary>
            /// Starts cursor depth check in a try-catch block. Useful for manually updating UI elements.
            /// Exceptions are reported client-side. Do not override this unless you have a good reason for it.
            /// If you need to do cursor depth testing use InputDepth();
            /// </summary>
            public virtual void BeginInputDepth()
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        if ((State & HudElementStates.CanUseCursor) > 0 && Visible && InputEnabled)
                            InputDepth();
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Starts input update in a try-catch block. Useful for manually updating UI elements.
            /// Exceptions are reported client-side. Do not override this unless you have a good reason for it.
            /// If you need to update input, use HandleInput().
            /// </summary>
            public virtual void BeginInput()
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        if (Visible && InputEnabled)
                        {
                            Vector3 cursorPos = HudSpace.CursorPos;
                            HandleInput(new Vector2(cursorPos.X, cursorPos.Y));
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Starts layout update in a try-catch block. Useful for manually updating UI elements.
            /// Exceptions are reported client-side. Do not override this unless you have a good reason for it.
            /// If you need to update layout, use Layout().
            /// </summary>
            public virtual void BeginLayout(bool refresh)
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        layerData.fullZOffset = ParentUtils.GetFullZOffset(layerData);

                        if (Visible || refresh)
                            Layout();
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Starts UI draw in a try-catch block. Useful for manually updating UI elements.
            /// Exceptions are reported client-side. Do not override this unless you have a good reason for it.
            /// If you need to draw billboards, use Draw().
            /// </summary>
            public virtual void BeginDraw()
            {
                if (!ExceptionHandler.ClientsPaused)
                {
                    try
                    {
                        if (Visible)
                            Draw();
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler.ReportException(e);
                    }
                }
            }

            /// <summary>
            /// Used to check whether the cursor is moused over the element and whether its being
            /// obstructed by another element.
            /// </summary>
            protected virtual void InputDepth() { }

            /// <summary>
            /// Updates the input of this UI element. Invocation order affected by z-Offset and depth sorting.
            /// </summary>
            protected virtual void HandleInput(Vector2 cursorPos) { }

            /// <summary>
            /// Updates the layout of this UI element. Not affected by depth or z-Offset sorting.
            /// Executes before input and draw.
            /// </summary>
            protected virtual void Layout() { }

            /// <summary>
            /// Used to immediately draw billboards. Invocation order affected by z-Offset and depth sorting.
            /// </summary>
            protected virtual void Draw() { }

            /// <summary>
            /// Adds update delegates for members in the order dictated by the UI tree
            /// </summary>
            public virtual void GetUpdateAccessors(List<HudUpdateAccessors> UpdateActions, byte preloadDepth)
            {
                if (Visible)
                {
                    layerData.fullZOffset = ParentUtils.GetFullZOffset(layerData);

                    UpdateActions.EnsureCapacity(UpdateActions.Count + children.Count + 1);
                    accessorDelegates.Item2.Item2 = HudSpace.GetNodeOriginFunc;

                    UpdateActions.Add(accessorDelegates);

                    for (int n = 0; n < children.Count; n++)
                        children[n].GetUpdateAccessors(UpdateActions, preloadDepth);
                }
            }

            /// <summary>
            /// Registers a child node to the object.
            /// </summary>
            /// <param name="preregister">Adds the element to the update tree without registering.</param>
            public virtual bool RegisterChild(HudNodeBase child)
            {
                if (child.Parent == this && !child.Registered)
                {
                    children.Add(child);
                    return true;
                }
                else if (child.Parent == null)
                    return child.Register(this);
                else
                    return false;
            }

            /// <summary>
            /// Unregisters the specified node from the parent.
            /// </summary>
            /// <param name="fast">Prevents registration from triggering a draw list
            /// update. Meant to be used in conjunction with pooled elements being
            /// unregistered/reregistered to the same parent.</param>
            public virtual bool RemoveChild(HudNodeBase child)
            {
                if (child.Parent == this)
                    return child.Unregister();
                else if (child.Parent == null)
                    return children.Remove(child);
                else
                    return false;
            }

            protected virtual object GetOrSetApiMember(object data, int memberEnum)
            {
                switch ((HudElementAccessors)memberEnum)
                {
                    case HudElementAccessors.GetType:
                        return GetType();
                    case HudElementAccessors.ZOffset:
                        return ZOffset;
                    case HudElementAccessors.FullZOffset:
                        return layerData.fullZOffset;
                    case HudElementAccessors.Position:
                        return Vector2.Zero;
                    case HudElementAccessors.Size:
                        return Vector2.Zero;
                    case HudElementAccessors.GetHudSpaceFunc:
                        return HudSpace?.GetHudSpaceFunc;
                    case HudElementAccessors.ModName:
                        return ExceptionHandler.ModName;
                    case HudElementAccessors.LocalCursorPos:
                        return HudSpace?.CursorPos ?? Vector3.Zero;
                    case HudElementAccessors.PlaneToWorld:
                        return HudSpace?.PlaneToWorldRef[0] ?? default(MatrixD);
                    case HudElementAccessors.IsInFront:
                        return HudSpace?.IsInFront ?? false;
                    case HudElementAccessors.IsFacingCamera:
                        return HudSpace?.IsFacingCamera ?? false;
                    case HudElementAccessors.NodeOrigin:
                        return HudSpace?.PlaneToWorldRef[0].Translation ?? Vector3D.Zero;
                }

                return null;
            }
        }
    }
}﻿using Sandbox.ModAPI;
using System;
using VRage;
using VRage.ModAPI;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    namespace UI
    {
        using Client;
        using Server;
        using System.Collections.Generic;
        using HudUpdateAccessors = MyTuple<
            ApiMemberAccessor,
            MyTuple<Func<ushort>, Func<Vector3D>>, // ZOffset + GetOrigin
            Action, // DepthTest
            Action, // HandleInput
            Action<bool>, // BeforeLayout
            Action // BeforeDraw
        >;

        /// <summary>
        /// Base class for hud nodes used to replace standard Pixel to World matrix with an arbitrary
        /// world matrix transform.
        /// </summary>
        public abstract class HudSpaceNodeBase : HudNodeBase, IReadOnlyHudSpaceNode
        {
            protected const HudElementStates spaceNodeVisible = HudElementStates.IsVisible | HudElementStates.WasParentVisible;

            /// <summary>
            /// Node defining the coordinate space used to render the UI element
            /// </summary>
            public override IReadOnlyHudSpaceNode HudSpace => this;

            /// <summary>
            /// Returns true if the space node is visible and rendering.
            /// </summary>
            public override bool Visible => (State & spaceNodeVisible) == spaceNodeVisible;

            /// <summary>
            /// Returns the current draw matrix
            /// </summary>
            public MatrixD PlaneToWorld => PlaneToWorldRef[0];

            /// <summary>
            /// Returns the current draw matrix by reference as an array of length 1
            /// </summary>
            public MatrixD[] PlaneToWorldRef { get; }

            /// <summary>
            /// Cursor position on the XY plane defined by the HUD space. Z == dist from screen.
            /// </summary>
            public Vector3 CursorPos { get; protected set; }

            /// <summary>
            /// Delegate used to retrieve current hud space. Used with cursor.
            /// </summary>
            public HudSpaceDelegate GetHudSpaceFunc { get; protected set; }

            /// <summary>
            /// Returns the world space position of the node's origin.
            /// </summary>
            public Func<Vector3D> GetNodeOriginFunc { get; protected set; }

            /// <summary>
            /// True if the origin of the HUD space is in front of the camera
            /// </summary>
            public bool IsInFront { get; protected set; }

            /// <summary>
            /// True if the XY plane of the HUD space is in front and facing toward the camera
            /// </summary>
            public bool IsFacingCamera { get; protected set; }

            public HudSpaceNodeBase(HudParentBase parent = null) : base(parent)
            {
                GetHudSpaceFunc = () => new MyTuple<bool, float, MatrixD>(false, 1f, PlaneToWorldRef[0]);
                GetNodeOriginFunc = () => PlaneToWorldRef[0].Translation;
                PlaneToWorldRef = new MatrixD[1];
            }

            protected override void Layout()
            {
                // Determine whether the node is in front of the camera and pointed toward it
                MatrixD camMatrix = MyAPIGateway.Session.Camera.WorldMatrix;
                Vector3D camOrigin = camMatrix.Translation,
                    camForward = camMatrix.Forward,
                    nodeOrigin = PlaneToWorldRef[0].Translation,
                    nodeForward = PlaneToWorldRef[0].Forward;

                IsInFront = Vector3D.Dot((nodeOrigin - camOrigin), camForward) > 0;
                IsFacingCamera = IsInFront && Vector3D.Dot(nodeForward, camForward) > 0;

                MatrixD worldToPlane;
                MatrixD.Invert(ref PlaneToWorldRef[0], out worldToPlane);
                LineD cursorLine = HudMain.Cursor.WorldLine;

                PlaneD plane = new PlaneD(PlaneToWorldRef[0].Translation, PlaneToWorldRef[0].Forward);
                Vector3D worldPos = plane.Intersection(ref cursorLine.From, ref cursorLine.Direction);

                Vector3D planePos;
                Vector3D.TransformNoProjection(ref worldPos, ref worldToPlane, out planePos);

                CursorPos = new Vector3()
                {
                    X = (float)planePos.X,
                    Y = (float)planePos.Y,
                    Z = (float)Math.Round(Vector3D.DistanceSquared(worldPos, cursorLine.From), 6)
                };
            }

            public override void GetUpdateAccessors(List<HudUpdateAccessors> UpdateActions, byte preloadDepth)
            {
                layerData.fullZOffset = ParentUtils.GetFullZOffset(layerData, _parent);
                UpdateActions.EnsureCapacity(UpdateActions.Count + children.Count + 1);
                accessorDelegates.Item2.Item2 = GetNodeOriginFunc;

                UpdateActions.Add(accessorDelegates);

                if (Visible && IsInFront)
                {
                    for (int n = 0; n < children.Count; n++)
                        children[n].GetUpdateAccessors(UpdateActions, preloadDepth);
                }
            }
        }
    }
}
﻿using System;
using VRage;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        using Client;
        using Server;

        /// <summary>
        /// Base type for hud elements that have text elements and a <see cref="TexturedBox"/> background.
        /// </summary>
        public abstract class LabelBoxBase : HudElementBase
        {
            /// <summary>
            /// Size of the text element sans padding.
            /// </summary>
            public abstract Vector2 TextSize { get; set; }

            /// <summary>
            /// Padding applied to the text element.
            /// </summary>
            public abstract Vector2 TextPadding { get; set; }

            /// <summary>
            /// Determines whether or not the text box can be resized manually.
            /// </summary>
            public abstract bool AutoResize { get; set; }

            /// <summary>
            /// If true, then the background will resize to match the size of the text plus padding. Otherwise,
            /// size will be clamped such that the element will not be smaller than the text element.
            /// </summary>
            public bool FitToTextElement { get; set; }

            /// <summary>
            /// Background color
            /// </summary>
            public virtual Color Color { get { return background.Color; } set { background.Color = value; } }

            /// <summary>
            /// Label box background
            /// </summary>
            public readonly TexturedBox background;

            public override float Width
            {
                get { return FitToTextElement ? TextSize.X + Padding.X : (_size.X + Padding.X); }
                set
                {
                    if (!FitToTextElement)
                        value = MathHelper.Max(TextSize.X, value);

                    if (value > Padding.X)
                        value -= Padding.X;

                    if (FitToTextElement)
                        TextSize = new Vector2(value, TextSize.Y);
                    else
                        base.Width = value;
                }
            }

            public override float Height
            {
                get { return FitToTextElement ? TextSize.Y + Padding.Y : (_size.Y + Padding.Y); }
                set
                {
                    if (!FitToTextElement)
                        value = MathHelper.Max(TextSize.Y, value);

                    if (value > Padding.Y)
                        value -= Padding.Y;

                    if (FitToTextElement)
                        TextSize = new Vector2(TextSize.X, value);
                    else
                        base.Height = value;
                }
            }

            public LabelBoxBase(HudParentBase parent) : base(parent)
            {
                background = new TexturedBox(this)
                {
                    DimAlignment = DimAlignments.Both | DimAlignments.IgnorePadding,
                };

                FitToTextElement = true;
                Color = Color.Gray;
            }

            protected override void Layout()
            {
                // The element may not be smaller than the text
                if (!FitToTextElement)
                {
                    _size = Vector2.Max(TextSize, _size);
                }
            }
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using VRage;
using VRageMath;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    namespace UI
    {
        public abstract class LabelElementBase : HudElementBase, IMinLabelElement
        {
            /// <summary>
            /// TextBoard backing the label element.
            /// </summary>
            public abstract ITextBoard TextBoard { get; }

            public LabelElementBase(HudParentBase parent = null) : base(parent)
            { }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        public abstract partial class HudNodeBase
        {
            /// <summary>
            /// Collection of utilities used internally to manage HUD nodes
            /// </summary>
            protected static class NodeUtils
            {
                /// <summary>
                /// Used internally quickly register a list of child nodes to a parent.
                /// </summary>
                public static void RegisterNodes(HudParentBase newParent, List<HudNodeBase> children, IReadOnlyList<HudNodeBase> nodes, bool canPreload)
                {
                    children.EnsureCapacity(children.Count + nodes.Count);

                    for (int n = 0; n < nodes.Count; n++)
                    {
                        HudNodeBase node = nodes[n];
                        node.Parent = newParent;
                        node.State |= HudElementStates.IsRegistered;
                        node.ParentVisible = newParent.Visible;

                        children.Add(node);

                        if (canPreload)
                            node.State |= HudElementStates.CanPreload;
                        else
                            node.State &= ~HudElementStates.CanPreload;
                    }
                }

                /// <summary>
                /// Used internally quickly register a list of child nodes to a parent.
                /// </summary>
                public static void RegisterNodes<TCon, TNode>(HudParentBase newParent, List<HudNodeBase> children, IReadOnlyList<TCon> nodes, bool canPreload)
                    where TCon : IHudElementContainer<TNode>, new()
                    where TNode : HudNodeBase
                {
                    children.EnsureCapacity(children.Count + nodes.Count);

                    for (int n = 0; n < nodes.Count; n++)
                    {
                        HudNodeBase node = nodes[n].Element;
                        node.Parent = newParent;
                        node.State |= HudElementStates.IsRegistered;
                        node.ParentVisible = newParent.Visible;

                        children.Add(node);

                        if (canPreload)
                            node.State |= HudElementStates.CanPreload;
                        else
                            node.State &= ~HudElementStates.CanPreload;
                    }
                }

                /// <summary>
                /// Used internally to quickly unregister child nodes from their parent. Removes the range of nodes
                /// specified in the node list from the child list.
                /// </summary>
                public static void UnregisterNodes(HudParentBase parent, List<HudNodeBase> children, IReadOnlyList<HudNodeBase> nodes, int index, int count)
                {
                    if (count > 0)
                    {
                        int conEnd = index + count - 1;

                        if (!(index >= 0 && index < nodes.Count && conEnd <= nodes.Count))
                            throw new Exception("Specified indices are out of range.");

                        if (parent == null)
                            throw new Exception("Parent cannot be null");

                        for (int i = index; i <= conEnd; i++)
                        {
                            int start = 0;

                            while (start < children.Count && children[start] != nodes[i])
                                start++;

                            if (children[start] == nodes[i])
                            {
                                int j = start, end = start;

                                while (j < children.Count && i <= conEnd && children[j] == nodes[i])
                                {
                                    end = j;
                                    i++;
                                    j++;
                                }

                                children.RemoveRange(start, end - start + 1);
                            }
                        }

                        for (int n = index; n < count; n++)
                        {
                            HudNodeBase node = nodes[n];
                            HudParentBase nodeParent = node._parent;

                            if (nodeParent != parent)
                                throw new Exception("The child node specified is not registered to the parent given.");

                            node.Parent = null;
                            node.State &= ~(HudElementStates.IsRegistered | HudElementStates.WasParentVisible);
                            node.ParentVisible = false;
                        }
                    }
                }

                /// <summary>
                /// Used internally to quickly unregister child nodes from their parent. Removes the range of nodes
                /// specified in the node list from the child list.
                /// </summary>
                public static void UnregisterNodes<TCon, TNode>(HudParentBase parent, List<HudNodeBase> children, IReadOnlyList<TCon> nodes, int index, int count)
                    where TCon : IHudElementContainer<TNode>, new()
                    where TNode : HudNodeBase
                {
                    if (count > 0)
                    {
                        int conEnd = index + count - 1;

                        if (!(index >= 0 && index < nodes.Count && conEnd <= nodes.Count))
                            throw new Exception("Specified indices are out of range.");

                        if (parent == null)
                            throw new Exception("Parent cannot be null");

                        for (int i = index; i <= conEnd; i++)
                        {
                            int start = 0;

                            while (start < children.Count && children[start] != nodes[i].Element)
                                start++;

                            if (children[start] == nodes[i].Element)
                            {
                                int j = start, end = start;

                                while (j < children.Count && i <= conEnd && children[j] == nodes[i].Element)
                                {
                                    end = j;
                                    i++;
                                    j++;
                                }

                                children.RemoveRange(start, end - start + 1);
                            }
                        }

                        for (int n = index; n < count; n++)
                        {
                            HudNodeBase node = nodes[n].Element;
                            HudParentBase nodeParent = node._parent;

                            if (nodeParent != parent)
                                throw new Exception("The child node specified is not registered to the parent given.");

                            node.Parent = null;
                            node.State &= ~(HudElementStates.IsRegistered | HudElementStates.WasParentVisible);
                        }
                    }
                }

                /// <summary>
                /// Used internally to modify the state of hud nodes
                /// </summary>
                public static void SetNodesState(HudElementStates state, bool mask, IReadOnlyList<HudNodeBase> nodes, int index, int count)
                {
                    if (count > 0)
                    {
                        int end = index + count - 1;
                        Utils.Debug.Assert(index >= 0 && end < nodes.Count, $"Range out of bounds. Index: {index}, End: {end}");

                        if (mask)
                        {
                            for (int i = index; i <= end; i++)
                                nodes[i].State &= ~state;
                        }
                        else
                        {
                            for (int i = index; i <= end; i++)
                                nodes[i].State |= state;
                        }
                    }
                }

                /// <summary>
                /// Used internally to modify the state of hud nodes
                /// </summary>
                public static void SetNodesState<TCon, TNode>(HudElementStates state, bool mask, IReadOnlyList<TCon> nodes, int index, int count)
                    where TCon : IHudElementContainer<TNode>, new()
                    where TNode : HudNodeBase
                {
                    if (count > 0)
                    {
                        int end = index + count - 1;
                        Utils.Debug.Assert(index >= 0 && end < nodes.Count, $"Range out of bounds. Index: {index}, End: {end}");

                        if (mask)
                        {
                            for (int i = index; i <= end; i++)
                                nodes[i].Element.State &= ~state;
                        }
                        else
                        {
                            for (int i = index; i <= end; i++)
                                nodes[i].Element.State |= state;
                        }
                    }
                }
            }
        }
    }
}﻿using System;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        public abstract partial class HudParentBase
        {
            /// <summary>
            /// Utilities used internally to access parent node members
            /// </summary>
            protected static class ParentUtils
            {
                /// <summary>
                /// Calculates the full z-offset using the public offset and inner offset.
                /// </summary>
                public static ushort GetFullZOffset(HudLayerData nodeData, HudParentBase parent = null)
                {
                    byte outerOffset = (byte)(nodeData.zOffset - sbyte.MinValue);
                    ushort innerOffset = (ushort)(nodeData.zOffsetInner << 8);

                    if (parent != null)
                    {
                        ushort parentFull = parent.layerData.fullZOffset;

                        outerOffset += (byte)((parentFull & 0x00FF) + sbyte.MinValue);
                        innerOffset += (ushort)(parentFull & 0xFF00);
                    }

                    return (ushort)(innerOffset | outerOffset);
                }
            }
        }
    }
}﻿using System;
using VRageMath;
using RichHudFramework.UI.Rendering;
using RichHudFramework.Internal;

namespace RichHudFramework.UI
{
    using Client;
    using Server;

    /// <summary>
    /// Base type for HUD windows. Supports dragging/resizing like pretty much every other window ever.
    /// </summary>
    public abstract class WindowBase : HudElementBase, IClickableElement
    {
        /// <summary>
        /// Window header text
        /// </summary>
        public RichText HeaderText { get { return HeaderBuilder.GetText(); } set { HeaderBuilder.SetText(value); } }

        /// <summary>
        /// Text builder for the window header
        /// </summary>
        public ITextBuilder HeaderBuilder => header.TextBoard;

        /// <summary>
        /// Determines the color of both the header and the border.
        /// </summary>
        public virtual Color BorderColor
        {
            get { return header.Color; }
            set
            {
                header.Color = value;
                border.Color = value;
            }
        }

        /// <summary>
        /// Determines the color of the body of the window.
        /// </summary>
        public virtual Color BodyColor { get { return bodyBg.Color; } set { bodyBg.Color = value; } }

        /// <summary>
        /// Minimum allowable size for the window.
        /// </summary>
        public Vector2 MinimumSize { get { return minimumSize; } set { minimumSize = value; } }

        /// <summary>
        /// Determines whether or not the window can be resized by the user
        /// </summary>
        public bool AllowResizing { get; set; }

        /// <summary>
        /// Determines whether or not the user can reposition the window
        /// </summary>
        public bool CanDrag { get; set; }

        /// <summary>
        /// Returns true if the window has focus and is accepting input
        /// </summary>
        public bool WindowActive { get; protected set; }

        /// <summary>
        /// Returns true if the cursor is over the window
        /// </summary>
        public override bool IsMousedOver => resizeInput.IsMousedOver;

        /// <summary>
        /// Mouse input element for the window
        /// </summary>
        public IMouseInput MouseInput => resizeInput;

        /// <summary>
        /// Window header element
        /// </summary>
        public readonly LabelBoxButton header;

        /// <summary>
        /// Textured background. Body of the window
        /// </summary>
        public readonly HudElementBase body;

        /// <summary>
        /// Window border
        /// </summary>
        public readonly BorderBox border;

        protected readonly MouseInputElement inputInner, resizeInput;
        protected readonly TexturedBox bodyBg;

        protected readonly Action<byte> LoseFocusCallback;
        protected float cornerSize = 16f;
        protected bool canMoveWindow, canResize;
        protected int resizeDir;
        protected Vector2 cursorOffset, minimumSize;

        public WindowBase(HudParentBase parent) : base(parent)
        {
            header = new LabelBoxButton(this)
            {
                DimAlignment = DimAlignments.Width,
                Height = 32f,
                ParentAlignment = ParentAlignments.Top | ParentAlignments.Inner,
                ZOffset = 1,
                Format = GlyphFormat.White.WithAlignment(TextAlignment.Center),
                HighlightEnabled = false,
                AutoResize = false,
            };

            body = new EmptyHudElement(header)
            {
                DimAlignment = DimAlignments.Width,
                ParentAlignment = ParentAlignments.Bottom,
            };

            bodyBg = new TexturedBox(body)
            {
                DimAlignment = DimAlignments.Both | DimAlignments.IgnorePadding,
                ZOffset = -2,
            };

            border = new BorderBox(this)
            {
                ZOffset = 1,
                Thickness = 1f,
                DimAlignment = DimAlignments.Both,
            };

            resizeInput = new MouseInputElement(this)
            {
                ZOffset = sbyte.MaxValue,
                Padding = new Vector2(16f),
                DimAlignment = DimAlignments.Both,
                CanIgnoreMasking = true
            };
            
            inputInner = new MouseInputElement(resizeInput)
            {
                DimAlignment = DimAlignments.Both | DimAlignments.IgnorePadding,
            };

            AllowResizing = true;
            CanDrag = true;
            UseCursor = true;
            ShareCursor = false;
            IsMasking = true;
            MinimumSize = new Vector2(200f, 200f);

            LoseFocusCallback = LoseFocus;
            GetFocus();
        }

        protected override void Layout()
        {
            body.Height = Height - header.Height;

            if (Visible && WindowActive)
            {
                if (canMoveWindow)
                {
                    Vector3 cursorPos = HudSpace.CursorPos;
                    Offset = new Vector2(cursorPos.X, cursorPos.Y) + cursorOffset - Origin;
                }

                if (canResize)
                    Resize();
            }
            else
            {
                canMoveWindow = false;
                canResize = false;
            }
        }

        protected void Resize()
        {
            Vector3 cursorPos = HudSpace.CursorPos;
            Vector2 center = Origin + Offset, newOffset = Offset;
            float newWidth, newHeight;

            // 1 == horizontal, 3 == both
            if (resizeDir == 1 || resizeDir == 3)
            {
                newWidth = Math.Abs(newOffset.X - cursorPos.X) + Width * .5f;

                if (newWidth >= MinimumSize.X)
                {
                    Width = newWidth;

                    if (cursorPos.X > center.X)
                        newOffset.X = cursorPos.X - Width * .5f;
                    else
                        newOffset.X = cursorPos.X + Width * .5f;
                }
            }

            // 2 == vertical
            if (resizeDir == 2 || resizeDir == 3)
            {
                newHeight = Math.Abs(newOffset.Y - cursorPos.Y) + Height * .5f;

                if (newHeight >= MinimumSize.Y)
                {
                    Height = newHeight;

                    if (cursorPos.Y > center.Y)
                        newOffset.Y = cursorPos.Y - Height * .5f;
                    else
                        newOffset.Y = cursorPos.Y + Height * .5f;
                }
            }

            Offset = newOffset;
        }

        protected override void HandleInput(Vector2 cursorPos)
        {
            if (IsMousedOver)
            {
                if (SharedBinds.LeftButton.IsNewPressed && !WindowActive)
                    GetFocus();
            }

            if (AllowResizing && resizeInput.IsNewLeftClicked && !inputInner.IsMousedOver)
            {
                Vector2 pos = Origin + Offset;
                canResize = true;
                resizeDir = 0;

                if (Width - (2f) * Math.Abs(pos.X - cursorPos.X) <= cornerSize)
                    resizeDir += 1;

                if (Height - (2f) * Math.Abs(pos.Y - cursorPos.Y) <= cornerSize)
                    resizeDir += 2;
            }
            else if (CanDrag && header.MouseInput.IsNewLeftClicked)
            {
                canMoveWindow = true;
                cursorOffset = (Origin + Offset) - cursorPos;
            }

            if (canResize || canMoveWindow)
            {
                if (!SharedBinds.LeftButton.IsPressed)
                {
                    canMoveWindow = false;
                    canResize = false;
                }
            }
        }

        /// <summary>
        /// Brings the window into the foreground
        /// </summary>
        public virtual void GetFocus()
        {
            layerData.zOffsetInner = HudMain.GetFocusOffset(LoseFocusCallback);
            WindowActive = true;
        }

        protected virtual void LoseFocus(byte newOffset)
        {
            layerData.zOffsetInner = newOffset;
            WindowActive = false;
        }
    }
}﻿using System;
using VRage;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Interface for mouse input of a UI element.
        /// </summary>
        public interface IMouseInput
        {
            /// <summary>
            /// Invoked when the cursor enters the element's bounds
            /// </summary>
            event EventHandler CursorEntered;

            /// <summary>
            /// Invoked when the cursor leaves the element's bounds
            /// </summary>
            event EventHandler CursorExited;

            /// <summary>
            /// Invoked when the element is clicked with the left mouse button
            /// </summary>
            event EventHandler LeftClicked;

            /// <summary>
            /// Invoked when the left click is released
            /// </summary>
            event EventHandler LeftReleased;

            /// <summary>
            /// Invoked when the element is clicked with the right mouse button
            /// </summary>
            event EventHandler RightClicked;

            /// <summary>
            /// Invoked when the right click is released
            /// </summary>
            event EventHandler RightReleased;

            /// <summary>
            /// Invoked when taking focus
            /// </summary>
            event EventHandler GainedInputFocus;

            /// <summary>
            /// Invoked when focus is lost
            /// </summary>
            event EventHandler LostInputFocus;

            /// <summary>
            /// Determines whether the input element is enabled and accepting input
            /// </summary>
            bool InputEnabled { get; set; }

            /// <summary>
            /// True if the element is being clicked with the left mouse button
            /// </summary>
            bool IsLeftClicked { get; }

            /// <summary>
            /// True if the element is being clicked with the right mouse button
            /// </summary>
            bool IsRightClicked { get; }

            /// <summary>
            /// True if the element was just clicked with the left mouse button
            /// </summary>
            bool IsNewLeftClicked { get; }

            /// <summary>
            /// True if the element was just clicked with the right mouse button
            /// </summary>
            bool IsNewRightClicked { get; }

            /// <summary>
            /// True if the element was just released after being left clicked
            /// </summary>
            bool IsLeftReleased { get; }

            /// <summary>
            /// True if the element was just released after being right clicked
            /// </summary>
            bool IsRightReleased { get; }

            /// <summary>
            /// Indicates whether or not the cursor is currently over this element.
            /// </summary>
            bool HasFocus { get; }

            /// <summary>
            /// Returns true if the element is moused over
            /// </summary>
            bool IsMousedOver { get; }

            /// <summary>
            /// Gets input focus for keyboard controls. Input focus normally taken when an
            /// element with mouse input is clicked.
            /// </summary>
            void GetInputFocus();

            /// <summary>
            /// Clears all subscribers to mouse input events.
            /// </summary>
            void ClearSubscribers();
        }

        public interface IClickableElement : IReadOnlyHudElement
        {
            IMouseInput MouseInput { get; }
        }
    }
}﻿using System.Text;
using VRage;
using System.Collections.Generic;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework.UI
{
    /// <summary>
    /// An interface for clickable UI elements that represent of ListBoxEntry elements.
    /// </summary>
    public interface IEntryBox<TContainer, TElement> : IEnumerable<TContainer>, IReadOnlyHudElement
        where TContainer : IScrollBoxEntry<TElement>, new()
        where TElement : HudElementBase, IMinLabelElement
    {
        /// <summary>
        /// Invoked when a member of the list is selected.
        /// </summary>
        event EventHandler SelectionChanged;

        /// <summary>
        /// Read-only collection of list entries.
        /// </summary>
        IReadOnlyList<TContainer> EntryList { get; }

        /// <summary>
        /// Current selection. Null if empty.
        /// </summary>
        TContainer Selection { get; }
    }

    public interface IEntryBox<TValue> : IEntryBox<ListBoxEntry<TValue>, Label>
    { }
}﻿using System;
using System.Collections.Generic;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Read-only interface for UI elements that support child elments using containers.
        /// </summary>
        public interface IReadOnlyHudCollection<TElementContainer, TElement> : IReadOnlyList<TElementContainer>
            where TElementContainer : IHudElementContainer<TElement>, new()
            where TElement : HudNodeBase
        {
            /// <summary>
            /// UI elements in the collection
            /// </summary>
            IReadOnlyList<TElementContainer> Collection { get; }

            /// <summary>
            /// Finds the collection member that meets the conditions required by the predicate.
            /// </summary>
            TElementContainer Find(Func<TElementContainer, bool> predicate);

            /// <summary>
            /// Finds the index of the collection member that meets the conditions required by the predicate.
            /// </summary>
            int FindIndex(Func<TElementContainer, bool> predicate);
        }

        /// <summary>
        /// Read-only interface for UI elements that support child elments using containers.
        /// </summary>
        public interface IReadOnlyHudCollection<TElementContainer> : IReadOnlyHudCollection<TElementContainer, HudElementBase>
            where TElementContainer : IHudElementContainer<HudElementBase>, new()
        { }

        /// <summary>
        /// Read-only interface for UI elements that support child elments using containers.
        /// </summary>
        public interface IReadOnlyHudCollection : IReadOnlyHudCollection<HudElementContainer<HudElementBase>, HudElementBase>
        { }

        /// <summary>
        /// Interface for UI elements that support child elments using containers.
        /// </summary>
        public interface IHudCollection<TElementContainer, TElement> : IReadOnlyHudCollection<TElementContainer, TElement>
            where TElementContainer : IHudElementContainer<TElement>, new()
            where TElement : HudNodeBase
        {
            /// <summary>
            /// Adds an element of type <see cref="TElement"/> to the collection.
            /// </summary>
            void Add(TElement element, bool preload = false);

            /// <summary>
            /// Adds an element of type <see cref="TElementContainer"/> to the collection.
            /// </summary>
            void Add(TElementContainer element, bool preload = false);

            /// <summary>
            /// Add the given range to the end of the collection.
            /// </summary>
            void AddRange(IReadOnlyList<TElementContainer> newContainers, bool preload = false);

            /// <summary>
            /// Adds an element of type <see cref="TElementContainer"/> at the given index.
            /// </summary>
            void Insert(int index, TElementContainer container, bool preload = false);

            /// <summary>
            /// Insert the given range into the collection.
            /// </summary>
            void InsertRange(int index, IReadOnlyList<TElementContainer> newContainers, bool preload = false);

            /// <summary>
            /// Removes the specified element from the collection.
            /// </summary>
            bool Remove(TElementContainer collectionElement);

            /// <summary>
            /// Removes the collection member that meets the conditions required by the predicate.
            /// </summary>
            bool Remove(Func<TElementContainer, bool> predicate);

            /// <summary>
            /// Remove the collection element at the given index.
            /// </summary>
            bool RemoveAt(int index);

            /// <summary>
            /// Removes the specfied range from the collection. Normal child elements not affected.
            /// </summary>
            void RemoveRange(int index, int count);

            /// <summary>
            /// Remove all elements in the collection. Does not affect normal child elements.
            /// </summary>
            void Clear();
        }

        /// <summary>
        /// Interface for UI elements that support child elments using containers.
        /// </summary>
        public interface IHudCollection<TElementContainer> : IHudCollection<TElementContainer, HudElementBase>
            where TElementContainer : IHudElementContainer<HudElementBase>, new()
        { }

        /// <summary>
        /// Interface for UI elements that support child elments using containers.
        /// </summary>
        public interface IHudCollection : IHudCollection<HudElementContainer<HudElementBase>, HudElementBase>
        { }
    }
}
﻿namespace RichHudFramework.UI
{
    using Rendering;

    public interface IMinLabelElement
    {
        /// <summary>
        /// TextBoard backing the label element.
        /// </summary>
        ITextBoard TextBoard { get; }
    }

    public interface ILabelElement : IMinLabelElement
    {
        /// <summary>
        /// Text rendered by the label.
        /// </summary>
        RichText Text { get; set; }

        /// <summary>
        /// Default formatting used by the label.
        /// </summary>
        GlyphFormat Format { get; set; }

        /// <summary>
        /// Line formatting mode used by the label.
        /// </summary>
        TextBuilderModes BuilderMode { get; set; }

        /// <summary>
        /// If true, the element will automatically resize to fit the text.
        /// </summary>
        bool AutoResize { get; set; }

        /// <summary>
        /// If true, the text will be vertically centered.
        /// </summary>
        bool VertCenterText { get; set; }

        float Height { get; set; }

        float Width { get; set; }
    }
}
﻿using System;
using VRage;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Read-only interface for hud elements with definite size and position.
        /// </summary>
        public interface IReadOnlyHudElement : IReadOnlyHudNode
        {
            /// <summary>
            /// Size of the element. Units in pixels by default.
            /// </summary>
            Vector2 Size { get; }

            /// <summary>
            /// Height of the hud element. Units in pixels by default.
            /// </summary>
            float Height { get; }

            /// <summary>
            /// Width of the hud element. Units in pixels by default.
            /// </summary>
            float Width { get; }

            /// <summary>
            /// Starting position of the hud element on the screen in pixels.
            /// </summary>
            Vector2 Origin { get; }

            /// <summary>
            /// Position of the hud element relative to its origin.
            /// </summary>
            Vector2 Offset { get; }

            /// <summary>
            /// Determines the starting position of the hud element relative to its parent.
            /// </summary>
            ParentAlignments ParentAlignment { get; }

            /// <summary>
            /// Determines how/if an element will copy its parent's dimensions. 
            /// </summary>
            DimAlignments DimAlignment { get; }

            /// <summary>
            /// If set to true the hud element will be allowed to capture the cursor.
            /// </summary>
            bool UseCursor { get; }

            /// <summary>
            /// If set to true the hud element will share the cursor with its child elements.
            /// </summary>
            bool ShareCursor { get; }

            /// <summary>
            /// Indicates whether or not the cursor is currently over the element. The element must
            /// be set to capture the cursor for this to work.
            /// </summary>
            bool IsMousedOver { get; }
        }
    }
}﻿namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Read-only interface for hud elements that can be parented to another element.
        /// </summary>
        public interface IReadOnlyHudNode : IReadOnlyHudParent
        {
            /// <summary>
            /// Parent object of the node.
            /// </summary>
            IReadOnlyHudParent Parent { get; }

            /// <summary>
            /// Indicates whether or not the node has been registered to its parent.
            /// </summary>
            bool Registered { get; }
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        using HudUpdateAccessors = MyTuple<
            ApiMemberAccessor,
            MyTuple<Func<ushort>, Func<Vector3D>>, // ZOffset + GetOrigin
            Action, // DepthTest
            Action, // HandleInput
            Action<bool>, // BeforeLayout
            Action // BeforeDraw
        >;

        [Flags]
        public enum HudElementStates : ushort
        {
            None = 0x0,
            IsVisible = 0x1,
            WasParentVisible = 0x2,
            IsRegistered = 0x4,
            CanUseCursor = 0x10,
            CanShareCursor = 0x20,
            IsMousedOver = 0x40,
            IsMouseInBounds = 0x80,
            CanPreload = 0x100,
            IsMasked = 0x200,
            IsMasking = 0x400,
            IsSelectivelyMasked = 0x800,
            CanIgnoreMasking = 0x1000,
            IsInputEnabled = 0x2000,
            WasParentInputEnabled = 0x4000
        }

        public struct HudLayerData
        {
            public sbyte zOffset;

            /// <summary>
            /// Additional zOffset range used internally; primarily for determining window draw order.
            /// Don't use this unless you have a good reason for it.
            /// </summary>
            public byte zOffsetInner;

            public ushort fullZOffset;
        }

        public enum HudElementAccessors : int
        {
            /// <summary>
            /// out: string
            /// </summary>
            ModName = 0,

            /// <summary>
            /// out: System.Type
            /// </summary>
            GetType = 1,

            /// <summary>
            /// out: byte
            /// </summary>
            ZOffset = 2,

            /// <summary>
            /// out: ushort
            /// </summary>
            FullZOffset = 3,

            /// <summary>
            /// out: Vector2
            /// </summary>
            Position = 4,

            /// <summary>
            /// out: Vector2
            /// </summary>
            Size = 5,

            /// <summary>
            /// out: Vector3
            /// </summary>
            LocalCursorPos = 6,

            /// <summary>
            /// out: bool
            /// </summary>
            DrawCursorInHudSpace = 7,

            /// <summary>
            /// out: HudSpaceDelegate
            /// </summary>
            GetHudSpaceFunc = 8,

            /// <summary>
            /// out: Vector3D
            /// </summary>
            NodeOrigin = 9,

            /// <summary>
            /// out: MatrixD
            /// </summary>
            PlaneToWorld = 10,

            /// <summary>
            /// out: bool
            /// </summary>
            IsInFront = 11,

            /// <summary>
            /// out: bool
            /// </summary>
            IsFacingCamera = 12,
        }

        /// <summary>
        /// Read-only interface for types capable of serving as parent objects to <see cref="HudNodeBase"/>s.
        /// </summary>
        public interface IReadOnlyHudParent
        {
            /// <summary>
            /// Node defining the coordinate space used to render the UI element
            /// </summary>
            IReadOnlyHudSpaceNode HudSpace { get; }

            /// <summary>
            /// Returns true if the element can be drawn and/or accept input
            /// </summary>
            bool Visible { get; }

            /// <summary>
            /// Returns true if input is enabled can update
            /// </summary>
            bool InputEnabled { get; }

            /// <summary>
            /// Used to change the draw order of the UI element. Lower offsets place the element
            /// further in the background. Higher offsets draw later and on top.
            /// </summary>
            sbyte ZOffset { get; }

            /// <summary>
            /// Adds update delegates for members in the order dictated by the UI tree
            /// </summary>
            void GetUpdateAccessors(List<HudUpdateAccessors> UpdateActions, byte preloadDepth);
        }
    }
}﻿using System;
using VRage;
using VRageMath;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Interface for types used to define custom UI coordinate spaces
        /// </summary>
        public interface IReadOnlyHudSpaceNode : IReadOnlyHudParent
        {
            /// <summary>
            /// Cursor position on the XY plane defined by the HUD space. Z == dist from screen.
            /// </summary>
            Vector3 CursorPos { get; }

            /// <summary>
            /// Delegate used to retrieve current hud space. Used for cursor depth testing.
            /// </summary>
            HudSpaceDelegate GetHudSpaceFunc { get; }

            /// <summary>
            /// Returns the current draw matrix
            /// </summary>
            MatrixD PlaneToWorld { get; }

            /// <summary>
            /// Returns the current draw matrix by reference as an array of length 1
            /// </summary>
            MatrixD[] PlaneToWorldRef { get; }

            /// <summary>
            /// Returns the world space position of the node's origin.
            /// </summary>
            Func<Vector3D> GetNodeOriginFunc { get; }

            /// <summary>
            /// True if the origin of the HUD space is in front of the camera
            /// </summary>
            bool IsInFront { get; }

            /// <summary>
            /// True if the XY plane of the HUD space is in front and facing toward the camera
            /// </summary>
            bool IsFacingCamera { get; }
        }
    }
}
﻿using RichHudFramework.UI.Rendering;
using VRageMath;

namespace RichHudFramework.UI
{
    /// <summary>
    /// A textured frame. The default texture is just a plain color.
    /// </summary>
    public class BorderBox : HudElementBase
    {
        /// <summary>
        /// Material applied to the box.
        /// </summary>
        public Material Material { get { return hudBoard.Material; } set { hudBoard.Material = value; } }

        /// <summary>
        /// Determines how the material reacts to changes in element size/aspect ratio.
        /// </summary>
        public MaterialAlignment MatAlignment { get { return hudBoard.MatAlignment; } set { hudBoard.MatAlignment = value; } }

        /// <summary>
        /// Coloring applied to the material.
        /// </summary>
        public Color Color { get { return hudBoard.Color; } set { hudBoard.Color = value; } }

        /// <summary>
        /// Size of the border on all four sides in pixels.
        /// </summary>
        public float Thickness { get { return _thickness; } set { _thickness = value; } }

        private float _thickness;
        protected readonly MatBoard hudBoard;

        public BorderBox(HudParentBase parent) : base(parent)
        {
            hudBoard = new MatBoard();
            Thickness = 1f;
        }

        public BorderBox() : this(null)
        { }

        protected override void Draw()
        {
            if (Color.A > 0)
            {
                CroppedBox box = default(CroppedBox);
                box.mask = maskingBox;

                float thickness = _thickness, 
                    height = cachedSize.Y - cachedPadding.Y, 
                    width = cachedSize.X - cachedPadding.X;
                Vector2 halfSize, pos;

                // Left
                halfSize = new Vector2(thickness, height) * .5f;
                pos = cachedPosition + new Vector2((-width + thickness) * .5f, 0f);
                box.bounds = new BoundingBox2(pos - halfSize, pos + halfSize);
                hudBoard.Draw(ref box, HudSpace.PlaneToWorldRef);

                // Top
                halfSize = new Vector2(width, thickness) * .5f;
                pos = cachedPosition + new Vector2(0f, (height - thickness) * .5f);
                box.bounds = new BoundingBox2(pos - halfSize, pos + halfSize);
                hudBoard.Draw(ref box, HudSpace.PlaneToWorldRef);

                // Right
                halfSize = new Vector2(thickness, height) * .5f;
                pos = cachedPosition + new Vector2((width - thickness) * .5f, 0f);
                box.bounds = new BoundingBox2(pos - halfSize, pos + halfSize);
                hudBoard.Draw(ref box, HudSpace.PlaneToWorldRef);

                // Bottom
                halfSize = new Vector2(width, thickness) * .5f;
                pos = cachedPosition + new Vector2(0f, (-height + thickness) * .5f);
                box.bounds = new BoundingBox2(pos - halfSize, pos + halfSize);
                hudBoard.Draw(ref box, HudSpace.PlaneToWorldRef);
            }
        }
    }
}
﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// A bare HUD element that renders nothing, no graphics, no text.
    /// </summary>
    public class EmptyHudElement : HudElementBase
    {
        public EmptyHudElement(HudParentBase parent) : base(parent)
        { }

        public EmptyHudElement() : this(null)
        { }
    }
}﻿using System;
using VRage;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// Used to control sizing behavior of HudChain members and the containing chain element itself. The align axis
        /// is the axis chain elements are arranged on; the off axis is the other axis. When vertically aligned, Y is 
        /// the align axis and X is the off axis. Otherwise, it's reversed.
        /// </summary>
        public enum HudChainSizingModes : int
        {
            // Naming: [Clamp/Fit][Chain/Members][OffAxis/AlignAxis/Both]
            // Fit > Clamp

            // Chain Sizing

            /// <summary>
            /// In this mode, the size of the chain on it's off axis will be allowed to vary freely so long as it
            /// is large enough to contain its members on that axis.
            /// </summary>
            ClampChainOffAxis = 0x1,

            /// <summary>
            /// In this mode, the size of the chain on it's align axis will be allowed to vary freely so long as it
            /// is large enough to contain its members on that axis.
            /// </summary>
            ClampChainAlignAxis = 0x2,

            /// <summary>
            /// In this mode, the chain's size will be allowed to vary freely so long as it remains large enough
            /// to contain them.
            /// </summary>
            ClampChainBoth = ClampChainOffAxis | ClampChainAlignAxis,

            /// <summary>
            /// In this mode, the element will automatically shrink/expand to fit its contents on its off axis.
            /// Supercedes ClampChainOffAxis.
            /// </summary>
            FitChainOffAxis = 0x4,

            /// <summary>
            /// In this mode, the element will automatically shrink/expand to fit its contents on its align axis.
            /// Supercedes ClampChainAlignAxis.
            /// </summary>
            FitChainAlignAxis = 0x8,

            /// <summary>
            /// In this mode, the element will automatically shrink/expand to fit its contents.
            /// Supercedes ClampChainBoth.
            /// </summary>
            FitChainBoth = FitChainOffAxis | FitChainAlignAxis,

            // Member Sizing

            /// <summary>
            /// If this flag is set, then the size of chain members on the off axis will be clamped. 
            /// </summary>
            ClampMembersOffAxis = 0x10,

            /// <summary>
            /// If this flag is set, then the size of chain members on the align axis will be clamped. 
            /// </summary>
            ClampMembersAlignAxis = 0x20,

            /// <summary>
            /// In this mode, chain members will be clamped between the set min/max size on both axes. Superceeds FitToMembers.
            /// </summary>
            ClampMembersBoth = ClampMembersOffAxis | ClampMembersAlignAxis,

            /// <summary>
            /// If this flag is set, chain members will be automatically resized to fill the chain along the off axis. 
            /// Superceeds ClampMembersOffAxis.
            /// </summary>
            FitMembersOffAxis = 0x40,

            /// <summary>
            /// If this flag is set, then the size of chain members on the align axis will be set to the maximum size. 
            /// Superceeds ClampMembersAlignAxis.
            /// </summary>
            FitMembersAlignAxis = 0x80,

            /// <summary>
            /// In this mode, chain members will be set to the maximum size on both axes. Superceeds ClampMembersBoth.
            /// </summary>
            FitMembersBoth = FitMembersOffAxis | FitMembersAlignAxis,
        }

        /// <summary>
        /// HUD element used to organize other elements into straight lines, either horizontal or vertical. Min/Max size
        /// determines the minimum and maximum size of chain members.
        /// </summary>
        /*
         Rules:
            1) Chain members must fit inside the chain. How this is accomplished depends on the sizing mode.
            2) Members must be positioned within the chain's bounds.
            3) Members are assumed to be compatible with the specified sizing mode. Otherwise the behavior is undefined
            and incorrect positioning and sizing will occur.
        */
        public class HudChain<TElementContainer, TElement> : HudCollection<TElementContainer, TElement>
            where TElementContainer : IHudElementContainer<TElement>, new()
            where TElement : HudElementBase
        {
            protected const HudElementStates nodeSetVisible = HudElementStates.IsVisible | HudElementStates.IsRegistered;

            /// <summary>
            /// Width of the chain
            /// </summary>
            public override float Width
            {
                set
                {
                    if (value > Padding.X)
                        value -= Padding.X;

                    _size.X = value;

                    if (value > 0f && offAxis == 0 && (SizingMode & (HudChainSizingModes.ClampMembersOffAxis | HudChainSizingModes.FitMembersOffAxis)) > 0)
                        _absMaxSize.X = _size.X;
                }
            }

            /// <summary>
            /// Height of the chain
            /// </summary>
            public override float Height
            {
                set
                {
                    if (value > Padding.Y)
                        value -= Padding.Y;

                    _size.Y = value;

                    if (value > 0f && offAxis == 1 && (SizingMode & (HudChainSizingModes.ClampMembersOffAxis | HudChainSizingModes.FitMembersOffAxis)) > 0)
                        _absMaxSize.Y = _size.Y;
                }
            }

            /// <summary>
            /// Maximum chain member size. If no maximum is set, then the currently set size will be used as the maximum.
            /// </summary>
            public Vector2 MemberMaxSize { get { return _absMaxSize; } set { _absMaxSize = value; } }

            /// <summary>
            /// Minimum allowable member size.
            /// </summary>
            public Vector2 MemberMinSize { get { return _absMinSize; } set { _absMinSize = value; } }

            /// <summary>
            /// Distance between chain elements along their axis of alignment.
            /// </summary>
            public float Spacing { get { return _spacing; } set { _spacing = value; } }

            /// <summary>
            /// Determines how/if the chain will attempt to resize member elements. Default sizing mode is 
            /// HudChainSizingModes.FitChainBoth.
            /// </summary>
            public HudChainSizingModes SizingMode { get; set; }

            /// <summary>
            /// Determines whether or not chain elements will be aligned vertically.
            /// </summary>
            public virtual bool AlignVertical 
            { 
                get { return _alignVertical; }
                set 
                {
                    if (value)
                    {
                        alignAxis = 1;
                        offAxis = 0;
                    }
                    else
                    {
                        alignAxis = 0;
                        offAxis = 1;
                    }

                    _alignVertical = value;
                }
            }

            protected bool _alignVertical;
            protected float _spacing;
            protected int alignAxis, offAxis;
            protected Vector2 _absMaxSize, _absMinSize;

            public HudChain(bool alignVertical, HudParentBase parent = null) : base(parent)
            {
                Init();

                Spacing = 0f;
                SizingMode = HudChainSizingModes.FitChainBoth;
                AlignVertical = alignVertical;
            }

            public HudChain(HudParentBase parent) : this(false, parent)
            { }

            public HudChain() : this(false, null)
            { }

            /// <summary>
            /// Initialzer called before the constructor.
            /// </summary>
            protected virtual void Init() { }

            protected override void Layout()
            {
                UpdateMemberSizes();

                Vector2 visibleTotalSize = GetVisibleTotalSize(),
                    listSize = GetListSize(cachedSize - cachedPadding, visibleTotalSize);

                _size = listSize;

                // Calculate member start offset
                Vector2 startOffset = new Vector2();

                if (alignAxis == 1)
                    startOffset.Y = listSize.Y * .5f;
                else
                    startOffset.X = -listSize.X * .5f;

                UpdateMemberOffsets(startOffset, cachedPadding);
            }

            /// <summary>
            /// Updates chain member sizes to conform to sizing rules.
            /// </summary>
            protected void UpdateMemberSizes()
            {
                Vector2 newMax;
                _absMinSize = Vector2.Max(Vector2.Zero, _absMinSize);
                newMax = Vector2.Max(_absMinSize, _absMaxSize);
                _absMaxSize = newMax;

                Vector2 minSize = MemberMinSize,
                    maxSize = MemberMaxSize;

                for (int n = 0; n < hudCollectionList.Count; n++)
                {
                    TElement element = hudCollectionList[n].Element;
                    Vector2 elementSize = element.Size;

                    // Adjust element size based on sizing mode
                    if ((SizingMode & HudChainSizingModes.FitMembersOffAxis) > 0)
                        elementSize[offAxis] = maxSize[offAxis];
                    else if ((SizingMode & HudChainSizingModes.ClampMembersOffAxis) > 0)
                        elementSize[offAxis] = MathHelper.Clamp(elementSize[offAxis], minSize[offAxis], maxSize[offAxis]);

                    if ((SizingMode & HudChainSizingModes.FitMembersAlignAxis) > 0)
                        elementSize[alignAxis] = maxSize[alignAxis];
                    else if ((SizingMode & HudChainSizingModes.ClampMembersAlignAxis) > 0)
                        elementSize[alignAxis] = MathHelper.Clamp(elementSize[alignAxis], minSize[alignAxis], maxSize[alignAxis]);

                    element.Size = elementSize;
                }
            }

            /// <summary>
            /// Calculates the chain's current size based on its sizing mode and the total
            /// size of its members (less padding).
            /// </summary>
            protected Vector2 GetListSize(Vector2 lastSize, Vector2 totalSize)
            {
                if ((SizingMode & HudChainSizingModes.FitChainAlignAxis) > 0)
                {
                    lastSize[alignAxis] = totalSize[alignAxis];
                }
                else // if ClampChainAlignAxis
                {
                    lastSize[alignAxis] = Math.Max(lastSize[alignAxis], totalSize[alignAxis]);
                }

                if ((SizingMode & HudChainSizingModes.FitChainOffAxis) > 0)
                {
                    lastSize[offAxis] = totalSize[offAxis];
                }
                else // if ClampChainOffAxis
                {
                    lastSize[offAxis] = Math.Max(lastSize[offAxis], totalSize[offAxis]);
                }

                return lastSize;
            }

            /// <summary>
            /// Updates chain member offsets to ensure that they're in a straight line.
            /// </summary>
            protected void UpdateMemberOffsets(Vector2 offset, Vector2 padding)
            {
                Vector2 alignMask = new Vector2(offAxis, -alignAxis), offMask = new Vector2(alignAxis, -offAxis);
                ParentAlignments left = (ParentAlignments)((int)ParentAlignments.Left * (2 - alignAxis)),
                    right = (ParentAlignments)((int)ParentAlignments.Right * (2 - alignAxis)),
                    bitmask = left | right;
                float spacing = Spacing;

                for (int n = 0; n < hudCollectionList.Count; n++)
                {
                    TElement element = hudCollectionList[n].Element;

                    // Calculate element size
                    Vector2 elementSize = element.Size;

                    // Enforce alignment restrictions
                    element.ParentAlignment &= bitmask;
                    element.ParentAlignment |= ParentAlignments.Inner;

                    // Calculate element offset
                    Vector2 newOffset = offset + (elementSize * alignMask * .5f);

                    if ((element.ParentAlignment & left) == left)
                    {
                        newOffset += padding * offMask * .5f;
                    }
                    else if ((element.ParentAlignment & right) == right)
                    {
                        newOffset -= padding * offMask * .5f;
                    }

                    // Apply changes
                    element.Offset = newOffset;

                    if ((element.State & (nodeSetVisible)) == nodeSetVisible)
                    {
                        // Move offset down for the next element
                        elementSize[alignAxis] += spacing;
                        offset += elementSize * alignMask;
                    }
                }
            }

            /// <summary>
            /// Calculates the total size of all visible elements in the chain, including spacing and
            /// any resizing that might be required.
            /// </summary>
            protected virtual Vector2 GetVisibleTotalSize()
            {
                Vector2 newSize = new Vector2();
                float spacing = Spacing;

                for (int n = 0; n < hudCollectionList.Count; n++)
                {
                    TElement element = hudCollectionList[n].Element;
                    
                    if ((element.State & (nodeSetVisible)) == nodeSetVisible)
                    {
                        Vector2 elementSize = element.Size;

                        // Total up the size of elements on the axis of alignment
                        newSize[alignAxis] += elementSize[alignAxis];

                        // Find largest element on the off axis
                        if (elementSize[offAxis] > newSize[offAxis])
                            newSize[offAxis] = elementSize[offAxis];

                        newSize[alignAxis] += spacing;
                    }
                }

                newSize[alignAxis] -= spacing;
                return Vector2.Max(newSize, Vector2.Zero);
            }
        }

        /// <summary>
        /// HUD element used to organize other elements into straight lines, either horizontal or vertical. Min/Max size
        /// determines the minimum and maximum size of chain members.
        /// </summary>
        public class HudChain<TElementContainer> : HudChain<TElementContainer, HudElementBase>
            where TElementContainer : IHudElementContainer<HudElementBase>, new()
        {
            public HudChain(bool alignVertical, HudParentBase parent = null) : base(alignVertical, parent)
            { }
        }

        /// <summary>
        /// HUD element used to organize other elements into straight lines, either horizontal or vertical. Min/Max size
        /// determines the minimum and maximum size of chain members.
        /// </summary>
        public class HudChain : HudChain<HudElementContainer<HudElementBase>, HudElementBase>
        {
            public HudChain(bool alignVertical, HudParentBase parent = null) : base(alignVertical, parent)
            { }
        }
    }
}
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    using UI.Server;

    namespace UI
    {
        /// <summary>
        /// A collection of UI elements wrapped in container objects. UI elements in the containers are parented
        /// to the collection, like any other HUD element.
        /// </summary>
        public class HudCollection<TElementContainer, TElement> : HudElementBase, IHudCollection<TElementContainer, TElement>
            where TElementContainer : IHudElementContainer<TElement>, new()
            where TElement : HudNodeBase
        {
            /// <summary>
            /// UI elements in the collection
            /// </summary>
            public IReadOnlyList<TElementContainer> Collection => hudCollectionList;

            /// <summary>
            /// Used to allow the addition of child elements using collection-initializer syntax in
            /// conjunction with normal initializers.
            /// </summary>
            public HudCollection<TElementContainer, TElement> CollectionContainer => this;

            /// <summary>
            /// Retrieves the element container at the given index.
            /// </summary>
            public TElementContainer this[int index]
            {
                get
                {
                    if (hudCollectionList.Count == 0 || index < 0 || index >= hudCollectionList.Count)
                        throw new Exception($"Collection index out of range. Index: {index} Count: {hudCollectionList.Count}");

                    return hudCollectionList[index];
                }
            }

            /// <summary>
            /// Returns the number of containers in the collection.
            /// </summary>
            int IReadOnlyCollection<TElementContainer>.Count => hudCollectionList.Count;

            /// <summary>
            /// Returns the number of containers in the collection.
            /// </summary>
            public int Count => hudCollectionList.Count;

            /// <summary>
            /// Indicates whether the collection is read-only
            /// </summary>
            public bool IsReadOnly => false;

            /// <summary>
            /// UI elements in the chain
            /// </summary>
            protected readonly List<TElementContainer> hudCollectionList;

            /// <summary>
            /// Used internally by HUD collection for bulk entry removal
            /// </summary>
            protected bool skipCollectionRemove;

            public HudCollection(HudParentBase parent) : base(parent)
            {
                hudCollectionList = new List<TElementContainer>();
            }

            public HudCollection() : this(null)
            { }

            public IEnumerator<TElementContainer> GetEnumerator() =>
                hudCollectionList.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                GetEnumerator();

            /// <summary>
            /// Adds an element of type <see cref="TElement"/> to the chain.
            /// </summary>
            public void Add(TElement element, bool preload = false)
            {
                var newContainer = new TElementContainer();
                newContainer.SetElement(element);
                Add(newContainer, preload);
            }

            /// <summary>
            /// Adds an element of type <see cref="TElementContainer"/> to the chain.
            /// </summary>
            public void Add(TElementContainer container, bool preload = false)
            {
                if (container.Element.Registered)
                    throw new Exception("HUD Element already registered!");

                if (container.Element.Register(this, preload))
                    hudCollectionList.Add(container);
                else
                    throw new Exception("HUD Element registration failed.");
            }

            /// <summary>
            /// Add the given range to the end of the chain.
            /// </summary>
            public void AddRange(IReadOnlyList<TElementContainer> newContainers, bool preload = false)
            {
                NodeUtils.RegisterNodes<TElementContainer, TElement>(this, children, newContainers, preload);
                hudCollectionList.AddRange(newContainers);
            }

            /// <summary>
            /// Adds an element of type <see cref="TElementContainer"/> at the given index.
            /// </summary>
            public void Insert(int index, TElementContainer container, bool preload = false)
            {
                if (container.Element.Register(this, preload))
                    hudCollectionList.Insert(index, container);
                else
                    throw new Exception("HUD Element registration failed.");
            }

            /// <summary>
            /// Insert the given range into the chain.
            /// </summary>
            public void InsertRange(int index, IReadOnlyList<TElementContainer> newContainers, bool preload = false)
            {
                NodeUtils.RegisterNodes<TElementContainer, TElement>(this, children, newContainers, preload);
                hudCollectionList.InsertRange(index, newContainers);
            }

            /// <summary>
            /// Removes the specified element from the collection.
            /// </summary>
            public bool Remove(TElementContainer entry)
            {
                if (entry.Element.Parent == this && hudCollectionList.Count > 0)
                {
                    if (hudCollectionList.Remove(entry))
                    {
                        bool success = entry.Element.Unregister();

                        return success;
                    }
                }

                return false;
            }

            /// <summary>
            /// Removes the chain member that meets the conditions required by the predicate.
            /// </summary>
            public bool Remove(Func<TElementContainer, bool> predicate)
            {
                if (hudCollectionList.Count > 0)
                {
                    int index = hudCollectionList.FindIndex(x => predicate(x));
                    TElement element = hudCollectionList[index].Element;
                    bool success = false;

                    if (index != -1 && index < hudCollectionList.Count)
                    {
                        hudCollectionList.RemoveAt(index);
                        success = element.Unregister();
                    }

                    return success;
                }

                return false;
            }

            /// <summary>
            /// Remove the element at the given index.
            /// </summary>
            public bool RemoveAt(int index)
            {
                if (hudCollectionList[index].Element.Parent == this && hudCollectionList.Count > 0)
                {
                    TElement element = hudCollectionList[index].Element;
                    hudCollectionList.RemoveAt(index);

                    bool success = element.Unregister();

                    return success;
                }

                return false;
            }

            /// <summary>
            /// Removes the specfied range from the collection. Normal child elements not affected.
            /// </summary>
            public void RemoveRange(int index, int count)
            {
                NodeUtils.UnregisterNodes<TElementContainer, TElement>(this, children, hudCollectionList, index, count);
                hudCollectionList.RemoveRange(index, count);
            }

            /// <summary>
            /// Remove all elements in the collection. Does not affect normal child elements.
            /// </summary>
            public void Clear()
            {
                NodeUtils.UnregisterNodes<TElementContainer, TElement>(this, children, hudCollectionList, 0, hudCollectionList.Count);
                hudCollectionList.Clear();
            }

            /// <summary>
            /// Finds the chain member that meets the conditions required by the predicate.
            /// </summary>
            public TElementContainer Find(Func<TElementContainer, bool> predicate)
            {
                return hudCollectionList.Find(x => predicate(x));
            }

            /// <summary>
            /// Finds the index of the chain member that meets the conditions required by the predicate.
            /// </summary>
            public int FindIndex(Func<TElementContainer, bool> predicate)
            {
                return hudCollectionList.FindIndex(x => predicate(x));
            }

            /// <summary>
            /// Returns true if the given element is in the collection.
            /// </summary>
            public bool Contains(TElementContainer item) =>
                hudCollectionList.Contains(item);

            /// <summary>
            /// Copies the contents of the collection to the given array starting at the index specified in the target array.
            /// </summary>
            public void CopyTo(TElementContainer[] array, int arrayIndex) =>
                hudCollectionList.CopyTo(array, arrayIndex);

            public override bool RemoveChild(HudNodeBase child)
            {
                if (child.Parent == this)
                {
                    bool success = child.Unregister();

                    if (success)
                        RemoveChild(child);

                    return success;
                }
                else if (child.Parent == null && children.Remove(child))
                {
                    if (!skipCollectionRemove)
                    {
                        for (int n = 0; n < hudCollectionList.Count; n++)
                        {
                            if (hudCollectionList[n].Element == child)
                            {
                                hudCollectionList.RemoveAt(n);
                                break;
                            }
                        }
                    }
                    else
                        skipCollectionRemove = false;

                    return true;
                }
                else
                    return false;
            }
        }

        /// <summary>
        /// A collection of UI elements wrapped in container objects. UI elements in the containers are parented
        /// to the collection, like any other HUD element.
        /// </summary>
        public class HudCollection<TElementContainer> : HudCollection<TElementContainer, HudNodeBase>
            where TElementContainer : IHudElementContainer<HudNodeBase>, new()
        {
            public HudCollection(HudParentBase parent = null) : base(parent)
            { }
        }

        /// <summary>
        /// A collection of UI elements wrapped in container objects. UI elements in the containers are parented
        /// to the collection, like any other HUD element.
        /// </summary>
        public class HudCollection : HudCollection<HudElementContainer<HudNodeBase>, HudNodeBase>
        {
            public HudCollection(HudParentBase parent = null) : base(parent)
            { }
        }
    }
}
﻿using RichHudFramework.UI.Rendering;
using VRageMath;

namespace RichHudFramework.UI
{
    using Rendering;
    using Rendering.Client;
    using Rendering.Server;

    /// <summary>
    /// HUD element used to render text.
    /// </summary>
    public class Label : LabelElementBase
    {
        /// <summary>
        /// Text rendered by the label.
        /// </summary>
        public RichText Text { get { return _textBoard.GetText(); } set { _textBoard.SetText(value); } }

        /// <summary>
        /// TextBoard backing the label element.
        /// </summary>
        public override ITextBoard TextBoard => _textBoard;

        /// <summary>
        /// Default formatting used by the label.
        /// </summary>
        public GlyphFormat Format { get { return _textBoard.Format; } set { _textBoard.Format = value; } }

        /// <summary>
        /// Line formatting mode used by the label.
        /// </summary>
        public TextBuilderModes BuilderMode { get { return _textBoard.BuilderMode; } set { _textBoard.BuilderMode = value; } }

        /// <summary>
        /// If true, the element will automatically resize to fit the text.
        /// </summary>
        public bool AutoResize { get { return _textBoard.AutoResize; } set { _textBoard.AutoResize = value; } }

        /// <summary>
        /// If true, the text will be vertically centered.
        /// </summary>
        public bool VertCenterText { get { return _textBoard.VertCenterText; } set { _textBoard.VertCenterText = value; } }

        public override float Width
        {
            get { return _textBoard.Size.X + Padding.X; }
            set
            {
                if (value > Padding.X)
                    value -= Padding.X;

                _textBoard.FixedSize = new Vector2(value, _textBoard.FixedSize.Y);
            }
        }

        public override float Height
        {
            get { return _textBoard.Size.Y + Padding.Y; }
            set
            {
                if (value > Padding.Y)
                    value -= Padding.Y;

                _textBoard.FixedSize = new Vector2(_textBoard.FixedSize.X, value);
            }
        }

        protected readonly TextBoard _textBoard;

        public Label(HudParentBase parent) : base(parent)
        {
            _textBoard = new TextBoard();
            _textBoard.Format = GlyphFormat.White;
            _textBoard.SetText("NewLabel");
        }

        public Label() : this(null)
        { }

        protected override void Draw()
        {
            Vector2 halfSize = (cachedSize - cachedPadding) * .5f;
            BoundingBox2 box = new BoundingBox2(cachedPosition - halfSize, cachedPosition + halfSize);

            if (maskingBox != null)
                _textBoard.Draw(box, maskingBox.Value, HudSpace.PlaneToWorldRef);
            else
                _textBoard.Draw(box, CroppedBox.defaultMask, HudSpace.PlaneToWorldRef);
        }
    }
}
﻿using RichHudFramework.UI.Rendering;
using VRageMath;

namespace RichHudFramework.UI
{
    /// <summary>
    /// A text element with a textured background.
    /// </summary>
    public class LabelBox : LabelBoxBase, ILabelElement
    {
        /// <summary>
        /// Text rendered by the label.
        /// </summary>
        public RichText Text { get { return textElement.TextBoard.GetText(); } set { textElement.TextBoard.SetText(value); } }

        /// <summary>
        /// Default formatting used by the label.
        /// </summary>
        public GlyphFormat Format { get { return textElement.TextBoard.Format; } set { textElement.TextBoard.Format = value; } }

        /// <summary>
        /// Padding applied to the text element.
        /// </summary>
        public override Vector2 TextPadding { get { return textElement.Padding; } set { textElement.Padding = value; } }

        /// <summary>
        /// Size of the text element including TextPadding.
        /// </summary>
        public override Vector2 TextSize { get { return textElement.Size; } set { textElement.Size = value; } }

        /// <summary>
        /// If true, the element will automatically resize to fit the text.
        /// </summary>
        public override bool AutoResize { get { return textElement.AutoResize; } set { textElement.AutoResize = value; } }

        /// <summary>
        /// Line formatting mode used by the label.
        /// </summary>
        public TextBuilderModes BuilderMode { get { return TextBoard.BuilderMode; } set { TextBoard.BuilderMode = value; } }

        /// <summary>
        /// If true, the text will be vertically centered.
        /// </summary>
        public bool VertCenterText { get { return textElement.VertCenterText; } set { textElement.VertCenterText = value; } }

        /// <summary>
        /// TextBoard backing the label element.
        /// </summary>
        public ITextBoard TextBoard => textElement.TextBoard;

        /// <summary>
        /// Text element contained by the label box.
        /// </summary>
        public readonly Label textElement;

        public LabelBox(HudParentBase parent) : base(parent)
        {
            textElement = new Label(this);
        }

        public LabelBox() : this(null)
        { }
    }
}
﻿using RichHudFramework.UI.Rendering;
using VRageMath;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Creates a colored box of a given width and height using a given material. The default material is just a plain color.
    /// </summary>
    public class TexturedBox : HudElementBase
    {
        /// <summary>
        /// Material applied to the box.
        /// </summary>
        public Material Material { get { return hudBoard.Material; } set { hudBoard.Material = value; } }

        /// <summary>
        /// Determines how the material reacts to changes in element size/aspect ratio.
        /// </summary>
        public MaterialAlignment MatAlignment { get { return hudBoard.MatAlignment; } set { hudBoard.MatAlignment = value; } }

        /// <summary>
        /// Coloring applied to the material.
        /// </summary>
        public Color Color { get { return hudBoard.Color; } set { hudBoard.Color = value; } }

        protected float lastScale;
        protected readonly MatBoard hudBoard;

        public TexturedBox(HudParentBase parent) : base(parent)
        {
            hudBoard = new MatBoard();
            Size = new Vector2(50f);
        }

        public TexturedBox() : this(null)
        { }

        protected override void Draw()
        {
            if (hudBoard.Color.A > 0)
            {
                CroppedBox box = default(CroppedBox);
                Vector2 halfSize = (cachedSize - cachedPadding) * .5f;

                box.bounds = new BoundingBox2(cachedPosition - halfSize, cachedPosition + halfSize);
                box.mask = maskingBox;
                hudBoard.Draw(ref box, HudSpace.PlaneToWorldRef);
            }
        }
    }
}
﻿using System;
using VRage;
using VRageMath;
using HudSpaceDelegate = System.Func<VRage.MyTuple<bool, float, VRageMath.MatrixD>>;

namespace RichHudFramework.UI
{
    using Client;
    using Server;
    using Internal;

    /// <summary>
    /// A clickable box. Doesn't render any textures or text. Must be used in conjunction with other elements.
    /// Events return the parent object.
    /// </summary>
    public class MouseInputElement : HudElementBase, IMouseInput
    {
        public override bool Visible 
        { 
            set 
            {
                if (value)
                    State |= HudElementStates.IsVisible;
                else
                    State &= elementNotVisible;

                if (!value)
                {
                    IsLeftClicked = false;
                    IsRightClicked = false;
                    IsNewLeftClicked = false;
                    IsNewRightClicked = false;
                    IsLeftReleased = false;
                    IsRightReleased = false;
                }
            }
        }

        /// <summary>
        /// Invoked when the cursor enters the element's bounds
        /// </summary>
        public event EventHandler CursorEntered;

        /// <summary>
        /// Invoked when the cursor leaves the element's bounds
        /// </summary>
        public event EventHandler CursorExited;

        /// <summary>
        /// Invoked when the element is clicked with the left mouse button
        /// </summary>
        public event EventHandler LeftClicked;

        /// <summary>
        /// Invoked when the left click is released
        /// </summary>
        public event EventHandler LeftReleased;

        /// <summary>
        /// Invoked when the element is clicked with the right mouse button
        /// </summary>
        public event EventHandler RightClicked;

        /// <summary>
        /// Invoked when the right click is released
        /// </summary>
        public event EventHandler RightReleased;

        /// <summary>
        /// Invoked when taking focus
        /// </summary>
        public event EventHandler GainedInputFocus;

        /// <summary>
        /// Invoked when focus is lost
        /// </summary>
        public event EventHandler LostInputFocus;

        /// <summary>
        /// Indicates whether or not the element has input focus.
        /// </summary>
        public bool HasFocus { get { return hasFocus && Visible; } private set { hasFocus = value; } }

        /// <summary>
        /// True if the element is being clicked with the left mouse button
        /// </summary>
        public bool IsLeftClicked { get; private set; }

        /// <summary>
        /// True if the element is being clicked with the right mouse button
        /// </summary>
        public bool IsRightClicked { get; private set; }

        /// <summary>
        /// True if the element was just clicked with the left mouse button
        /// </summary>
        public bool IsNewLeftClicked { get; private set; }

        /// <summary>
        /// True if the element was just clicked with the right mouse button
        /// </summary>
        public bool IsNewRightClicked { get; private set; }

        /// <summary>
        /// True if the element was just released after being left clicked
        /// </summary>
        public bool IsLeftReleased { get; private set; }

        /// <summary>
        /// True if the element was just released after being right clicked
        /// </summary>
        public bool IsRightReleased { get; private set; }

        private bool mouseCursorEntered;
        private bool hasFocus;
        protected readonly Action LoseFocusCallback;

        public MouseInputElement(HudParentBase parent) : base(parent)
        {
            UseCursor = true;
            ShareCursor = true;
            HasFocus = false;
            DimAlignment = DimAlignments.Both | DimAlignments.IgnorePadding;

            LoseFocusCallback = LoseFocus;
        }

        public MouseInputElement() : this(null)
        { }

        /// <summary>
        /// Clears all subscribers to mouse input events.
        /// </summary>
        public void ClearSubscribers()
        {
            CursorEntered = null;
            CursorExited = null;
            LeftClicked = null;
            LeftReleased = null;
            RightClicked = null;
            RightReleased = null;
        }

        protected override void InputDepth()
        {
            State &= ~HudElementStates.IsMouseInBounds;

            if (HudMain.InputMode != HudInputMode.NoInput && (HudSpace?.IsFacingCamera ?? false))
            {
                Vector3 cursorPos = HudSpace.CursorPos;
                Vector2 halfSize = Vector2.Max(cachedSize, new Vector2(minMouseBounds)) * .5f;
                BoundingBox2 box = new BoundingBox2(cachedPosition - halfSize, cachedPosition + halfSize);
                bool mouseInBounds;

                if (maskingBox == null)
                {
                    mouseInBounds = box.Contains(new Vector2(cursorPos.X, cursorPos.Y)) == ContainmentType.Contains
                        || (IsLeftClicked || IsRightClicked);
                }
                else
                {
                    mouseInBounds = box.Intersect(maskingBox.Value).Contains(new Vector2(cursorPos.X, cursorPos.Y)) == ContainmentType.Contains
                        || (IsLeftClicked || IsRightClicked);
                }

                if (mouseInBounds)
                {
                    State |= HudElementStates.IsMouseInBounds;
                    HudMain.Cursor.TryCaptureHudSpace(cursorPos.Z, HudSpace.GetHudSpaceFunc);
                }
            }
        }

        protected override void HandleInput(Vector2 cursorPos)
        {
            if (IsMousedOver)
            {
                if (!mouseCursorEntered)
                {
                    mouseCursorEntered = true;
                    CursorEntered?.Invoke(_parent, EventArgs.Empty);
                }

                if (SharedBinds.LeftButton.IsNewPressed)
                {
                    GetInputFocus();
                    OnLeftClick();
                }
                else
                {
                    IsNewLeftClicked = false;
                }

                if (SharedBinds.RightButton.IsNewPressed)
                {
                    GetInputFocus();
                    OnRightClick();
                }
                else
                {
                    IsNewRightClicked = false;
                }
            }
            else
            {
                if (mouseCursorEntered)
                {
                    mouseCursorEntered = false;
                    CursorExited?.Invoke(_parent, EventArgs.Empty);
                }

                if (HasFocus && (SharedBinds.LeftButton.IsNewPressed || SharedBinds.RightButton.IsNewPressed))
                    LoseFocus();

                IsNewLeftClicked = false;
                IsNewRightClicked = false;                
            }

            if (!SharedBinds.LeftButton.IsPressed && IsLeftClicked)
            {
                LeftReleased?.Invoke(_parent, EventArgs.Empty);
                IsLeftReleased = true;
                IsLeftClicked = false;
            }
            else
                IsLeftReleased = false;

            if (!SharedBinds.RightButton.IsPressed && IsRightClicked)
            {
                RightReleased?.Invoke(_parent, EventArgs.Empty);
                IsRightReleased = true;
                IsRightClicked = false;
            }
            else
                IsRightReleased = false;
        }

        /// <summary>
        /// Invokes left click event
        /// </summary>
        public virtual void OnLeftClick()
        {
            LeftClicked?.Invoke(_parent, EventArgs.Empty);
            IsLeftClicked = true;
            IsNewLeftClicked = true;
            IsLeftReleased = false;
        }

        /// <summary>
        /// Invokes right click event
        /// </summary>
        public virtual void OnRightClick()
        {
            RightClicked?.Invoke(_parent, EventArgs.Empty);
            IsRightClicked = true;
            IsNewRightClicked = true;
            IsRightReleased = false;
        }

        /// <summary>
        /// Gets input focus for keyboard controls. Input focus normally taken when an
        /// element with mouse input is clicked.
        /// </summary>
        public virtual void GetInputFocus()
        {
            if (!hasFocus)
            {
                hasFocus = true;
                HudMain.GetInputFocus(LoseFocusCallback);
                GainedInputFocus?.Invoke(_parent, EventArgs.Empty);
            }
        }

        protected virtual void LoseFocus()
        {
            if (hasFocus)
            {
                hasFocus = false;
                LostInputFocus?.Invoke(_parent, EventArgs.Empty);
            }
        }
    }
}﻿using System.Collections.Generic;
using VRageMath;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Filters cursor input to the elements behind it. If any bind in its list is pressed, then cursor
    /// input to those elements will be blocked.
    /// </summary>
    public class MouseInputFilter : HudElementBase
    {
        /// <summary>
        /// True if any bind in the bind list is pressed
        /// </summary>
        public bool IsControlPressed { get; private set; }

        /// <summary>
        /// List of binds used in filtering input
        /// </summary>
        public IReadOnlyList<IBind> Binds { get; set; }
        
        public MouseInputFilter(HudParentBase parent) : base(parent)
        {
            UseCursor = true;
            ShareCursor = true;
        }

        public MouseInputFilter() : this(null)
        { }

        protected override void HandleInput(Vector2 cursorPos)
        {
            IsControlPressed = false;

            if (IsMousedOver && Binds != null)
            {
                for (int n = 0; n < Binds.Count; n++)
                {
                    if (Binds[n].IsPressed)
                    {
                        IsControlPressed = true;
                        break;
                    }
                }
            }

            ShareCursor = !IsControlPressed;
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using VRageMath;

namespace RichHudFramework.UI
{
    using Client;
    using Server;

    /// <summary>
    /// Clickable text box. Supports text highlighting and has its own text caret. Text only, no background.
    /// </summary>
    public class TextBox : Label, IClickableElement
    {
        /// <summary>
        /// Determines whether or not the textbox will allow the user to edit its contents
        /// </summary>
        public bool EnableEditing { get { return caret.ShowCaret; } set { caret.ShowCaret = value; } }

        /// <summary>
        /// Determines whether the user will be allowed to highlight text
        /// </summary>
        public bool EnableHighlighting { get; set; }

        /// <summary>
        /// Indicates whether or not the textbox will accept input
        /// </summary>
        public bool InputOpen { get; private set; }

        /// <summary>
        /// Used to restrict the range of characters allowed for input.
        /// </summary>
        public Func<char, bool> CharFilterFunc { get; set; }

        /// <summary>
        /// Index of the first character in the selected range.
        /// </summary>
        public Vector2I SelectionStart => selectionBox.Start;

        /// <summary>
        /// Index of the last character in the selected range.
        /// </summary>
        public Vector2I SelectionEnd => selectionBox.End;

        /// <summary>
        /// If true, then text box currently has a range of characters selected.
        /// </summary>
        public bool SelectionEmpty => selectionBox.Empty;

        /// <summary>
        /// If true, the caret will move to the end of the text when it gains focus.
        /// </summary>
        public bool MoveToEndOnGainFocus { get; set; }

        /// <summary>
        /// If true, any text selections will be cleared when focus is lost.
        /// </summary>
        public bool ClearSelectionOnLoseFocus { get; set; }

        public IMouseInput MouseInput { get; }

        private readonly TextInput textInput;
        private readonly TextCaret caret;
        private readonly SelectionBox selectionBox;
        private readonly ToolTip warningToolTip;
        private bool canHighlight, allowInput;
        private Vector2 cursorStart;

        public TextBox(HudParentBase parent) : base(parent)
        {
            MouseInput = new MouseInputElement(this) { ShareCursor = true, ZOffset = 1 };
            textInput = new TextInput(AddChar, RemoveLastChar, TextInputFilter);

            caret = new TextCaret(this) { Visible = false };
            selectionBox = new SelectionBox(caret, this) { Color = new Color(255, 255, 255, 140) };

            warningToolTip = new ToolTip()
            {
                text = "Open Chat to Enable Text Editing",
                bgColor = ToolTip.orangeWarningBG
            };

            caret.CaretMoved += CaretMoved;
            MouseInput.GainedInputFocus += GainFocus;
            MouseInput.LostInputFocus += LoseFocus;

            ShareCursor = true;
            EnableEditing = true;
            EnableHighlighting = true;
            UseCursor = true;

            MoveToEndOnGainFocus = false;
            ClearSelectionOnLoseFocus = true;

            Size = new Vector2(60f, 200f);
        }

        public TextBox() : this(null)
        { }

        /// <summary>
        /// Opens the textbox for input and moves the caret to the end.
        /// </summary>
        public void OpenInput()
        {
            allowInput = true;
            UpdateInputOpen();
            caret.SetPosition(0);
            caret.SetPosition(short.MaxValue);
        }
        
        /// <summary>
        /// Closes textbox input and clears the text selection.
        /// </summary>
        public void CloseInput()
        {
            allowInput = false;
            UpdateInputOpen();
            selectionBox.ClearSelection();
        }

        /// <summary>
        /// Highlights the range of text specified.
        /// </summary>
        public void SetSelection(Vector2I start, Vector2I end) =>
            selectionBox.SetSelection(start, end);

        /// <summary>
        /// Clears selected text range.
        /// </summary>
        public void ClearSelection() =>
            selectionBox.ClearSelection();

        /// <summary>
        /// Determines whether or not the given character is within the accepted range for input.
        /// </summary>
        private bool TextInputFilter(char ch)
        {
            if (CharFilterFunc == null)
                return ch >= ' ' || ch == '\n' || ch == '\t';
            else
                return CharFilterFunc(ch) && (ch >= ' ' || ch == '\n');
        }

        private void CaretMoved()
        {
            if (canHighlight)
                selectionBox.UpdateSelection();
        }

        private void GainFocus(object sender, EventArgs args)
        {
            if (MoveToEndOnGainFocus)
                caret.SetPosition(short.MaxValue);
        }

        private void LoseFocus(object sender, EventArgs args)
        {
            if (ClearSelectionOnLoseFocus)
                ClearSelection();
        }

        protected override void HandleInput(Vector2 cursorPos)
        {
            bool useInput = allowInput || (MouseInput.HasFocus && HudMain.InputMode == HudInputMode.Full);

            if (EnableEditing && IsMousedOver && HudMain.InputMode == HudInputMode.CursorOnly)
                HudMain.Cursor.RegisterToolTip(warningToolTip);

            if (useInput && EnableEditing)
            {
                textInput.HandleInput();

                if (SharedBinds.Cut.IsNewPressed && !selectionBox.Empty && EnableHighlighting)
                {
                    RichText text = TextBoard.GetTextRange(selectionBox.Start, selectionBox.End);
                    DeleteSelection();
                    caret.Move(new Vector2I(0, -GetRichTextMinLength(text)));
                    HudMain.ClipBoard = text;
                }

                if (SharedBinds.Paste.IsNewPressed)
                {
                    if (!HudMain.ClipBoard.Equals(default(RichText)))
                    {
                        Vector2I insertIndex = caret.CaretIndex + new Vector2I(0, 1);
                        insertIndex.X = MathHelper.Clamp(insertIndex.X, 0, TextBoard.Count);

                        DeleteSelection();
                        TextBoard.Insert(HudMain.ClipBoard, insertIndex);
                        int length = GetRichTextMinLength(HudMain.ClipBoard);

                        if (caret.CaretIndex.Y == -1)
                            length++;

                        caret.Move(new Vector2I(0, length));
                    }
                }
            }

            UpdateInputOpen();
            caret.Visible = InputOpen;

            if (useInput && EnableHighlighting)
            {
                bool isCursorHighlighting = false;

                if (UseCursor)
                {
                    if (MouseInput.IsNewLeftClicked)
                    {
                        cursorStart = cursorPos;
                        selectionBox.ClearSelection();
                    }
                    // Require some movement before enabling highlighting
                    else if (!canHighlight && MouseInput.IsLeftClicked && (cursorPos - cursorStart).LengthSquared() > 16f)
                    {
                        canHighlight = true;
                        isCursorHighlighting = true;
                    }
                    else if (!MouseInput.IsLeftClicked)
                    {
                        canHighlight = false;
                    }
                }

                if (!isCursorHighlighting)
                    canHighlight = SharedBinds.Shift.IsPressed;

                if (SharedBinds.SelectAll.IsNewPressed)
                    selectionBox.SetSelection(Vector2I.Zero, new Vector2I(TextBoard.Count - 1, TextBoard[TextBoard.Count - 1].Count - 1));
                else if (SharedBinds.Escape.IsNewPressed)
                    selectionBox.ClearSelection();

                if (SharedBinds.Copy.IsNewPressed && !selectionBox.Empty)
                    HudMain.ClipBoard = TextBoard.GetTextRange(selectionBox.Start, selectionBox.End);
            }
            else
            {
                canHighlight = false;
            }
        }

        private void UpdateInputOpen()
        {
            bool useInput = allowInput || (MouseInput.HasFocus && HudMain.InputMode == HudInputMode.Full);
            InputOpen = useInput && (EnableHighlighting || EnableEditing);
        }

        /// <summary>
        /// Inserts the given character to the right of the caret.
        /// </summary>
        private void AddChar(char ch)
        {
            DeleteSelection();
            TextBoard.Insert(ch, caret.CaretIndex + new Vector2I(0, 1));
            caret.Move(new Vector2I(0, 1));
        }

        /// <summary>
        /// Removes the character immediately preceeding the caret.
        /// </summary>
        private void RemoveLastChar()
        {
            if (TextBoard.Count > 0 && TextBoard[caret.CaretIndex.X].Count > 0)
            {
                DeleteSelection();

                if (caret.CaretIndex.Y >= 0)
                    TextBoard.RemoveAt(ClampIndex(caret.CaretIndex));

                caret.Move(new Vector2I(0, -1));
            }
        }

        /// <summary>
        /// Removes the text currently highlighted from the textbox.
        /// </summary>
        private void DeleteSelection()
        {
            if (!selectionBox.Empty)
            {
                TextBoard.RemoveRange(selectionBox.Start, selectionBox.End);
                selectionBox.ClearSelection();
            }
        }

        /// <summary>
        /// Clamps the given index within the range of existing characters.
        /// </summary>
        private Vector2I ClampIndex(Vector2I index)
        {
            if (TextBoard.Count > 0)
            {
                index.X = MathHelper.Clamp(index.X, 0, TextBoard.Count - 1);
                index.Y = MathHelper.Clamp(index.Y, 0, TextBoard[index.X].Count - 1);

                return index;
            }
            else
                return Vector2I.Zero;
        }

        private static int GetRichTextMinLength(RichText text)
        {
            int length = 0;

            for (int n = 0; n < text.apiData.Count; n++)
                length += text.apiData[n].Item1.Length;

            return length;
        }

        private class TextCaret : TexturedBox
        {
            /// <summary>
            /// Index of the character currently selected by the caret. When Y == -1, that means
            /// the caret is positioned to the left of the first character in the line.
            /// </summary>
            public Vector2I CaretIndex { get; private set; }

            /// <summary>
            /// Determines whether the caret will be visible
            /// </summary>
            public bool ShowCaret { get; set; }

            public event Action CaretMoved;

            private readonly TextBox textElement;
            private readonly ITextBoard text;
            private readonly Stopwatch blinkTimer;
            private bool blink, caretMoved;
            private int caretOffset;
            private Vector2 lastCursorPos;

            public TextCaret(TextBox textElement) : base(textElement)
            {
                this.textElement = textElement;
                text = textElement.TextBoard;
                Size = new Vector2(1f, 16f);
                Color = new Color(240, 240, 230);

                blinkTimer = new Stopwatch();
                blinkTimer.Start();
            }

            /// <summary>
            /// Moves the caret in the direction indicated by the vector. The caret will automatically
            /// wrap to the last/next line if movement in the Y direction would result in the index
            /// going out of range.
            /// </summary>
            /// <param name="dir">Index direction vector</param>
            public void Move(Vector2I dir, bool navigate = false)
            {
                Vector2I newIndex, min = new Vector2I(0, -1);

                if (dir.Y < 0 && CaretIndex == min)
                    dir.Y = 0;

                bool moveLeft = dir.Y < 0, moveRight = dir.Y > 0,
                    prepending = CaretIndex.Y == -1,
                    startPrepend = moveLeft && CaretIndex.Y == 0;

                if (startPrepend || (dir.Y == 0 && prepending))
                {
                    newIndex = CaretIndex + new Vector2I(dir.X, 0);
                    newIndex.Y = -1;

                    newIndex = ClampIndex(newIndex);
                    caretOffset = GetOffsetFromIndex(new Vector2I(newIndex.X, 0));
                }
                else
                {
                    int newOffset = Math.Max(caretOffset + dir.Y, 0);

                    // Stop prepending
                    if ((prepending && moveRight) && (CaretIndex.X > 0 || text[0].Count > 1))
                        newOffset -= 1;

                    newIndex = GetIndexFromOffset(newOffset) + new Vector2I(dir.X, 0);
                    newIndex = ClampIndex(newIndex);
                    caretOffset = GetOffsetFromIndex(newIndex);

                    if (navigate && moveRight && newIndex.X > CaretIndex.X)
                        newIndex.Y = -1;
                }

                CaretIndex = ClampIndex(newIndex);
                caretMoved = true;

                if (CaretIndex.Y >= 0)
                    text.MoveToChar(CaretIndex);
                else
                    text.MoveToChar(CaretIndex + new Vector2I(0, 1));

                blink = true;
                blinkTimer.Restart();
            }

            public void SetPosition(Vector2I index)
            {
                index = ClampIndex(index);
                
                if (CaretIndex != index)
                    caretMoved = true;

                CaretIndex = index;
                caretOffset = Math.Max(GetOffsetFromIndex(CaretIndex), 0);
                text.MoveToChar(CaretIndex);
            }

            public void SetPosition(short offset)
            {
                Vector2I index = GetIndexFromOffset(offset);

                if (CaretIndex != index)
                    caretMoved = true;

                CaretIndex = index;
                caretOffset = Math.Max(GetOffsetFromIndex(CaretIndex), 0);
                text.MoveToChar(index);
            }

            protected override void Layout()
            {
                base.Layout();

                if (caretMoved)
                {
                    CaretMoved?.Invoke();
                    caretMoved = false;
                }
            }

            protected override void Draw()
            {
                if (ShowCaret)
                {
                    bool isCharVisible = text.Count == 0 || text[0].Count == 0;
                    CaretIndex = ClampIndex(CaretIndex);

                    // If line visible
                    if ((text.Count > 0 && text[0].Count > 0) && 
                        (CaretIndex.X >= text.VisibleLineRange.X && CaretIndex.X <= text.VisibleLineRange.Y) )
                    {
                        // Damned special cases
                        Vector2I index = Vector2I.Max(CaretIndex, Vector2I.Zero);

                        // Calculate visibilty on line
                        IRichChar ch = text[index];
                        Vector2 size = ch.Size,
                            pos = ch.Offset + text.TextOffset;
                        BoundingBox2 textBounds = BoundingBox2.CreateFromHalfExtent(Vector2.Zero, .5f * text.Size),
                            charBounds = BoundingBox2.CreateFromHalfExtent(pos, .5f * Vector2.Max(size, new Vector2(8f)));

                        if (textBounds.Contains(charBounds) != ContainmentType.Disjoint)
                            isCharVisible = true;
                    }

                    if (blink & isCharVisible)
                    {
                        UpdateOffset();
                        base.Draw();
                    }

                    if (blinkTimer.ElapsedMilliseconds > 500)
                    {
                        blink = !blink;
                        blinkTimer.Restart();
                    }
                }
            }

            /// <summary>
            /// Updates the position of the caret to match that of the currently selected character.
            /// </summary>
            private void UpdateOffset()
            {
                Vector2 offset = new Vector2();
                Vector2I index = Vector2I.Max(CaretIndex, Vector2I.Zero);

                if (text.Count > 0 && text[index.X].Count > 0)
                {
                    IRichChar ch;
                    Height = text[index.X].Size.Y - 2f;
                    ch = text[index];

                    if (CaretIndex.Y == -1)
                    {
                       
                        offset = ch.Offset + text.TextOffset;
                        offset.X -= ch.Size.X * .5f + 1f;
                    }
                    else
                    {
                        offset = ch.Offset + text.TextOffset;
                        offset.X += ch.Size.X * .5f + 1f;
                    }
                }
                else
                {
                    if (text.Format.Alignment == TextAlignment.Left)
                        offset.X = -textElement.Size.X * .5f + 2f;
                    else if (text.Format.Alignment == TextAlignment.Right)
                        offset.X = textElement.Size.X * .5f - 2f;

                    offset += _parentFull.Padding * .5f;

                    if (!text.VertCenterText)
                        offset.Y = (text.Size.Y - Height) * .5f - 4f;
                }

                Offset = offset;
            }

            /// <summary>
            /// Handles input for moving the caret.
            /// </summary>
            protected override void HandleInput(Vector2 cursorPos)
            {
                if (SharedBinds.DownArrow.IsPressedAndHeld || SharedBinds.DownArrow.IsNewPressed)
                    Move(new Vector2I(1, 0), true);

                if (SharedBinds.UpArrow.IsPressedAndHeld || SharedBinds.UpArrow.IsNewPressed)
                    Move(new Vector2I(-1, 0), true);

                if (SharedBinds.RightArrow.IsPressedAndHeld || SharedBinds.RightArrow.IsNewPressed)
                    Move(new Vector2I(0, 1), true);

                if (SharedBinds.LeftArrow.IsPressedAndHeld || SharedBinds.LeftArrow.IsNewPressed)
                    Move(new Vector2I(0, -1), true);

                if (textElement.UseCursor)
                {
                    if (textElement.MouseInput.IsLeftClicked)
                        GetClickedChar(cursorPos);
                }
            }

            /// <summary>
            /// Sets the index of the caret to that of the character closest to the cursor.
            /// </summary>
            private void GetClickedChar(Vector2 cursorPos)
            {
                if ((cursorPos - lastCursorPos).LengthSquared() > 4f)
                {
                    CaretIndex = ClampIndex(CaretIndex);

                    Vector2 offset = cursorPos - textElement.Position;
                    Vector2I index = Vector2I.Max(CaretIndex, Vector2I.Zero),
                        newIndex = text.GetCharAtOffset(offset);

                    // If clicking left of center on the char, move one char back.
                    if ((text.Count > 0 && text[index.X].Count > 0 && text[index].Ch != '\n') && (offset.X < text[index].Offset.X))
                        CaretIndex -= new Vector2I(0, 1);

                    CaretIndex = ClampIndex(newIndex);
                    caretOffset = GetOffsetFromIndex(CaretIndex);
                    lastCursorPos = cursorPos;

                    blink = true;
                    blinkTimer.Restart();
                    caretMoved = true;
                }
            }

            /// <summary>
            /// Clamps the given index within the range of existing characters.
            /// </summary>
            private Vector2I ClampIndex(Vector2I index)
            {
                if (text.Count > 0)
                {
                    index.X = MathHelper.Clamp(index.X, 0, text.Count - 1);
                    index.Y = MathHelper.Clamp(index.Y, -1, text[index.X].Count - 1);

                    return index;
                }
                else
                    return Vector2I.Zero;
            }

            /// <summary>
            /// Returns the total number of characters between the start of the text and the current index.
            /// </summary>
            private int GetOffsetFromIndex(Vector2I index)
            {
                int offset = 0;

                for (int line = 0; line < index.X; line++)
                {
                    offset += text[line].Count;
                }

                offset += index.Y;
                return offset;
            }

            /// <summary>
            /// Calculates the index with given the number of characters between it and the beginning of the
            /// text.
            /// </summary>
            private Vector2I GetIndexFromOffset(int offset)
            {
                Vector2I index = Vector2I.Zero;
                int charCount = 0;

                for (int line = 0; line < text.Count; line++)
                    charCount += text[line].Count;

                offset = Math.Min(offset, charCount - 1);

                for (int line = 0; line < text.Count; line++)
                {
                    int lineLength = text[line].Count;

                    if (offset < lineLength)
                    {
                        index.Y = offset;
                        break;
                    }
                    else
                    {
                        offset -= lineLength;
                        index.X++;
                    }
                }

                return index;
            }
        }

        private class SelectionBox : HudElementBase
        {
            /// <summary>
            /// Color of the selection box
            /// </summary>
            public Color Color { get { return highlightBoard.Color; } set { highlightBoard.Color = value; } }

            /// <summary>
            /// Index of the first character in the selection.
            /// </summary>
            public Vector2I Start { get; private set; }

            /// <summary>
            /// Index of the last character in the selection.
            /// </summary>
            public Vector2I End { get; private set; }

            /// <summary>
            /// If true, then the current selection is empty.
            /// </summary>
            public bool Empty => (Start == -Vector2I.One || End == -Vector2I.One);

            private readonly TextCaret caret;
            private readonly ITextBoard text;
            private readonly MatBoard highlightBoard;
            private readonly List<HighlightBox> highlightList;
            private Vector2 lastTextSize;
            private Vector2I lastVisRange;
            private bool highlightStale;

            public SelectionBox(TextCaret caret, Label parent) : base(parent)
            {
                text = parent.TextBoard;
                this.caret = caret;

                Start = -Vector2I.One;
                highlightBoard = new MatBoard();
                highlightList = new List<HighlightBox>();
            }

            public void SetSelection(Vector2I start, Vector2I end)
            {
                Start = start;
                End = end;

                highlightStale = true;
            }

            public void ClearSelection()
            {
                Start = -Vector2I.One;
                End = -Vector2I.One;
                highlightList.Clear();
            }

            public void UpdateSelection()
            {
                Vector2I caretIndex = caret.CaretIndex;

                if (text.Count > 0)
                {
                    if (Start == -Vector2I.One)
                    {
                        Start = caretIndex;
                        End = Start;

                        if (Start.Y < text[Start.X].Count - 1)
                            Start += new Vector2I(0, 1);
                    }
                    else
                    {
                        // If caret after start
                        if (caretIndex.X > Start.X || (caretIndex.X == Start.X && caretIndex.Y >= Start.Y))
                            End = caretIndex;
                        else
                        {
                            Start = caretIndex;

                            if (Start.Y < text[Start.X].Count - 1)
                                Start += new Vector2I(0, 1);
                        }
                    }

                    if (End.Y == -1)
                        End += new Vector2I(0, 1);

                    highlightStale = true;
                }
                else
                {
                    Start = -Vector2I.One;
                    End = -Vector2I.One;
                }
            }

            protected override void Draw()
            {
                if (lastTextSize != text.Size)
                {
                    lastTextSize = text.Size;
                    ClearSelection();
                }

                if (!Empty)
                {
                    if (highlightStale || text.VisibleLineRange != lastVisRange)
                    {
                        lastVisRange = text.VisibleLineRange;
                        UpdateHighlight();
                    }

                    Vector2 tbOffset = text.TextOffset, bounds = new Vector2(-text.Size.X * .5f, text.Size.X * .5f);

                    for (int n = 0; n < highlightList.Count; n++)
                        highlightList[n].Draw(highlightBoard, Origin, tbOffset, bounds, HudSpace.PlaneToWorldRef);
                }
            }

            /// <summary>
            /// Calculates the size and offsets for the boxes highlighting the selection.
            /// </summary>
            private void UpdateHighlight()
            {
                highlightStale = false;
                highlightList.Clear();

                // Clamp line range
                Vector2I lineRange = text.VisibleLineRange;
                Start = new Vector2I(MathHelper.Clamp(Start.X, 0, text.Count - 1), Start.Y);
                End = new Vector2I(MathHelper.Clamp(End.X, 0, text.Count - 1), End.Y);

                // Clamp char range
                if (text.Count > 0)
                {
                    Start = new Vector2I(Start.X, MathHelper.Clamp(Start.Y, 0, text[Start.X].Count - 1));
                    End = new Vector2I(End.X, MathHelper.Clamp(End.Y, 0, text[End.X].Count - 1));
                }

                int startLine = Math.Max(Start.X, lineRange.X),
                    endLine = Math.Min(End.X, lineRange.Y);

                // Add start and end
                if (Start.X == End.X && Start.X == startLine)
                    AddHighlightBox(Start.X, Start.Y, End.Y);
                else
                {
                    for (int line = startLine; line <= endLine; line++)
                    {
                        if (line == Start.X)
                            AddHighlightBox(Start.X, Start.Y, text[Start.X].Count - 1); // Top
                        else if (line == End.X)
                            AddHighlightBox(End.X, 0, End.Y); // Bottom
                        else
                            AddHighlightBox(line, 0, text[line].Count - 1); // Middle
                    }
                }

                if (highlightList.Count > 0 && highlightList.Capacity > 3 * highlightList.Count)
                    highlightList.TrimExcess();
            }

            /// <summary>
            /// Adds an appropriately sized highlight box for the range of characters on the given line.
            /// Does not take into account text clipping or text offset.
            /// </summary>
            private void AddHighlightBox(int line, int startCh, int endCh)
            {
                if (text[line].Count > 0)
                {
                    if (startCh < 0 || endCh < 0 || startCh >= text[line].Count || endCh >= text[line].Count)
                        throw new Exception($"Char out of range. Line: {line} StartCh: {startCh}, EndCh: {endCh}, Count: {text[line].Count}");

                    IRichChar left = text[line][startCh], right = text[line][endCh];
                    var highlightBox = new HighlightBox
                    {
                        size = new Vector2()
                        {
                            X = right.Offset.X - left.Offset.X + (left.Size.X + right.Size.X) * .5f,
                            Y = text[line].Size.Y
                        },
                        offset = new Vector2()
                        {
                            X = (right.Offset.X + left.Offset.X) * .5f - 2f,
                            Y = text[line].VerticalOffset - text[line].Size.Y * .5f
                        }
                    };

                    if (highlightBox.size.X > 1f)
                        highlightBox.size.X += 4f;

                    highlightList.Add(highlightBox);
                }
            }

            private struct HighlightBox
            {
                public Vector2 size, offset;

                public void Draw(MatBoard matBoard, Vector2 origin, Vector2 tbOffset, Vector2 xBounds, MatrixD[] matrixRef)
                {
                    CroppedBox box = default(CroppedBox);
                    Vector2 clipSize, clipPos;
                    clipSize = size;
                    clipPos = offset + tbOffset;

                    // Determine the visible extents of the highlight box within the bounds of the textboard
                    float leftBound = Math.Max(clipPos.X - clipSize.X * .5f, xBounds.X),
                        rightBound = Math.Min(clipPos.X + clipSize.X * .5f, xBounds.Y);

                    // Adjust highlight size and offset to compensate for textboard clipping and offset
                    clipSize.X = Math.Max(0, rightBound - leftBound);
                    clipPos.X = (rightBound + leftBound) * .5f;
                    clipPos += origin;

                    clipSize *= .5f;
                    box.bounds = new BoundingBox2(clipPos - clipSize, clipPos + clipSize);

                    matBoard.Draw(ref box, matrixRef);
                }
            }
        }
    }
}
﻿using VRageMath;
using System;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Clickable button with a textured background.
    /// </summary>
    public class Button : TexturedBox, IClickableElement
    {
        /// <summary>
        /// Indicates whether or not the cursor is currently positioned over the button.
        /// </summary>
        public override bool IsMousedOver => _mouseInput.IsMousedOver;

        /// <summary>
        /// Handles mouse input for the button.
        /// </summary>
        public IMouseInput MouseInput => _mouseInput;

        /// <summary>
        /// Determines whether or not the button will highlight when moused over.
        /// </summary>
        public bool HighlightEnabled { get; set; }

        /// <summary>
        /// Color of the background when moused over.
        /// </summary>
        public Color HighlightColor { get; set; }

        protected readonly MouseInputElement _mouseInput;
        protected Color lastBackgroundColor;

        public Button(HudParentBase parent) : base(parent)
        {
            _mouseInput = new MouseInputElement(this);
            HighlightColor = new Color(125, 125, 125, 255);
            HighlightEnabled = true;

            _mouseInput.CursorEntered += CursorEnter;
            _mouseInput.CursorExited += CursorExit;
        }

        public Button() : this(null)
        { }

        protected virtual void CursorEnter(object sender, EventArgs args)
        {
            if (HighlightEnabled)
            {
                lastBackgroundColor = Color;
                Color = HighlightColor;
            }
        }

        protected virtual void CursorExit(object sender, EventArgs args)
        {
            if (HighlightEnabled)
            {
                Color = lastBackgroundColor;
            }
        }
    }
}﻿using VRageMath;
using System;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Clickable button with text and a textured background. 
    /// </summary>
    public class LabelBoxButton : LabelBox, IClickableElement
    {
        /// <summary>
        /// Color of the background when moused over.
        /// </summary>
        public virtual Color HighlightColor { get; set; }

        /// <summary>
        /// Determines whether or not the button will highlight when moused over.
        /// </summary>
        public virtual bool HighlightEnabled { get; set; }

        /// <summary>
        /// Indicates whether or not the cursor is currently over the element.
        /// </summary>
        public override bool IsMousedOver => _mouseInput.IsMousedOver;

        /// <summary>
        /// Mouse input for the button.
        /// </summary>
        public IMouseInput MouseInput => _mouseInput;

        protected MouseInputElement _mouseInput;
        protected Color oldColor;

        public LabelBoxButton(HudParentBase parent) : base(parent)
        {
            _mouseInput = new MouseInputElement(this);
            Color = Color.DarkGray;
            HighlightColor = Color.Gray;
            HighlightEnabled = true;

            _mouseInput.CursorEntered += CursorEnter;
            _mouseInput.CursorExited += CursorExit;
        }

        public LabelBoxButton() : this(null)
        { }

        protected virtual void CursorEnter(object sender, EventArgs args)
        {
            if (HighlightEnabled)
            {
                oldColor = Color;
                Color = HighlightColor;
            }
        }

        protected virtual void CursorExit(object sender, EventArgs args)
        {
            if (HighlightEnabled)
            {
                Color = oldColor;
            }
        }
    }
}﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Clickable text element. Text only, no background.
    /// </summary>
    public class LabelButton : Label, IClickableElement
    {
        /// <summary>
        /// Handles mouse input for the button.
        /// </summary>
        public IMouseInput MouseInput => _mouseInput;

        /// <summary>
        /// Indicates whether or not the cursor is currently positioned over the button.
        /// </summary>
        public override bool IsMousedOver => _mouseInput.IsMousedOver;

        protected MouseInputElement _mouseInput;

        public LabelButton(HudParentBase parent) : base(parent)
        {
            _mouseInput = new MouseInputElement(this);
        }

        public LabelButton() : this(null)
        { }
    }
}﻿using VRageMath;
using System;

namespace RichHudFramework.UI
{
    using Client;
    using Server;

    /// <summary>
    /// Generic clickable slider bar. Can be oriented vertically or horizontally. Current value
    /// automatically clamped between min and max.
    /// </summary>
    public class SliderBar : HudElementBase, IClickableElement
    {
        /// <summary>
        /// Width of the sliderbar.
        /// </summary>
        public override float Width
        {
            get 
            {
                if (Vertical)
                    return (Math.Max(_barSize.X, _sliderSize.X) + _padding.X);
                else
                    return _barSize.X;
            }
            set
            {
                if (value > _padding.X)
                    value -= _padding.X;

                if (_barSize.X >= _sliderSize.X)
                {
                    _barSize.X = value;
                    _sliderSize.X = Math.Min(_sliderSize.X, _barSize.X);
                }
                else
                {
                    _sliderSize.X = value;
                    _barSize.X = Math.Min(_sliderSize.X, _barSize.X);
                }
            }
        }

        /// <summary>
        /// Height of the sliderbar.
        /// </summary>
        public override float Height
        {
            get
            {
                if (Vertical)
                    return _barSize.Y;
                else
                    return (Math.Max(_barSize.Y, _sliderSize.Y) + _padding.Y);
            }
            set
            {
                if (value > _padding.Y)
                    value -= _padding.Y;

                if (_barSize.Y >= _sliderSize.Y)
                {
                    _barSize.Y = value;
                    _sliderSize.Y = Math.Min(_sliderSize.Y, _barSize.Y);
                }
                else
                {
                    _sliderSize.Y = value;
                    _barSize.Y = Math.Min(_sliderSize.Y, _barSize.Y);
                }
            }
        }

        /// <summary>
        /// Lower limit.
        /// </summary>
        public float Min
        {
            get { return _min; }
            set
            {
                _min = value;

                if (_max - _min != 0)
                    Percent = (_current - _min) / (_max - _min);
                else
                    Percent = 0;
            }
        }

        /// <summary>
        /// Upper limit for the slider.
        /// </summary>
        public float Max
        {
            get { return _max; }
            set
            {
                _max = value;

                if (_max - _min != 0)
                    Percent = (_current - _min) / (_max - _min);
                else
                    Percent = 0;
            }
        }

        /// <summary>
        /// Currently selected value bounded by the given Min and Max values.
        /// </summary>
        public float Current
        {
            get { return _current; }
            set
            {
                if (_max - _min != 0)
                    Percent = (value - _min) / (_max - _min);
                else
                    Percent = 0;
            }
        }

        /// <summary>
        /// Position of the slider given as a percentage. At 0, the slider will be at its minimum value;
        /// at 1, the slider will be at the given maximum value.
        /// </summary>
        public float Percent
        {
            get { return _percent; }
            set
            {
                _percent = MathHelper.Clamp(value, 0f, 1f);
                _current = _percent * (Max - Min) + Min;

                UpdateButtonOffset();
            }
        }

        /// <summary>
        /// If true then the slider will change to its set highlight color when moused over.
        /// </summary>
        public bool EnableHighlight { get; set; }

        /// <summary>
        /// Color of the slider bar
        /// </summary>
        public Color BarColor { get; set; }

        /// <summary>
        /// Bar color when moused over
        /// </summary>
        public Color BarHighlight { get; set; }

        /// <summary>
        /// Color of the slider box when not moused over
        /// </summary>
        public Color SliderColor { get; set; }

        /// <summary>
        /// Color of the slider button when moused over
        /// </summary>
        public Color SliderHighlight { get; set; }

        /// <summary>
        /// Size of the slider bar
        /// </summary>
        public Vector2 BarSize { get { return _barSize; } set { _barSize = value; } }

        /// <summary>
        /// Width of the slider bar
        /// </summary>
        public float BarWidth { get { return _barSize.X; } set { _barSize.X = value; } }

        /// <summary>
        /// Height of the slider bar
        /// </summary>
        public float BarHeight { get { return _barSize.Y; } set { _barSize.Y = value; } }

        /// <summary>
        /// Size of the slider button
        /// </summary>
        public Vector2 SliderSize { get { return _sliderSize; } set { _sliderSize = value; } }

        /// <summary>
        /// Width of the slider button.
        /// </summary>
        public float SliderWidth { get { return _sliderSize.X; } set { _sliderSize.X = value; } }

        /// <summary>
        /// Height of the slider button
        /// </summary>
        public float SliderHeight { get { return _sliderSize.Y; } set { _sliderSize.Y = value; } }

        /// <summary>
        /// Determines whether or not the slider button is currently visible
        /// </summary>
        public bool SliderVisible { get; set; }

        /// <summary>
        /// If true, the slider will be oriented vertically s.t. the slider moves up and down.
        /// </summary>
        public bool Vertical { get; set; }

        /// <summary>
        /// Reverses the direction of the slider w/respect to its value.
        /// </summary>
        public bool Reverse { get; set; }

        /// <summary>
        /// Indicates whether or not the hud element is currently moused over
        /// </summary>
        public override bool IsMousedOver => mouseInput.IsMousedOver;

        /// <summary>
        /// Handles mouse input for the slider bar
        /// </summary>
        public IMouseInput MouseInput => mouseInput;

        protected readonly TexturedBox slider, bar;
        protected readonly MouseInputElement mouseInput;
        protected Vector2 _barSize, _sliderSize;
        protected Vector2 startCursorOffset, lastPos;

        protected float _min, _max, _current, _percent;
        protected bool canMoveSlider;

        public SliderBar(HudParentBase parent) : base(parent)
        {
            bar = new TexturedBox(this);
            slider = new TexturedBox(bar) { UseCursor = true, ShareCursor = true };
            mouseInput = new MouseInputElement(this) { DimAlignment = DimAlignments.Both };

            _barSize = new Vector2(100f, 12f);
            _sliderSize = new Vector2(6f, 12f);
            SliderVisible = true;

            bar.Size = _barSize;
            slider.Size = _sliderSize;

            SliderColor = new Color(180, 180, 180, 255);
            BarColor = new Color(140, 140, 140, 255);
            SliderHighlight = new Color(200, 200, 200, 255);
            EnableHighlight = true;

            _min = 0f;
            _max = 1f;

            Current = 0f;
            Percent = 0f;
        }

        public SliderBar() : this(null)
        { }

        protected override void HandleInput(Vector2 cursorPos)
        {
            if (!canMoveSlider && mouseInput.IsNewLeftClicked)
            {
                canMoveSlider = true;

                if (slider.IsMousedOver)
                    startCursorOffset = cursorPos - slider.Position;
                else
                    startCursorOffset = Vector2.Zero;
            }
            else if (canMoveSlider && !SharedBinds.LeftButton.IsPressed)
            {
                canMoveSlider = false;
            }
        }

        protected override void Layout()
        {
            Vector3 fullCurosrPos = HudSpace.CursorPos;
            Vector2 cursorPos = new Vector2(fullCurosrPos.X, fullCurosrPos.Y);

            bar.Size = _barSize;
            slider.Size = _sliderSize;
            slider.Visible = SliderVisible;

            if (EnableHighlight && (IsMousedOver || canMoveSlider))
            {
                slider.Color = SliderHighlight;

                if (BarHighlight != default(Color))
                    bar.Color = BarHighlight;
            }
            else
            {
                slider.Color = SliderColor;
                bar.Color = BarColor;
            }

            if (canMoveSlider && (cursorPos - lastPos).LengthSquared() > 4f)
            {
                float minOffset, maxOffset, pos;
                lastPos = cursorPos;
                cursorPos -= startCursorOffset;

                if (Vertical)
                {
                    minOffset = -((_barSize.Y - _sliderSize.Y) * .5f);
                    maxOffset = -minOffset;
                    pos = MathHelper.Clamp(cursorPos.Y - Origin.Y, minOffset, maxOffset);
                }
                else
                {
                    minOffset = -((_barSize.X - _sliderSize.X) * .5f);
                    maxOffset = -minOffset;
                    pos = MathHelper.Clamp(cursorPos.X - Origin.X, minOffset, maxOffset);
                }

                if (Reverse)
                    Percent = 1f - ((pos - minOffset) / (maxOffset - minOffset));
                else 
                    Percent = (pos - minOffset) / (maxOffset - minOffset);
            }

            UpdateButtonOffset();
        }

        private void UpdateButtonOffset()
        {
            if (Vertical)
            {
                if (Reverse)
                    slider.Offset = new Vector2(0f, -(Percent - .5f) * (_barSize.Y - _sliderSize.Y));
                else
                    slider.Offset = new Vector2(0f, (Percent - .5f) * (_barSize.Y - _sliderSize.Y));
            }
            else
            {
                if (Reverse)
                    slider.Offset = new Vector2(-(Percent - .5f) * (_barSize.X - _sliderSize.X), 0f);
                else
                    slider.Offset = new Vector2((Percent - .5f) * (_barSize.X - _sliderSize.X), 0f);
            }
        }
    }
}﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Interface for objects acting as containers of UI elements
    /// </summary>
    public interface IHudElementContainer<TElement> where TElement : HudNodeBase
    {
        /// <summary>
        /// HUD Element associated with the container
        /// </summary>
        TElement Element { get; }

        /// <summary>
        /// Sets the element associated with the container. Should only
        /// allow one assignment.
        /// </summary>
        void SetElement(TElement Element);
    }
}
﻿using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework.UI
{
    /// <summary>
    /// Interface implemented by objects that function as list box entries.
    /// </summary>
    public interface IListBoxEntry<TElement, TValue>
        : ISelectionBoxEntryTuple<TElement, TValue>
        where TElement : HudElementBase, IMinLabelElement
    {
        object GetOrSetMember(object data, int memberEnum);
    }
}﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Interface for scrollbox entry containers.
    /// </summary>
    public interface IScrollBoxEntry<TElement> : IHudElementContainer<TElement> 
        where TElement : HudElementBase
    {
        bool Enabled { get; set; }
    }

    public interface IScrollBoxEntryTuple<TElement, TData> : IScrollBoxEntry<TElement> 
        where TElement : HudElementBase
    {
        TData AssocMember { get; set; }
    }
}﻿using System;
using System.Text;
using VRage;
using System.Collections.Generic;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework.UI
{
    /// <summary>
    /// HUD element container that functions as a list entry in Selection Box types.
    /// </summary>
    public interface ISelectionBoxEntry<TElement> : IScrollBoxEntry<TElement>
         where TElement : HudElementBase
    {
        bool AllowHighlighting { get; set; }

        void Reset();
    }

    /// <summary>
    /// HUD element container that functions as a list entry in Selection Box types with data tuples.
    /// </summary>
    public interface ISelectionBoxEntryTuple<TElement, TValue>
        : ISelectionBoxEntry<TElement>, IScrollBoxEntryTuple<TElement, TValue>
        where TElement : HudElementBase
    { }

}
﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Base container class for <see cref="HudChain"/> members. Can be extended to associate data with chain
    /// elements.
    /// </summary>
    public class HudElementContainer<TElement> : IHudElementContainer<TElement> where TElement : HudNodeBase
    {
        public virtual TElement Element { get; private set; }

        public HudElementContainer()
        { }

        public virtual void SetElement(TElement element)
        {
            if (Element == null)
                Element = element;
            else
                throw new System.Exception("Only one element can ever be associated with a container object.");
        }
    }

    /// <summary>
    /// Base container class for <see cref="HudChain"/> members. Can be extended to associate data with chain
    /// elements.
    /// </summary>
    public class HudElementContainer : HudElementContainer<HudElementBase>
    { }
}
﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Basic container class used to associate a <see cref="HudChain"/> element with an arbitrary object
    /// of type TData.
    /// </summary>
    public class HudElementTuple<TElement, TData> : HudElementContainer<TElement> where TElement : HudElementBase
    {
        public virtual TData AssocData { get; set; }

        public HudElementTuple()
        { }
    }

    /// <summary>
    /// Basic container class used to associate a <see cref="HudChain"/> element with an arbitrary object
    /// of type TData.
    /// </summary>
    public class HudElementTuple<TData> : HudElementTuple<HudElementBase, TData> 
    { }
}
﻿using System;
using System.Text;
using VRage;
using System.Collections.Generic;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework.UI
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    /// <summary>
    /// Label assocated with an object of type T. Used in conjunction with list boxes.
    /// </summary>
    public class ListBoxEntry<TValue> : ListBoxEntry<Label, TValue>
    { }

    public class ListBoxEntry<TElement, TValue>
        : SelectionBoxEntryTuple<TElement, TValue>, IListBoxEntry<TElement, TValue>
        where TElement : HudElementBase, IMinLabelElement, new()
    {
        public ListBoxEntry()
        {
            SetElement(new TElement());
            Element.TextBoard.AutoResize = false;
        }

        public override void Reset()
        {
            Enabled = true;
            AllowHighlighting = true;
            AssocMember = default(TValue);
            Element.TextBoard.Clear();
        }

        public object GetOrSetMember(object data, int memberEnum)
        {
            var member = (ListBoxEntryAccessors)memberEnum;

            switch (member)
            {
                case ListBoxEntryAccessors.Name:
                    {
                        if (data != null)
                            Element.TextBoard.SetText(data as List<RichStringMembers>);
                        else
                            return Element.TextBoard.GetText().apiData;

                        break;
                    }
                case ListBoxEntryAccessors.Enabled:
                    {
                        if (data != null)
                            Enabled = (bool)data;
                        else
                            return Enabled;

                        break;
                    }
                case ListBoxEntryAccessors.AssocObject:
                    {
                        if (data != null)
                            AssocMember = (TValue)data;
                        else
                            return AssocMember;

                        break;
                    }
                case ListBoxEntryAccessors.ID:
                        return this;
            }

            return null;
        }
    }
}﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Base container class for scrollbox members. Can be extended to associate data with ScrollBox
    /// elements.
    /// </summary>
    public class ScrollBoxEntry<TElement> : HudElementContainer<TElement>, IScrollBoxEntry<TElement> 
        where TElement : HudElementBase
    {
        public virtual bool Enabled { get; set; }

        public ScrollBoxEntry()
        {
            Enabled = true;
        }
    }

    /// <summary>
    /// Base container class for scrollbox members. Can be extended to associate data with ScrollBox
    /// elements.
    /// </summary>
    public class ScrollBoxEntry : ScrollBoxEntry<HudElementBase>
    { }
}﻿namespace RichHudFramework.UI
{
    /// <summary>
    /// Basic container class used to associate a scrollbox element with an arbitrary object
    /// of type TData.
    /// </summary>
    public class ScrollBoxEntryTuple<TElement, TData> 
        : ScrollBoxEntry<TElement>, IScrollBoxEntryTuple<TElement, TData> 
        where TElement : HudElementBase
    {
        /// <summary>
        /// Object associated with the entry
        /// </summary>
        public virtual TData AssocMember { get; set; }

        public ScrollBoxEntryTuple()
        { }
    }

    /// <summary>
    /// Basic container class used to associate a scrollbox element with an arbitrary object
    /// of type TData.
    /// </summary>
    public class ScrollBoxEntryTuple<TData> : ScrollBoxEntryTuple<HudElementBase, TData> 
    { }
}﻿using System;
using System.Text;
using VRage;
using System.Collections.Generic;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework.UI
{
    public class SelectionBoxEntry<TElement> : HudElementContainer<TElement>, ISelectionBoxEntry<TElement>
        where TElement : HudElementBase
    {
        public virtual bool Enabled { get; set; }

        public virtual bool AllowHighlighting { get; set; }

        public SelectionBoxEntry()
        {
            Enabled = true;
            AllowHighlighting = true;
        }

        public virtual void Reset()
        {
            Enabled = true;
            AllowHighlighting = true;
        }
    }

    public class SelectionBoxEntryTuple<TElement, TValue>
        : SelectionBoxEntry<TElement>, ISelectionBoxEntryTuple<TElement, TValue>
        where TElement : HudElementBase
    {
        public TValue AssocMember { get; set; }

        public override void Reset()
        {
            Enabled = true;
            AllowHighlighting = true;
            AssocMember = default(TValue);
        }
    }

}
﻿using Sandbox.ModAPI;
using System;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        /// <summary>
        /// HUD Space Node used to generate draw matrices based on the camera's world matrix.
        /// Equivalent to HudMain.PixelToWorld in its default configuration.
        /// </summary>
        public class CamSpaceNode : HudSpaceNodeBase
        {
            /// <summary>
            /// Scaling applied on the XY plane of the node's transform.
            /// </summary>
            public float PlaneScale { get; set; }

            /// <summary>
            /// Gets/sets axis the node's transform is rotated about, starting from the matrix's
            /// origin.
            /// </summary>
            public Vector3 RotationAxis { get; set; }

            /// <summary>
            /// Rotation about the axis in radians
            /// </summary>
            public float RotationAngle { get; set; }

            /// <summary>
            /// Displacement of the matrix, in meters, from the camera
            /// </summary>
            public Vector3D TransformOffset { get; set; }

            /// <summary>
            /// If enabled, the matrix's plane will be rescaled to compensate for fov and
            /// resolution s.t. 1 unit == 1 pixel on the near plane.
            /// </summary>
            public bool IsScreenSpace { get; set; }

            /// <summary>
            /// If enabled, HudMain.ResScale will be used to rescale the matrix to compensate
            /// for high PPI displays. Requires IsScreenSpace == true.
            /// </summary>
            public bool UseResScaling { get; set; }

            public CamSpaceNode(HudParentBase parent = null) : base(parent)
            {
                PlaneScale = 1f;
                TransformOffset = new Vector3D(0d, 0d, -MyAPIGateway.Session.Camera.NearPlaneDistance);

                IsScreenSpace = true;
                UseResScaling = true;
            }

            protected override void Layout()
            {
                double scale = PlaneScale;

                if (IsScreenSpace)
                {
                    scale *= HudMain.FovScale / HudMain.ScreenHeight;

                    if (UseResScaling)
                        scale *= HudMain.ResScale;
                }

                var scaling = MatrixD.CreateScale(scale, scale, 1d);
                var rotation = MatrixD.CreateFromQuaternion(Quaternion.CreateFromAxisAngle(RotationAxis, RotationAngle));
                var translation = MatrixD.CreateTranslation(TransformOffset);

                PlaneToWorldRef[0] = (scaling * rotation * translation) * MyAPIGateway.Session.Camera.WorldMatrix;
                base.Layout();
            }
        }
    }
}
﻿using System;
using VRage;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// HUD node used to replace the standard Pixel to World matrix with an arbitrary
        /// world matrix transform given by a user-supplied delegate.
        /// </summary>
        public class CustomSpaceNode : HudSpaceNodeBase
        {
            /// <summary>
            /// Used to update the current draw matrix. If no delegate is set, the node will default
            /// to the matrix supplied by its parent.
            /// </summary>
            public Func<MatrixD> UpdateMatrixFunc { get; set; }

            public CustomSpaceNode(HudParentBase parent = null) : base(parent)
            { }

            protected override void Layout()
            {
                if (UpdateMatrixFunc != null)
                    PlaneToWorldRef[0] = UpdateMatrixFunc();
                else if (Parent?.HudSpace != null)
                    PlaneToWorldRef[0] = Parent.HudSpace.PlaneToWorldRef[0];

                base.Layout();
            }
        }
    }
}
﻿using Sandbox.ModAPI;
using System;
using VRage;
using VRage.ModAPI;
using VRageMath;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        /// <summary>
        /// HUD node used to rescale the plane to world matrix of a given parent space.
        /// </summary>
        public class ScaledSpaceNode : HudSpaceNodeBase
        {
            /// <summary>
            /// Scaling applied on the XY plane of the node's transform.
            /// </summary>
            public float PlaneScale { get; set; }

            public Func<float> UpdateScaleFunc { get; set; }

            public ScaledSpaceNode(HudParentBase parent = null) : base(parent)
            { }

            protected override void Layout()
            {
                if (UpdateScaleFunc != null)
                    PlaneScale = UpdateScaleFunc();

                IReadOnlyHudSpaceNode parentSpace = _parent.HudSpace;

                PlaneToWorldRef[0] = MatrixD.CreateScale(PlaneScale, PlaneScale, 1d) * parentSpace.PlaneToWorldRef[0];
                IsInFront = parentSpace.IsInFront;
                IsFacingCamera = parentSpace.IsFacingCamera;

                CursorPos = parentSpace.CursorPos / PlaneScale;
            }
        }
    }
}
﻿using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using VRage.Utils;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        namespace Rendering
        {
            /// <summary>
            /// Material data for rendering individual triangles.
            /// </summary>
            public struct TriMaterial
            {
                public static readonly TriMaterial Default = new TriMaterial()
                {
                    textureID = Material.Default.TextureID,
                    bbColor = Vector4.One,
                    texCoords = new Triangle(
                        new Vector2(0f, 0f),
                        new Vector2(0f, 1f),
                        new Vector2(1f, 0f)
                    )
                };

                /// <summary>
                /// Material ID used by billboards
                /// </summary>
                public MyStringId textureID;

                /// <summary>
                /// Normalized Linear RGB color
                /// </summary>
                public Vector4 bbColor;

                /// <summary>
                /// Normalized texture coordinates
                /// </summary>
                public Triangle texCoords;
            }

            /// <summary>
            /// Material data for rendering quads.
            /// </summary>
            public struct QuadMaterial
            {
                public static readonly QuadMaterial Default = new QuadMaterial()
                {
                    textureID = Material.Default.TextureID,
                    bbColor = Vector4.One,
                    texCoords = new FlatQuad(
                        new Vector2(0f, 0f),
                        new Vector2(0f, 1f),
                        new Vector2(1f, 0f),
                        new Vector2(1f, 1f)
                    )
                };

                /// <summary>
                /// Material ID used by billboards
                /// </summary>
                public MyStringId textureID;

                /// <summary>
                /// Normalized Linear RGB color
                /// </summary>
                public Vector4 bbColor;

                /// <summary>
                /// Normalized texture coordinates
                /// </summary>
                public FlatQuad texCoords;
            }

            /// <summary>
            /// Material data for rendering quads with texture coordinates defined by a bounding box.
            /// </summary>
            public struct BoundedQuadMaterial
            {
                public static readonly BoundedQuadMaterial Default = new BoundedQuadMaterial()
                {
                    textureID = Material.Default.TextureID,
                    bbColor = Vector4.One,
                    texBounds = new BoundingBox2(Vector2.Zero, Vector2.One)
                };

                /// <summary>
                /// Material ID used by billboards
                /// </summary>
                public MyStringId textureID;

                /// <summary>
                /// Normalized Linear RGB color
                /// </summary>
                public Vector4 bbColor;

                /// <summary>
                /// Determines the scale and aspect ratio of the texture as rendered
                /// </summary>
                public BoundingBox2 texBounds;
            }

            /// <summary>
            /// Material data for rendering polygons.
            /// </summary>
            public struct PolyMaterial
            {
                public static readonly PolyMaterial Default = new PolyMaterial()
                {
                    textureID = Material.Default.TextureID,
                    bbColor = Vector4.One,
                    texCoords = null
                };

                /// <summary>
                /// Material ID used by billboards
                /// </summary>
                public MyStringId textureID;

                /// <summary>
                /// Normalized Linear RGB color
                /// </summary>
                public Vector4 bbColor;

                /// <summary>
                /// Min/max texcoords
                /// </summary>
                public BoundingBox2 texBounds;

                /// <summary>
                /// Normalized texture coordinates
                /// </summary>
                public List<Vector2> texCoords;
            }

            /// <summary>
            /// Defines a quad comprised of four <see cref="Vector2"/>s.
            /// </summary>
            public struct FlatQuad
            {
                public Vector2 Point0, Point1, Point2, Point3;

                public FlatQuad(Vector2 Point0, Vector2 Point1, Vector2 Point2, Vector2 Point3)
                {
                    this.Point0 = Point0;
                    this.Point1 = Point1;
                    this.Point2 = Point2;
                    this.Point3 = Point3;
                }
            }

            /// <summary>
            /// A set of three vectors defining a triangle
            /// </summary>
            public struct Triangle
            {
                public Vector2 Point0, Point1, Point2;

                public Triangle(Vector2 Point0, Vector2 Point1, Vector2 Point2)
                {
                    this.Point0 = Point0;
                    this.Point1 = Point1;
                    this.Point2 = Point2;
                }
            }

            /// <summary>
            /// A set of three vectors defining a triangle
            /// </summary>
            public struct TriangleD
            {
                public Vector3D Point0, Point1, Point2;

                public TriangleD(Vector3D Point0, Vector3D Point1, Vector3D Point2)
                {
                    this.Point0 = Point0;
                    this.Point1 = Point1;
                    this.Point2 = Point2;
                }
            }
        }
    }
}﻿using System.Collections.Generic;
using System;
using System.Threading;
using Sandbox.ModAPI;
using VRage.Game;
using VRage;
using VRage.Utils;
using VRageMath;
using VRageRender;
using RichHudFramework.Internal;
using BlendTypeEnum = VRageRender.MyBillboard.BlendTypeEnum;

namespace RichHudFramework
{
    namespace UI
    {
        using ApiMemberAccessor = System.Func<object, int, object>;
        using TriangleBillboardData = MyTuple<
            BlendTypeEnum, // blendType
            Vector2I, // bbID + matrixID
            MyStringId, // material
            Vector4, // color
            MyTuple<Vector2, Vector2, Vector2>, // texCoords
            MyTuple<Vector3D, Vector3D, Vector3D> // vertexPos
        >;
        using FlatTriangleBillboardData = MyTuple<
            BlendTypeEnum, // blendType
            Vector2I, // bbID + matrixID
            MyStringId, // material
            MyTuple<Vector4, BoundingBox2?>, // color + mask
            MyTuple<Vector2, Vector2, Vector2>, // texCoords
            MyTuple<Vector2, Vector2, Vector2> // flat pos
        >;

        namespace Rendering
        {
            public enum BillBoardUtilAccessors : int
            {
                /// <summary>
                /// out: List<MyTriangleBillboard>
                /// </summary>
                GetPoolBack = 1
            }

            public sealed partial class BillBoardUtils
            {
                #region 3D Billboards

                /// <summary>
                /// Renders a polygon from a given set of unique vertex coordinates. Triangles are defined by their
                /// indices and the tex coords are parallel to the vertex list.
                /// </summary>
                public static void AddTriangles(IReadOnlyList<int> indices, IReadOnlyList<Vector3D> vertices, ref PolyMaterial mat, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    int triangleCount = indices.Count / 3,
                        bbRemaining = bbPool.Count - bbDataBack.Count,
                        bbToAdd = Math.Max(triangleCount - bbRemaining, 0);

                    instance.AddNewBB(bbToAdd);

                    for (int i = bbDataBack.Count; i < triangleCount + bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        var bb = new TriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = mat.bbColor,
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texCoords[indices[i]],
                                mat.texCoords[indices[i + 1]],
                                mat.texCoords[indices[i + 2]]
                            ),
                            Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                            (
                                vertices[indices[i]],
                                vertices[indices[i + 1]],
                                vertices[indices[i + 2]]
                            ),
                        };
                        bbDataBack.Add(bb);
                    }
                }

                /// <summary>
                /// Adds a triangles in the given starting index range
                /// </summary>
                public static void AddTriangleRange(Vector2I range, IReadOnlyList<int> indices, IReadOnlyList<Vector3D> vertices, ref PolyMaterial mat, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    int iMax = indices.Count,
                        triangleCount = (range.Y - range.X) / 3,
                        bbRemaining = bbPool.Count - bbDataBack.Count,
                        bbToAdd = Math.Max(triangleCount - bbRemaining, 0);

                    instance.AddNewBB(bbToAdd);

                    for (int i = bbDataBack.Count; i < triangleCount + bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = range.X; i <= range.Y; i += 3)
                    {
                        var bb = new TriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = mat.bbColor,
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texCoords[indices[i % iMax]],
                                mat.texCoords[indices[(i + 1) % iMax]],
                                mat.texCoords[indices[(i + 2) % iMax]]
                            ),
                            Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                            (
                                vertices[indices[i % iMax]],
                                vertices[indices[(i + 1) % iMax]],
                                vertices[indices[(i + 2) % iMax]]
                            ),
                        };
                        bbDataBack.Add(bb);
                    }
                }

                /// <summary>
                /// Renders a polygon from a given set of unique vertex coordinates. Triangles are defined by their
                /// indices.
                /// </summary>
                public static void AddTriangles(IReadOnlyList<int> indices, IReadOnlyList<Vector3D> vertices, ref TriMaterial mat, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    int triangleCount = indices.Count / 3,
                        bbRemaining = bbPool.Count - bbDataBack.Count,
                        bbToAdd = Math.Max(triangleCount - bbRemaining, 0);

                    instance.AddNewBB(bbToAdd);

                    for (int i = bbDataBack.Count; i < triangleCount + bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        var bb = new TriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = mat.bbColor,
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texCoords.Point0,
                                mat.texCoords.Point1,
                                mat.texCoords.Point2
                            ),
                            Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                            (
                                vertices[indices[i]],
                                vertices[indices[i + 1]],
                                vertices[indices[i + 2]]
                            ),
                        };
                        bbDataBack.Add(bb);
                    }
                }

                /// <summary>
                /// Adds a list of textured quads in one batch using QuadBoard data
                /// </summary>
                public static void AddQuads(IReadOnlyList<QuadBoardData> quads, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    int triangleCount = quads.Count * 2,
                        bbRemaining = bbPool.Count - bbDataBack.Count,
                        bbToAdd = Math.Max(triangleCount - bbRemaining, 0);

                    instance.AddNewBB(bbToAdd);

                    for (int i = bbDataBack.Count; i < triangleCount + bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = 0; i < quads.Count; i++)
                    {
                        QuadBoardData quadBoard = quads[i];
                        MyQuadD quad = quadBoard.positions;
                        BoundedQuadMaterial mat = quadBoard.material;

                        var bbL = new TriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = mat.bbColor,
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texBounds.Min,
                                mat.texBounds.Min + new Vector2(0f, mat.texBounds.Size.Y),
                                mat.texBounds.Max
                            ),
                            Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                            (
                                quad.Point0,
                                quad.Point1,
                                quad.Point2
                            ),

                        };
                        var bbR = new TriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count + 1, matrixID),
                            Item3 = mat.textureID,
                            Item4 = mat.bbColor,
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texBounds.Min,
                                mat.texBounds.Max,
                                mat.texBounds.Min + new Vector2(mat.texBounds.Size.X, 0f)
                            ),
                            Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                            (
                                quad.Point0,
                                quad.Point2,
                                quad.Point3
                            ),
                        };

                        bbDataBack.Add(bbL);
                        bbDataBack.Add(bbR);
                    }
                }

                /// <summary>
                /// Adds a triangle starting at the given index.
                /// </summary>
                public static void AddTriangle(int start, IReadOnlyList<int> indices, IReadOnlyList<Vector3D> vertices, ref TriMaterial mat, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    int index = bbDataBack.Count;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    var bb = new TriangleBillboardData
                    {
                        Item1 = BlendTypeEnum.PostPP,
                        Item2 = new Vector2I(index, matrixID),
                        Item3 = mat.textureID,
                        Item4 = mat.bbColor,
                        Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texCoords.Point0,
                                mat.texCoords.Point1,
                                mat.texCoords.Point2
                            ),
                        Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                            (
                                vertices[indices[start]],
                                vertices[indices[start + 1]],
                                vertices[indices[start + 2]]
                            ),
                    };
                    bbDataBack.Add(bb);

                    if (index >= bbPool.Count)
                        instance.AddNewBB(index - (bbPool.Count - 1));

                    MyTransparentGeometry.AddBillboard(bbPool[index], false);
                }

                /// <summary>
                /// Queues a single triangle billboard for rendering
                /// </summary>
                public static void AddTriangle(ref TriMaterial mat, ref TriangleD triangle, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    int index = bbDataBack.Count;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    var bb = new TriangleBillboardData
                    {
                        Item1 = BlendTypeEnum.PostPP,
                        Item2 = new Vector2I(index, matrixID),
                        Item3 = mat.textureID,
                        Item4 = mat.bbColor,
                        Item5 = new MyTuple<Vector2, Vector2, Vector2>
                        (
                            mat.texCoords.Point0,
                            mat.texCoords.Point1,
                            mat.texCoords.Point2
                        ),
                        Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                        (
                            triangle.Point0,
                            triangle.Point1,
                            triangle.Point2
                        ),
                    };
                    bbDataBack.Add(bb);

                    if (index >= bbPool.Count)
                        instance.AddNewBB(index - (bbPool.Count - 1));

                    MyTransparentGeometry.AddBillboard(bbPool[index], false);
                }

                /// <summary>
                /// Queues a quad billboard for rendering
                /// </summary>
                public static void AddQuad(ref QuadMaterial mat, ref MyQuadD quad, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    int indexL = bbDataBack.Count,
                        indexR = bbDataBack.Count + 1;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    var bbL = new TriangleBillboardData
                    {
                        Item1 = BlendTypeEnum.PostPP,
                        Item2 = new Vector2I(indexL, matrixID),
                        Item3 = mat.textureID,
                        Item4 = mat.bbColor,
                        Item5 = new MyTuple<Vector2, Vector2, Vector2>
                        (
                            mat.texCoords.Point0,
                            mat.texCoords.Point1,
                            mat.texCoords.Point2
                        ),
                        Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                        (
                            quad.Point0,
                            quad.Point1,
                            quad.Point2
                        ),
                    };
                    var bbR = new TriangleBillboardData
                    {
                        Item1 = BlendTypeEnum.PostPP,
                        Item2 = new Vector2I(indexR, matrixID),
                        Item3 = mat.textureID,
                        Item4 = mat.bbColor,
                        Item5 = new MyTuple<Vector2, Vector2, Vector2>
                        (
                            mat.texCoords.Point0,
                            mat.texCoords.Point2,
                            mat.texCoords.Point3
                        ),
                        Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                        (
                            quad.Point0,
                            quad.Point2,
                            quad.Point3
                        ),
                    };

                    bbDataBack.Add(bbL);
                    bbDataBack.Add(bbR);

                    if (indexR >= bbPool.Count)
                        instance.AddNewBB(indexR - (bbPool.Count - 1));

                    MyTransparentGeometry.AddBillboard(bbPool[indexL], false);
                    MyTransparentGeometry.AddBillboard(bbPool[indexR], false);
                }

                /// <summary>
                /// Queues a quad billboard for rendering
                /// </summary>
                public static void AddQuad(ref BoundedQuadMaterial mat, ref MyQuadD quad, MatrixD[] matrixRef = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.triangleList;
                    int indexL = bbDataBack.Count,
                        indexR = bbDataBack.Count + 1;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID = -1;

                    if (matrixRef != null && !matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    var bbL = new TriangleBillboardData
                    {
                        Item1 = BlendTypeEnum.PostPP,
                        Item2 = new Vector2I(indexL, matrixID),
                        Item3 = mat.textureID,
                        Item4 = mat.bbColor,
                        Item5 = new MyTuple<Vector2, Vector2, Vector2>
                        (
                            mat.texBounds.Min,
                            mat.texBounds.Min + new Vector2(0f, mat.texBounds.Size.Y),
                            mat.texBounds.Max
                        ),
                        Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                        (
                            quad.Point0,
                            quad.Point1,
                            quad.Point2
                        ),
                    };
                    var bbR = new TriangleBillboardData
                    {
                        Item1 = BlendTypeEnum.PostPP,
                        Item2 = new Vector2I(indexR, matrixID),
                        Item3 = mat.textureID,
                        Item4 = mat.bbColor,
                        Item5 = new MyTuple<Vector2, Vector2, Vector2>
                        (
                            mat.texBounds.Min,
                            mat.texBounds.Max,
                            mat.texBounds.Min + new Vector2(mat.texBounds.Size.X, 0f)
                        ),
                        Item6 = new MyTuple<Vector3D, Vector3D, Vector3D>
                        (
                            quad.Point0,
                            quad.Point2,
                            quad.Point3
                        ),
                    };

                    bbDataBack.Add(bbL);
                    bbDataBack.Add(bbR);

                    if (indexR >= bbPool.Count)
                        instance.AddNewBB(indexR - (bbPool.Count - 1));

                    MyTransparentGeometry.AddBillboard(bbPool[indexL], false);
                    MyTransparentGeometry.AddBillboard(bbPool[indexR], false);
                }

                #endregion

                #region 2D Billboards

                /// <summary>
                /// Renders a polygon from a given set of unique vertex coordinates. Triangles are defined by their
                /// indices and the tex coords are parallel to the vertex list.
                /// </summary>
                public static void AddTriangles(IReadOnlyList<int> indices, IReadOnlyList<Vector2> vertices, ref PolyMaterial mat, MatrixD[] matrixRef)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.flatTriangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID;

                    if (!matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    // Get triangle count, ensure enough billboards are in the pool and add them to the
                    // render queue before writing QB data to buffer
                    int triangleCount = indices.Count / 3,
                        bbRemaining = bbPool.Count - bbDataBack.Count,
                        bbToAdd = Math.Max(triangleCount - bbRemaining, 0);

                    instance.AddNewBB(bbToAdd);

                    for (int i = bbDataBack.Count; i < triangleCount + bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = 0; i < indices.Count; i += 3)
                    {
                        var bb = new FlatTriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, null),
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texCoords[indices[i]],
                                mat.texCoords[indices[i + 1]],
                                mat.texCoords[indices[i + 2]]
                            ),
                            Item6 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                vertices[indices[i]],
                                vertices[indices[i + 1]],
                                vertices[indices[i + 2]]
                            ),
                        };
                        bbDataBack.Add(bb);
                    }
                }

                /// <summary>
                /// Adds a triangles in the given starting index range
                /// </summary>
                public static void AddTriangleRange(Vector2I range, IReadOnlyList<int> indices, IReadOnlyList<Vector2> vertices, ref PolyMaterial mat, MatrixD[] matrixRef)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.flatTriangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID;

                    if (!matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    // Get triangle count, ensure enough billboards are in the pool and add them to the
                    // render queue before writing QB data to buffer
                    int iMax = indices.Count,
                        triangleCount = (range.Y - range.X) / 3,
                        bbRemaining = bbPool.Count - bbDataBack.Count,
                        bbToAdd = Math.Max(triangleCount - bbRemaining, 0);

                    instance.AddNewBB(bbToAdd);

                    for (int i = bbDataBack.Count; i < triangleCount + bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = range.X; i <= range.Y; i += 3)
                    {
                        var bb = new FlatTriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, null),
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                mat.texCoords[indices[i % iMax]],
                                mat.texCoords[indices[(i + 1) % iMax]],
                                mat.texCoords[indices[(i + 2) % iMax]]
                            ),
                            Item6 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                vertices[indices[i % iMax]],
                                vertices[indices[(i + 1) % iMax]],
                                vertices[indices[(i + 2) % iMax]]
                            ),
                        };
                        bbDataBack.Add(bb);
                    }
                }

                /// <summary>
                /// Adds a list of textured quads in one batch using QuadBoard data
                /// </summary>
                public static void AddQuads(IReadOnlyList<BoundedQuadBoard> quads, MatrixD[] matrixRef, BoundingBox2? mask = null,
                    Vector2 offset = default(Vector2), float scale = 1f)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.flatTriangleList;
                    var bbBuf = instance.bbBuf;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID;

                    if (!matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    int triangleCount = quads.Count * 2,
                        bbCountStart = bbDataBack.Count;

                    bbDataBack.EnsureCapacity(bbDataBack.Count + triangleCount);

                    for (int i = 0; i < quads.Count; i++)
                    {
                        BoundedQuadBoard boundedQB = quads[i];
                        BoundedQuadMaterial mat = boundedQB.quadBoard.materialData;
                        Vector2 size = boundedQB.bounds.Size * scale,
                            center = offset + boundedQB.bounds.Center * scale;

                        BoundingBox2 bounds = BoundingBox2.CreateFromHalfExtent(center, .5f * size);
                        BoundingBox2? maskBox = mask;
                        ContainmentType containment = ContainmentType.Contains;

                        if (maskBox != null)
                        {
                            maskBox.Value.Contains(ref bounds, out containment);

                            if (containment == ContainmentType.Contains)
                                maskBox = null;
                        }

                        if (containment != ContainmentType.Disjoint)
                        {
                            var bbL = new FlatTriangleBillboardData
                            {
                                Item1 = BlendTypeEnum.PostPP,
                                Item2 = new Vector2I(bbDataBack.Count, matrixID),
                                Item3 = mat.textureID,
                                Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, maskBox),
                                Item5 = new MyTuple<Vector2, Vector2, Vector2>
                                (
                                    new Vector2(mat.texBounds.Max.X, mat.texBounds.Min.Y), // 1
                                    mat.texBounds.Max, // 0
                                    new Vector2(mat.texBounds.Min.X, mat.texBounds.Max.Y) // 3
                                ),
                                Item6 = new MyTuple<Vector2, Vector2, Vector2>
                                (
                                    bounds.Max,
                                    new Vector2(bounds.Max.X, bounds.Min.Y),
                                    bounds.Min
                                ),
                            };
                            var bbR = new FlatTriangleBillboardData
                            {
                                Item1 = BlendTypeEnum.PostPP,
                                Item2 = new Vector2I(bbDataBack.Count + 1, matrixID),
                                Item3 = mat.textureID,
                                Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, maskBox),
                                Item5 = new MyTuple<Vector2, Vector2, Vector2>
                                (
                                    new Vector2(mat.texBounds.Max.X, mat.texBounds.Min.Y), // 1
                                    new Vector2(mat.texBounds.Min.X, mat.texBounds.Max.Y), // 3
                                    mat.texBounds.Min // 2
                                ),
                                Item6 = new MyTuple<Vector2, Vector2, Vector2>
                                (
                                    bounds.Max,
                                    bounds.Min,
                                    new Vector2(bounds.Min.X, bounds.Max.Y)
                                ),
                            };

                            bbDataBack.Add(bbL);
                            bbDataBack.Add(bbR);
                        }
                    }

                    // Add more billboards to pool as needed then queue them for rendering
                    int bbToAdd = Math.Max(bbDataBack.Count - bbPool.Count, 0);
                    instance.AddNewBB(bbToAdd);

                    for (int i = bbCountStart; i < bbDataBack.Count; i++)
                        bbBuf.Add(bbPool[i]);

                    MyTransparentGeometry.AddBillboards(bbBuf, false);
                    bbBuf.Clear();
                }

                /// <summary>
                /// Queues a quad billboard for rendering
                /// </summary>
                public static void AddQuad(ref BoundedQuadBoard boundedQB, MatrixD[] matrixRef, BoundingBox2? mask = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.flatTriangleList;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID;

                    if (!matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    // Mask bounding check. Null mask if not intersecting.
                    BoundingBox2? maskBox = mask;
                    ContainmentType containment = ContainmentType.Contains;

                    if (maskBox != null)
                    {
                        maskBox.Value.Contains(ref boundedQB.bounds, out containment);

                        if (containment == ContainmentType.Contains)
                            maskBox = null;
                    }

                    if (containment != ContainmentType.Disjoint)
                    {
                        int indexL = bbDataBack.Count,
                            indexR = bbDataBack.Count + 1;
                        BoundedQuadMaterial mat = boundedQB.quadBoard.materialData;

                        var bbL = new FlatTriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, maskBox),
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                new Vector2(mat.texBounds.Max.X, mat.texBounds.Min.Y), // 1
                                mat.texBounds.Max, // 0
                                new Vector2(mat.texBounds.Min.X, mat.texBounds.Max.Y) // 3
                            ),
                            Item6 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                boundedQB.bounds.Max,
                                new Vector2(boundedQB.bounds.Max.X, boundedQB.bounds.Min.Y),
                                boundedQB.bounds.Min
                            ),
                        };
                        var bbR = new FlatTriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count + 1, matrixID),
                            Item3 = mat.textureID,
                            Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, maskBox),
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                new Vector2(mat.texBounds.Max.X, mat.texBounds.Min.Y), // 1
                                new Vector2(mat.texBounds.Min.X, mat.texBounds.Max.Y), // 3
                                mat.texBounds.Min // 2
                            ),
                            Item6 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                boundedQB.bounds.Max,
                                boundedQB.bounds.Min,
                                new Vector2(boundedQB.bounds.Min.X, boundedQB.bounds.Max.Y)
                            ),
                        };

                        bbDataBack.Add(bbL);
                        bbDataBack.Add(bbR);

                        if (indexR >= bbPool.Count)
                            instance.AddNewBB(indexR - (bbPool.Count - 1));

                        MyTransparentGeometry.AddBillboard(bbPool[indexL], false);
                        MyTransparentGeometry.AddBillboard(bbPool[indexR], false);
                    }
                }

                /// <summary>
                /// Queues a quad billboard for rendering
                /// </summary>
                public static void AddQuad(ref FlatQuad quad, ref BoundedQuadMaterial mat, MatrixD[] matrixRef, BoundingBox2? mask = null)
                {
                    var bbPool = instance.bbPoolBack;
                    var bbDataBack = instance.flatTriangleList;
                    var matList = instance.matrixBuf;
                    var matTable = instance.matrixTable;

                    // Find matrix index in table or add it
                    int matrixID;

                    if (!matTable.TryGetValue(matrixRef, out matrixID))
                    {
                        matrixID = matList.Count;
                        matList.Add(matrixRef[0]);
                        matTable.Add(matrixRef, matrixID);
                    }

                    // Mask bounding check. Null mask if not intersecting.
                    BoundingBox2? maskBox = mask;
                    ContainmentType containment = ContainmentType.Contains;

                    if (maskBox != null)
                    {
                        BoundingBox2 bounds = new BoundingBox2(quad.Point2, quad.Point0);
                        maskBox.Value.Contains(ref bounds, out containment);

                        if (containment == ContainmentType.Contains)
                            maskBox = null;
                    }

                    if (containment != ContainmentType.Disjoint)
                    {
                        int indexL = bbDataBack.Count,
                            indexR = bbDataBack.Count + 1;

                        var bbL = new FlatTriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count, matrixID),
                            Item3 = mat.textureID,
                            Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, maskBox),
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                new Vector2(mat.texBounds.Max.X, mat.texBounds.Min.Y), // 1
                                mat.texBounds.Max, // 0
                                new Vector2(mat.texBounds.Min.X, mat.texBounds.Max.Y) // 3
                            ),
                            Item6 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                quad.Point0,
                                quad.Point1,
                                quad.Point2
                            ),
                        };
                        var bbR = new FlatTriangleBillboardData
                        {
                            Item1 = BlendTypeEnum.PostPP,
                            Item2 = new Vector2I(bbDataBack.Count + 1, matrixID),
                            Item3 = mat.textureID,
                            Item4 = new MyTuple<Vector4, BoundingBox2?>(mat.bbColor, maskBox),
                            Item5 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                new Vector2(mat.texBounds.Max.X, mat.texBounds.Min.Y), // 1
                                new Vector2(mat.texBounds.Min.X, mat.texBounds.Max.Y), // 3
                                mat.texBounds.Min // 2
                            ),
                            Item6 = new MyTuple<Vector2, Vector2, Vector2>
                            (
                                quad.Point0,
                                quad.Point2,
                                quad.Point3
                            ),
                        };

                        bbDataBack.Add(bbL);
                        bbDataBack.Add(bbR);

                        if (indexR >= bbPool.Count)
                            instance.AddNewBB(indexR - (bbPool.Count - 1));

                        MyTransparentGeometry.AddBillboard(bbPool[indexL], false);
                        MyTransparentGeometry.AddBillboard(bbPool[indexR], false);
                    }
                }

                #endregion

                /// <summary>
                /// Adds the given number of <see cref="MyTriangleBillboard"/>s to the pool
                /// </summary>
                private void AddNewBB(int count)
                {
                    bbPoolBack.EnsureCapacity(bbPoolBack.Count + count);

                    for (int i = 0; i < count; i++)
                    {
                        bbPoolBack.Add(new MyTriangleBillboard
                        {
                            BlendType = BlendTypeEnum.PostPP,
                            Position0 = Vector3D.Zero,
                            Position1 = Vector3D.Zero,
                            Position2 = Vector3D.Zero,
                            UV0 = Vector2.Zero,
                            UV1 = Vector2.Zero,
                            UV2 = Vector2.Zero,
                            Material = Material.Default.TextureID,
                            Color = Vector4.One,
                            DistanceSquared = float.PositiveInfinity,
                            ColorIntensity = 1f,
                            CustomViewProjection = -1
                        });
                    }
                }

                /// <summary>
                /// Converts a color to its normalized linear RGB equivalent. Assumes additive blending
                /// with premultiplied alpha.
                /// </summary>
                public static Vector4 GetBillBoardBoardColor(Color color)
                {
                    float opacity = color.A / 255f;

                    color.R = (byte)(color.R * opacity);
                    color.G = (byte)(color.G * opacity);
                    color.B = (byte)(color.B * opacity);

                    return ((Vector4)color).ToLinearRGB();
                }
            }
        }
    }
}﻿using VRageMath;
using System.Collections.Generic;

namespace RichHudFramework
{
    namespace UI
    {
        namespace Rendering
        {
            /// <summary>
            /// Draws a rectangular prism using billboards in world space.
            /// </summary>
            public class BlockBoard
            {
                /// <summary>
                /// Controls the dimensions of the block.
                /// </summary>
                public Vector3D Size { get; set; }

                /// <summary>
                /// Determines the distance of the block from the center of its transform.
                /// </summary>
                public Vector3D Offset { get; set; }

                /// <summary>
                /// Material board for the front face (-Z).
                /// </summary>
                public MatBoard Front => faces[0];

                /// <summary>
                /// Material board for the back face (+Z).
                /// </summary>
                public MatBoard Back => faces[1];

                /// <summary>
                /// Material board for the top face (+Y).
                /// </summary>
                public MatBoard Top => faces[2];

                /// <summary>
                /// Material board for the bottom face (-Y).
                /// </summary>
                public MatBoard Bottom => faces[3];

                /// <summary>
                /// Material board for the left face (-X).
                /// </summary>
                public MatBoard Left => faces[4];

                /// <summary>
                /// Material board for the right face (+X).
                /// </summary>
                public MatBoard Right => faces[5];

                /// <summary>
                /// Gets all six faces of the block as a read only list.
                /// </summary>
                public IReadOnlyList<MatBoard> Faces => faces;

                private readonly MatBoard[] faces;
                private readonly Vector3D[] octant;

                public BlockBoard()
                {
                    faces = new MatBoard[6];
                    octant = new Vector3D[8];

                    for (int n = 0; n < 6; n++)
                        faces[n] = new MatBoard();
                }

                /// <summary>
                /// Sets the color for every face.
                /// </summary>
                public void SetColor(Color color)
                {
                    for (int n = 0; n < 6; n++)
                        faces[n].Color = color;
                }

                /// <summary>
                /// Sets every face to the given material.
                /// </summary>
                public void SetMaterial(Material material)
                {
                    for (int n = 0; n < 6; n++)
                        faces[n].Material = material;
                }

                /// <summary>
                /// Sets every face's material alignment.
                /// </summary>
                public void SetMaterialAlignment(MaterialAlignment materialAlignment)
                {
                    for (int n = 0; n < 6; n++)
                        faces[n].MatAlignment = materialAlignment;
                }

                /// <summary>
                /// Draws a block made of billboards in world space using the given matrix transform.
                /// </summary>
                public void Draw(ref MatrixD matrix)
                {
                    MyQuadD faceQuad;
                    UpdateOctant(ref matrix);

                    // -Z/+Z
                    faceQuad.Point0 = octant[3];
                    faceQuad.Point1 = octant[2];
                    faceQuad.Point2 = octant[1];
                    faceQuad.Point3 = octant[0];

                    faces[0].Draw(ref faceQuad);

                    faceQuad.Point0 = octant[4];
                    faceQuad.Point1 = octant[5];
                    faceQuad.Point2 = octant[6];
                    faceQuad.Point3 = octant[7];

                    faces[1].Draw(ref faceQuad);

                    // -Y/+Y
                    faceQuad.Point0 = octant[7];
                    faceQuad.Point1 = octant[6];
                    faceQuad.Point2 = octant[2];
                    faceQuad.Point3 = octant[3];

                    faces[2].Draw(ref faceQuad);

                    faceQuad.Point0 = octant[0];
                    faceQuad.Point1 = octant[1];
                    faceQuad.Point2 = octant[5];
                    faceQuad.Point3 = octant[4];

                    faces[3].Draw(ref faceQuad);

                    // -X/+X
                    faceQuad.Point0 = octant[0];
                    faceQuad.Point1 = octant[4];
                    faceQuad.Point2 = octant[7];
                    faceQuad.Point3 = octant[3];

                    faces[4].Draw(ref faceQuad);

                    faceQuad.Point0 = octant[5];
                    faceQuad.Point1 = octant[1];
                    faceQuad.Point2 = octant[2];
                    faceQuad.Point3 = octant[6];

                    faces[5].Draw(ref faceQuad);
                }

                private void UpdateOctant(ref MatrixD matrix)
                {
                    Vector3D size = Size * 0.5d;

                    octant[0] = new Vector3D(-size.X, size.Y, -size.Z);
                    octant[1] = new Vector3D(size.X, size.Y, -size.Z);
                    octant[2] = new Vector3D(size.X, -size.Y, -size.Z);
                    octant[3] = new Vector3D(-size.X, -size.Y, -size.Z);

                    octant[4] = new Vector3D(-size.X, size.Y, size.Z);
                    octant[5] = new Vector3D(size.X, size.Y, size.Z);
                    octant[6] = new Vector3D(size.X, -size.Y, size.Z);
                    octant[7] = new Vector3D(-size.X, -size.Y, size.Z);

                    for (int n = 0; n < 8; n++)
                        octant[n] = Vector3D.Transform(octant[n], ref matrix) + Offset;
                }
            }
        }
    }
}﻿using System;
using VRageMath;

namespace RichHudFramework.UI.Rendering
{
    [Flags]
    public enum FontStyles : int
    {
        Regular = 0,

        Bold = 1,

        /// <summary>
        /// Font effect, always available
        /// </summary>
        Italic = 2,

        BoldItalic = 3,

        /// <summary>
        /// Font effect, always available
        /// </summary>
        Underline = 4
    }

    /// <summary>
    /// Simplified Font interface for use by HUD API clients.
    /// </summary>
    public interface IFontMin
    {
        /// <summary>
        /// Font name
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Index of the font in the font manager
        /// </summary>
        int Index { get; }

        /// <summary>
        /// Font size at which the textures were created.
        /// </summary>
        float PtSize { get; }

        /// <summary>
        /// Default scaling applied to font. Used to normalize font size.
        /// </summary>
        float BaseScale { get; }

        /// <summary>
        /// Returns the index for this font using regular styling
        /// </summary>
        Vector2I Regular { get; }

        /// <summary>
        /// Returns the index for the bolded version of this font
        /// </summary>
        Vector2I Bold { get; }

        /// <summary>
        /// Returns the index for the italicised version of this font
        /// </summary>
        Vector2I Italic { get; }

        /// <summary>
        /// Returns the index for the bold italic version of this font
        /// </summary>
        Vector2I BoldItalic { get; }

        /// <summary>
        /// Returns true if the font is defined for the given style.
        /// </summary>
        bool IsStyleDefined(FontStyles styleEnum);

        /// <summary>
        /// Returns true if the font is defined for the given style.
        /// </summary>
        bool IsStyleDefined(int style);

        /// <summary>
        /// Retrieves the full index of the font style
        /// </summary>
        Vector2I GetStyleIndex(int style);

        /// <summary>
        /// Retrieves the full index of the font style
        /// </summary>
        Vector2I GetStyleIndex(FontStyles style);
    }
}﻿using VRageMath;
using System;

namespace RichHudFramework
{
    namespace UI
    {
        using Client;

        namespace Rendering
        {
            using Client;
            using Server;

            public class MatBoard
            {
                /// <summary>
                /// Coloring applied to the material.
                /// </summary>
                public Color Color
                {
                    get { return color; }
                    set
                    {
                        if (value != color)
                            minBoard.materialData.bbColor = BillBoardUtils.GetBillBoardBoardColor(value);

                        color = value;
                    }
                }

                /// <summary>
                /// Texture applied to the billboard.
                /// </summary>
                public Material Material
                {
                    get { return matFrame.Material; }
                    set
                    {
                        if (value != matFrame.Material)
                        {
                            updateMatFit = true;
                            matFrame.Material = value;
                            minBoard.materialData.textureID = value.TextureID;
                        }
                    }
                }

                /// <summary>
                /// Determines how the texture scales with the MatBoard's dimensions.
                /// </summary>
                public MaterialAlignment MatAlignment
                {
                    get { return matFrame.Alignment; }
                    set
                    {
                        if (value != matFrame.Alignment)
                        {
                            updateMatFit = true;
                            matFrame.Alignment = value;
                        }
                    }
                }

                private Color color;
                private bool updateMatFit;

                private QuadBoard minBoard;
                private readonly MaterialFrame matFrame;

                /// <summary>
                /// Initializes a new matboard with a size of 0 and a blank, white material.
                /// </summary>
                public MatBoard()
                {
                    matFrame = new MaterialFrame();
                    minBoard = QuadBoard.Default;

                    color = Color.White;
                    updateMatFit = true;
                }

                /// <summary>
                /// Draws a billboard in world space using the quad specified.
                /// </summary>
                public void Draw(ref MyQuadD quad)
                {
                    minBoard.Draw(ref quad);
                }

                /// <summary>
                /// Draws a billboard in world space facing the +Z direction of the matrix given. Units in meters,
                /// matrix transform notwithstanding. Dont forget to compensate for perspective scaling!
                /// </summary
                public void Draw(ref CroppedBox box, MatrixD[] matrixRef)
                {
                    ContainmentType containment = ContainmentType.Contains;

                    if (box.mask != null)
                        box.mask.Value.Contains(ref box.bounds, out containment);

                    if (containment != ContainmentType.Disjoint)
                    {
                        if (updateMatFit && matFrame.Material != Material.Default)
                        {
                            Vector2 boxSize = box.bounds.Size;
                            minBoard.materialData.texBounds = matFrame.GetMaterialAlignment(boxSize.X / boxSize.Y);
                            updateMatFit = false;
                        }

                        if (containment != ContainmentType.Disjoint)
                            minBoard.Draw(ref box, matrixRef);
                    }
                }     
            }
        }
    }
}﻿using VRage.Utils;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        namespace Rendering
        {
            /// <summary>
            /// Used to determine how a given <see cref="Material"/> is scaled on a given Billboard.
            /// Note: texture colors are clamped to their edges.
            /// </summary>
            public enum MaterialAlignment : int
            {
                /// <summary>
                /// Stretches/compresses the material to cover the whole billboard. Default behavior.
                /// </summary>
                StretchToFit = 0,

                /// <summary>
                ///  Rescales the material so that it matches the height of the Billboard while maintaining its aspect ratio.
                ///  Material will be clipped as needed.
                /// </summary>
                FitVertical = 1,

                /// <summary>
                /// Rescales the material so that it matches the width of the Billboard while maintaining its aspect ratio.
                /// Material will be clipped as needed.
                /// </summary>
                FitHorizontal = 2,

                /// <summary>
                /// Rescales the material such that it maintains it's aspect ratio while filling as much of the billboard
                /// as possible
                /// </summary>
                FitAuto = 3,
            }

            /// <summary>
            /// Defines a texture used by <see cref="MatBoard"/>s. Supports sprite sheets.
            /// </summary>
            public class Material
            {
                public static readonly Material Default = new Material("RichHudDefault", new Vector2(4f, 4f)),
                    CircleMat = new Material("RhfCircle", new Vector2(1024f)),
                    AnnulusMat = new Material("RhfAnnulus", new Vector2(1024f));

                /// <summary>
                /// ID of the Texture the <see cref="Material"/> is based on.
                /// </summary>
                public readonly MyStringId TextureID;

                /// <summary>
                /// The dimensions, in pixels, of the <see cref="Material"/>.
                /// </summary>
                public readonly Vector2 size;

                /// <summary>
                /// The dimensions of the <see cref="Material"/> in normalized texture coordinates.
                /// </summary>
                public readonly Vector2 uvSize;

                /// <summary>
                /// Center of the <see cref="Material"/> in normalized texture coordinates.
                /// </summary>
                public readonly Vector2 uvOffset;

                /// <summary>
                /// Creates a <see cref="Material"/> using the name of the Texture's ID and its size in pixels.
                /// </summary>
                /// <param name="TextureName">Name of the texture ID</param>
                /// <param name="size">Size of the material in pixels</param>
                public Material(string TextureName, Vector2 size) : this(MyStringId.GetOrCompute(TextureName), size)
                { }

                /// <summary>
                /// Creates a <see cref="Material"/> based on a Texture Atlas/Sprite with a given offset and size.
                /// </summary>
                /// <param name="TextureName">Name of the texture ID</param>
                /// <param name="texSize">Size of the texture associated with the texture ID in pixels</param>
                /// <param name="texCoords">UV offset starting from the upper left hand corner in pixels</param>
                /// <param name="size">Size of the material starting from the given offset</param>
                public Material(string TextureName, Vector2 texSize, Vector2 texCoords, Vector2 size)
                    : this(MyStringId.GetOrCompute(TextureName), texSize, texCoords, size)
                { }

                /// <summary>
                /// Creates a <see cref="Material"/> using the name of the Texture's ID and its size in pixels.
                /// </summary>
                /// <param name="TextureID">MyStringID associated with the texture</param>
                /// <param name="size">Size of the material in pixels</param>
                public Material(MyStringId TextureID, Vector2 size)
                {
                    this.TextureID = TextureID;
                    this.size = size;

                    uvSize = Vector2.One;
                    uvOffset = uvSize * .5f;
                }

                /// <summary>
                /// Creates a <see cref="Material"/> based on a Texture Atlas/Sprite with a given offset and size.
                /// </summary>
                /// <param name="TextureID">MyStringID associated with the texture</param>
                /// <param name="texSize">Size of the texture associated with the texture ID in pixels</param>
                /// <param name="texCoords">UV offset starting from the upper left hand corner in pixels</param>
                /// <param name="size">Size of the material starting from the given offset</param>
                public Material(MyStringId TextureID, Vector2 textureSize, Vector2 offset, Vector2 size)
                {
                    this.TextureID = TextureID;
                    this.size = size;

                    size.X /= textureSize.X;
                    size.Y /= textureSize.Y;

                    uvSize = size;

                    offset.X /= textureSize.X;
                    offset.Y /= textureSize.Y;

                    uvOffset = offset + (uvSize * .5f);
                }
            }

        }
    }
}﻿using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        namespace Rendering
        {
            public interface IReadOnlyMaterialFrame
            {
                /// <summary>
                /// Texture associated with the frame
                /// </summary>
                MaterialAlignment Alignment { get; }

                /// <summary>
                /// Determines how or if the material is scaled w/respect to its aspect ratio.
                /// </summary>
                Material Material { get;}

                /// <summary>
                /// Texture coordinate offset
                /// </summary>
                Vector2 UvOffset { get; }

                BoundingBox2 GetMaterialAlignment(float bbAspectRatio);
            }

            /// <summary>
            /// Defines the positioning and alignment of a Material on a QuadBoard.
            /// </summary>
            public class MaterialFrame : IReadOnlyMaterialFrame
            {
                /// <summary>
                /// Texture associated with the frame
                /// </summary>
                public Material Material { get; set; }

                /// <summary>
                /// Determines how or if the material is scaled w/respect to its aspect ratio.
                /// </summary>
                public MaterialAlignment Alignment { get; set; }

                /// <summary>
                /// Texture coordinate offset
                /// </summary>
                public Vector2 UvOffset { get; set; }

                public MaterialFrame()
                {
                    Material = Material.Default;
                    Alignment = MaterialAlignment.StretchToFit;
                    UvOffset = Vector2.Zero;
                }

                /// <summary>
                /// Calculates the texture coordinates needed to fit the material to the billboard. 
                /// Aspect ratio = Width/Height
                /// </summary>
                public BoundingBox2 GetMaterialAlignment(float bbAspectRatio)
                {
                    Vector2 matOrigin = Material.uvOffset + UvOffset,
                        matStep = Material.uvSize * .5f;

                    if (Alignment != MaterialAlignment.StretchToFit)
                    {
                        float matAspectRatio = Material.size.X / Material.size.Y;
                        Vector2 localUV = new Vector2(1f);

                        if (Alignment == MaterialAlignment.FitAuto)
                        {
                            if (matAspectRatio > bbAspectRatio) // If material is too wide, make it shorter
                                localUV = new Vector2(1f, matAspectRatio / bbAspectRatio);
                            else // If the material is too tall, make it narrower
                                localUV = new Vector2(bbAspectRatio / matAspectRatio, 1f);
                        }
                        else if (Alignment == MaterialAlignment.FitVertical)
                        {
                            localUV = new Vector2(bbAspectRatio / matAspectRatio, 1f);
                        }
                        else if (Alignment == MaterialAlignment.FitHorizontal)
                        {
                            localUV = new Vector2(1f, matAspectRatio / bbAspectRatio);
                        }

                        matStep *= localUV;
                    }

                    return new BoundingBox2
                    (
                        matOrigin - matStep, // Bottom left
                        matOrigin + matStep // Upper right
                    );
                }
            }
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections.Generic;
using VRageMath;

namespace RichHudFramework.UI.Rendering
{
    using Client;
    using Server;

    /// <summary>
    /// Renders a 2D polygon using billboards
    /// </summary>
    public class PolyBoard
    {
        /// <summary>
        /// Tinting applied to the material
        /// </summary>
        public virtual Color Color
        {
            get { return color; }
            set
            {
                if (value != color)
                    polyMat.bbColor = BillBoardUtils.GetBillBoardBoardColor(value);

                color = value;
            }
        }

        /// <summary>
        /// Texture applied to the billboard.
        /// </summary>
        public virtual Material Material
        {
            get { return matFrame.Material; }
            set
            {
                if (value != matFrame.Material)
                {
                    updateMatFit = true;
                    matFrame.Material = value;
                    polyMat.textureID = value.TextureID;
                }
            }
        }

        /// <summary>
        /// Determines how the texture scales with the MatBoard's dimensions.
        /// </summary>
        public MaterialAlignment MatAlignment
        {
            get { return matFrame.Alignment; }
            set
            {
                if (value != matFrame.Alignment)
                {
                    updateMatFit = true;
                    matFrame.Alignment = value;
                }
            }
        }

        /// <summary>
        /// Get/set number of sides on the polygon
        /// </summary>
        public virtual int Sides
        {
            get { return _sides; }
            set
            {
                if (value != _sides)
                    updateVertices = true;

                _sides = value;
            }
        }

        protected int _sides;

        protected Color color;
        protected bool updateVertices, updateMatFit;

        protected PolyMaterial polyMat;
        protected readonly MaterialFrame matFrame;
        protected readonly List<int> triangles;
        protected readonly List<Vector2> vertices;
        protected readonly List<Vector2> drawVertices;

        public PolyBoard()
        {
            triangles = new List<int>();
            vertices = new List<Vector2>();
            drawVertices = new List<Vector2>();

            matFrame = new MaterialFrame();
            polyMat = PolyMaterial.Default;
            polyMat.texCoords = new List<Vector2>();

            _sides = 16;
            updateVertices = true;
        }

        /// <summary>
        /// Draws a polygon using billboards
        /// </summary>
        public virtual void Draw(Vector2 size, Vector2 origin, MatrixD[] matrixRef)
        {
            if (_sides > 2 && drawVertices.Count > 2)
            {
                if (updateVertices)
                    GeneratePolygon();

                if (updateMatFit)
                {
                    polyMat.texBounds = matFrame.GetMaterialAlignment(size.X / size.Y);
                    GenerateTextureCoordinates();
                    updateMatFit = false;
                }

                // Generate final vertices for drawing from unscaled vertices
                for (int i = 0; i < drawVertices.Count; i++)
                {
                    drawVertices[i] = origin + size * vertices[i];
                }

                BillBoardUtils.AddTriangles(triangles, drawVertices, ref polyMat, matrixRef);
            }
        }

        /// <summary>
        /// Draws the given range of faces
        /// </summary>
        public virtual void Draw(Vector2 size, Vector2 origin, Vector2I faceRange, MatrixD[] matrixRef)
        {
            if (_sides > 2 && drawVertices.Count > 2)
            {
                if (updateVertices)
                    GeneratePolygon();

                if (updateMatFit)
                {
                    polyMat.texBounds = matFrame.GetMaterialAlignment(size.X / size.Y);
                    GenerateTextureCoordinates();
                    updateMatFit = false;
                }

                // Generate final vertices for drawing from unscaled vertices
                int max = drawVertices.Count - 1;
                drawVertices[max] = origin + size * vertices[max];

                for (int i = 0; i < drawVertices.Count; i++)
                {
                    drawVertices[i] = origin + size * vertices[i];
                }

                faceRange *= 3;
                BillBoardUtils.AddTriangleRange(faceRange, triangles, drawVertices, ref polyMat, matrixRef);
            }
        }

        /// <summary>
        /// Returns the center position of the given slice relative to the center of the billboard
        /// </summary>
        public virtual Vector2 GetSliceOffset(Vector2 bbSize, Vector2I range)
        {
            if (updateVertices)
                GeneratePolygon();

            int max = vertices.Count;
            Vector2 start = vertices[range.X], 
                end = vertices[(range.Y + 1) % max], 
                center = Vector2.Zero;

            return bbSize * (start + end + center) / 3f;
        }

        protected virtual void GeneratePolygon()
        {
            GenerateVertices();
            GenerateTriangles();
            drawVertices.Clear();

            for (int i = 0; i < vertices.Count; i++)
                drawVertices.Add(Vector2.Zero);

            updateMatFit = true;
        }

        protected virtual void GenerateTriangles()
        {
            int max = vertices.Count - 1;
            triangles.Clear();
            triangles.EnsureCapacity(_sides * 3);

            for (int i = 0; i < vertices.Count - 1; i++)
            {
                triangles.Add(max);
                triangles.Add(i);
                triangles.Add((i + 1) % max);
            }
        }

        protected virtual void GenerateTextureCoordinates()
        {
            Vector2 texScale = polyMat.texBounds.Size,
                texCenter = polyMat.texBounds.Center;

            polyMat.texCoords.Clear();
            polyMat.texCoords.EnsureCapacity(vertices.Count);

            for (int i = 0; i < vertices.Count; i++)
            {
                Vector2 uv = vertices[i] * texScale;
                uv.Y *= -1f;

                polyMat.texCoords.Add(uv + texCenter);
            }
        }

        protected virtual void GenerateVertices()
        {
            float rotStep = (float)(Math.PI * 2f / _sides),
                rotPos = -.5f * rotStep;

            vertices.Clear();
            vertices.EnsureCapacity(_sides + 1);

            for (int i = 0; i < _sides; i++)
            {
                Vector2 point = Vector2.Zero;
                point.X = (float)Math.Cos(rotPos);
                point.Y = (float)Math.Sin(rotPos);

                vertices.Add(.5f * point);
                rotPos += rotStep;
            }

            vertices.Add(Vector2.Zero);
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRageMath;

namespace RichHudFramework.UI.Rendering
{
    using Client;
    using Server;

    /// <summary>
    /// Renders a 2D polygon using billboards with the center punched out.
    /// </summary>
    public class PuncturedPolyBoard : PolyBoard
    {
        /// <summary>
        /// Scaled inner radius as fractional offset from exterior edge.
        /// </summary>
        public float InnerRadius
        {
            get { return _innerRadius; }
            set
            {
                if (value != _innerRadius)
                    updateVertices = true;

                _innerRadius = value;
            }
        }

        private float _innerRadius;

        public PuncturedPolyBoard()
        {
            _innerRadius = 0.6f;
        }

        /// <summary>
        /// Draws the given range of faces
        /// </summary>
        public override void Draw(Vector2 size, Vector2 origin, Vector2I faceRange, MatrixD[] matrixRef)
        {
            if (_sides > 2 && drawVertices.Count > 5)
            {
                if (updateVertices)
                    GeneratePolygon();

                if (updateMatFit)
                {
                    polyMat.texBounds = matFrame.GetMaterialAlignment(size.X / size.Y);
                    GenerateTextureCoordinates();
                    updateMatFit = false;
                }

                faceRange.Y++;
                faceRange *= 2;
                // Outer vertex indices are even
                faceRange.X -= faceRange.X % 2;
                faceRange.Y -= faceRange.Y % 2;

                // Generate final vertices for drawing from unscaled vertices
                for (int i = faceRange.X; i <= faceRange.Y + 1; i++)
                {
                    drawVertices[i % drawVertices.Count] = origin + size * vertices[i % drawVertices.Count];
                }

                faceRange *= 3;
                BillBoardUtils.AddTriangleRange(faceRange, triangles, drawVertices, ref polyMat, matrixRef);
            }
        }

        /// <summary>
        /// Returns the center position of the given slice relative to the center of the billboard
        /// </summary>
        public override Vector2 GetSliceOffset(Vector2 bbSize, Vector2I range)
        {
            if (updateVertices)
                GeneratePolygon();

            range.Y++;
            range *= 2;
            // Outer vertex indices are even
            range.X -= range.X % 2;
            range.Y -= range.Y % 2;

            int max = vertices.Count;
            Vector2 sum = 
                vertices[range.X] +
                vertices[range.X + 1] +
                vertices[(range.Y) % max] +
                vertices[(range.Y + 1) % max];

            return bbSize * sum * .25f;
        }

        protected override void GenerateTriangles()
        {
            int max = vertices.Count;
            triangles.Clear();
            triangles.EnsureCapacity(_sides * 3 * 2);

            for (int i = 0; i < vertices.Count; i += 2)
            {
                int outerStart = i,
                    innerStart = (i + 1) % max,
                    outerEnd = (i + 2) % max,
                    innerEnd = (i + 3) % max;

                // Left Upper
                triangles.Add(outerStart);
                triangles.Add(outerEnd);
                triangles.Add(innerStart);

                // Right Lower
                triangles.Add(outerEnd);
                triangles.Add(innerEnd);
                triangles.Add(innerStart);
            }
        }

        protected override void GenerateVertices()
        {
            float rotStep = (float)(Math.PI * 2f / _sides),
                rotPos = -.5f * rotStep;

            _innerRadius = Math.Min(1f - 0.01f, _innerRadius);
            vertices.Clear();
            vertices.EnsureCapacity(_sides * 2);

            for (int i = 0; i < _sides; i++)
            {
                Vector2 outerStart = Vector2.Zero;
                outerStart.X = (float)Math.Cos(rotPos);
                outerStart.Y = (float)Math.Sin(rotPos);

                Vector2 innerStart = outerStart * _innerRadius;

                vertices.Add(.5f * outerStart);
                vertices.Add(.5f * innerStart);
                rotPos += rotStep;
            }
        }
    }
}﻿using Sandbox.ModAPI;
using System;
using System.Collections.Generic;
using VRage.Game;
using VRage.Utils;
using VRageMath;
using VRageRender;
using BlendTypeEnum = VRageRender.MyBillboard.BlendTypeEnum;

namespace RichHudFramework
{
    namespace UI
    {
        namespace Rendering
        {
            using Client;
            using Server;

            /// <summary>
            /// Bounding box paired with another as a mask for clipping billboards
            /// </summary>
            public struct CroppedBox
            {
                public static readonly BoundingBox2 defaultMask =
                    new BoundingBox2(-Vector2.PositiveInfinity, Vector2.PositiveInfinity);

                public BoundingBox2 bounds;
                public BoundingBox2? mask;
            }

            /// <summary>
            /// Final 3D quad for <see cref="QuadBoard"/> generated prior to rendering
            /// </summary>
            public struct QuadBoardData
            {
                public BoundedQuadMaterial material;
                public MyQuadD positions;
            }

            /// <summary>
            /// <see cref="QuadBoard"/> with bounding
            /// </summary>
            public struct BoundedQuadBoard
            {
                public BoundingBox2 bounds;
                public QuadBoard quadBoard;
            }

            /// <summary>
            /// Defines a rectangular billboard with texture coordinates defined by a bounding box
            /// </summary>
            public struct QuadBoard
            {
                public static readonly QuadBoard Default;

                /// <summary>
                /// Determines the extent to which the quad will be rhombused
                /// </summary>
                public float skewRatio;

                /// <summary>
                /// Determines material applied to the billboard as well as its alignment, bounding and tint
                /// </summary>
                public BoundedQuadMaterial materialData;

                static QuadBoard()
                {
                    var matFit = new BoundingBox2(new Vector2(0f, 0f), new Vector2(1f, 1f));
                    Default = new QuadBoard(Material.Default.TextureID, matFit, Color.White);
                }

                public QuadBoard(MyStringId textureID, BoundingBox2 matFit, Vector4 bbColor, float skewRatio = 0f)
                {
                    materialData.textureID = textureID;
                    materialData.texBounds = matFit;
                    materialData.bbColor = bbColor;
                    this.skewRatio = skewRatio;
                }

                public QuadBoard(MyStringId textureID, BoundingBox2 matFit, Color color, float skewRatio = 0f)
                {
                    materialData.textureID = textureID;
                    materialData.texBounds = matFit;
                    materialData.bbColor = BillBoardUtils.GetBillBoardBoardColor(color);
                    this.skewRatio = skewRatio;
                }

                /// <summary>
                /// Draws a billboard in world space using the quad specified.
                /// </summary>
                public void Draw(ref MyQuadD quad)
                {
                    BillBoardUtils.AddQuad(ref materialData, ref quad);
                }

                /// <summary>
                /// Draws a billboard in world space facing the +Z direction of the matrix specified. Units in meters, matrix
                /// transform notwithstanding.
                /// </summary>
                public void Draw(ref CroppedBox box, MatrixD[] matrixRef)
                {
                    FlatQuad quad = new FlatQuad()
                    {
                        Point0 = box.bounds.Max,
                        Point1 = new Vector2(box.bounds.Max.X, box.bounds.Min.Y),
                        Point2 = box.bounds.Min,
                        Point3 = new Vector2(box.bounds.Min.X, box.bounds.Max.Y),
                    };

                    if (skewRatio != 0f)
                    {
                        Vector2 start = quad.Point0, end = quad.Point3,
                            offset = (end - start) * skewRatio * .5f;

                        quad.Point0 = Vector2.Lerp(start, end, skewRatio) - offset;
                        quad.Point3 = Vector2.Lerp(start, end, 1f + skewRatio) - offset;
                        quad.Point1 -= offset;
                        quad.Point2 -= offset;
                    }

                    BillBoardUtils.AddQuad(ref quad, ref materialData, matrixRef, box.mask);
                }
            }
        }
    }
}﻿using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {
        namespace Rendering
        {
            public enum LineAccessors : int
            {
                /// <summary>
                /// out: int
                /// </summary>
                Count = 1,

                /// <summary>
                /// out: Vector2
                /// </summary>
                Size = 2,

                /// <summary>
                /// out: float
                /// </summary>
                VerticalOffset = 3,
            }

            public interface ILine : IIndexedCollection<IRichChar>
            {
                /// <summary>
                /// Size of the line as rendered
                /// </summary>
                Vector2 Size { get; }

                /// <summary>
                /// Starting vertical position of the line starting from the center of the text element, sans text offset.
                /// </summary>
                float VerticalOffset { get; }
            }
        }
    }
}﻿using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {

        namespace Rendering
        {
            public enum RichCharAccessors : int
            {
                /// <summary>
                /// out: char
                /// </summary>
                Ch = 1,

                /// <summary>
                /// out: GlyphFormatMembers
                /// </summary>
                Format = 2,

                /// <summary>
                /// out: Vector2
                /// </summary>
                Size = 3,

                /// <summary>
                /// out: Vector2
                /// </summary>
                Offset = 4
            }

            public interface IRichChar
            {
                /// <summary>
                /// Character assocated with the glyph
                /// </summary>
                char Ch { get; }

                /// <summary>
                /// Text format used by the character
                /// </summary>
                GlyphFormat Format { get; }

                /// <summary>
                /// Size of the glyph as rendered
                /// </summary>
                Vector2 Size { get; }

                /// <summary>
                /// Position of the glyph relative to the center of its parent text element. Does not include the 
                /// parent's TextOffset. Will not be updated if outside its TextBoard's visible line range.
                /// </summary>
                Vector2 Offset { get; }
            }
        }
    }
}﻿using System;
using VRageMath;

namespace RichHudFramework
{
    namespace UI
    {

        namespace Rendering
        {
            public enum TextBoardAccessors : int
            {
                /// <summary>
                /// in/out: bool
                /// </summary>
                AutoResize = 129,

                /// <summary>
                /// in/out: bool
                /// </summary>
                VertAlign = 130,

                /// <summary>
                /// in: Vector2I
                /// </summary>
                MoveToChar = 131,

                /// <summary>
                /// out: Vector2I
                /// </summary>
                GetCharAtOffset = 132,

                /// <summary>
                /// Action event
                /// </summary>
                OnTextChanged = 133,

                /// <summary>
                /// in/out: Vector2
                /// </summary>
                TextOffset = 134,

                /// <summary>
                /// out: Vector2I
                /// </summary>
                VisibleLineRange = 135,
            }

            public interface ITextBoard : ITextBuilder
            {
                /// <summary>
                /// Invoked whenever a change is made to the text. Invokes once every 500ms, at most.
                /// </summary>
                event Action TextChanged;

                /// <summary>
                /// Scale of the text board. Applied after scaling specified in GlyphFormat.
                /// </summary>
                float Scale { get; set; }

                /// <summary>
                /// Size of the text box as rendered
                /// </summary>
                Vector2 Size { get; }

                /// <summary>
                /// Full text size including any text outside the visible range.
                /// </summary>
                Vector2 TextSize { get; }

                /// <summary>
                /// Used to change the position of the text within the text element. AutoResize must be disabled for this to work.
                /// </summary>
                Vector2 TextOffset { get; set; }

                /// <summary>
                /// Returns the range of lines visible.
                /// </summary>
                Vector2I VisibleLineRange { get; }

                /// <summary>
                /// Size of the text box when AutoResize is set to false. Does nothing otherwise.
                /// </summary>
                Vector2 FixedSize { get; set; }

                /// <summary>
                /// If true, the text board will automatically resize to fit the text.
                /// </summary>
                bool AutoResize { get; set; }

                /// <summary>
                /// If true, the text will be vertically aligned to the center of the text board.
                /// </summary>
                bool VertCenterText { get; set; }

                /// <summary>
                /// Calculates and applies the minimum offset needed to ensure that the character at the specified index
                /// is within the visible range.
                /// </summary>
                void MoveToChar(Vector2I index);

                /// <summary>
                /// Returns the index of the character at the given offset.
                /// </summary>
                Vector2I GetCharAtOffset(Vector2 localPos);

                /// <summary>
                /// Draws the text board in screen space with an offset given in pixels.
                /// </summary>
                void Draw(Vector2 origin);

                /// <summary>
                /// Draws the text board in world space on the XY plane of the matrix, facing in the +Z
                /// direction.
                /// </summary>
                void Draw(Vector2 offset, MatrixD matrix);

                /// <summary>
                /// Draws the text board in world space on the XY plane of the matrix, facing in the +Z
                /// direction.
                /// </summary>
                void Draw(BoundingBox2 box, BoundingBox2 mask, MatrixD[] matrix);
            }
        }
    }
}﻿using VRageMath;
using System.Text;

namespace RichHudFramework
{
    namespace UI
    {
        public enum TextBuilderModes : int
        {
            /// <summary>
            /// In this mode, all text in the <see cref="Rendering.ITextBuilder"/> will all be on the same line.
            /// Line breaks are ignored and filtered from the text.
            /// </summary>
            Unlined = 1,

            /// <summary>
            /// In this mode, <see cref="Rendering.ITextBuilder"/> text can be separated into multiple lines with line
            /// breaks ('\n').
            /// </summary>
            Lined = 2,

            /// <summary>
            /// In this mode, <see cref="Rendering.ITextBuilder"/> text will be split into multiple lines as needed to
            /// ensure proper wrapping (in addition to manual line breaks).
            /// </summary>
            Wrapped = 3
        }

        namespace Rendering
        {
            public enum TextBuilderAccessors : int
            {
                /// <summary>
                /// in/out: float
                /// </summary>
                LineWrapWidth = 1,

                /// <summary>
                /// in/out: int (TextBuilderModes)
                /// </summary>
                BuilderMode = 2,

                /// <summary>
                /// in: Vector2I, Vector2I, out: List<RichStringMembers>
                /// </summary>
                GetRange = 3,

                /// <summary>
                /// int: GlyphFormatMembers
                /// </summary>
                SetFormatting = 4,

                /// <summary>
                /// in: Vector2I, Vector2I
                /// </summary>
                RemoveRange = 5,

                /// <summary>
                /// in/out: GlyphFormatMembers
                /// </summary>
                Format = 6,

                /// <summary>
                /// out: string
                /// </summary>
                ToString = 7,
            }

            public interface ITextBuilder : IIndexedCollection<ILine>
            {
                /// <summary>
                /// Returns the character at the index specified.
                /// </summary>
                IRichChar this[Vector2I index] { get; }

                /// <summary>
                /// Default text format. Applied to strings added without any other formatting specified.
                /// </summary>
                GlyphFormat Format { get; set; }

                /// <summary>
                /// Gets or sets the maximum line width before text will wrap to the next line. Word wrapping must be enabled for
                /// this to apply.
                /// </summary>
                float LineWrapWidth { get; set; }

                /// <summary>
                /// Determines the formatting mode of the text.
                /// </summary>
                TextBuilderModes BuilderMode { get; set; }

                /// <summary>
                /// Replaces the current text with the <see cref="RichText"/> given
                /// </summary>
                void SetText(RichText text);

                /// <summary>
                /// Clears current text and appends a copy of the <see cref="StringBuilder"/> given.
                /// </summary>
                void SetText(StringBuilder text, GlyphFormat? format = null);

                /// <summary>
                /// Clears current text and appends a copy of the <see cref="string"/> given.
                /// </summary>
                void SetText(string text, GlyphFormat? format = null);

                /// <summary>
                /// Appends the given <see cref="RichText"/>
                /// </summary>
                void Append(RichText text);

                /// <summary>
                /// Appends a copy of the text in the <see cref="StringBuilder"/>
                /// </summary>
                void Append(StringBuilder text, GlyphFormat? format = null);

                /// <summary>
                /// Appends a copy of the <see cref="string"/>
                /// </summary>
                void Append(string text, GlyphFormat? format = null);

                /// <summary>
                /// Appends the given <see cref="char"/>
                /// </summary>
                void Append(char ch, GlyphFormat? format = null);

                /// <summary>
                /// Inserts the given <see cref="RichText"/> starting at the specified starting index
                /// </summary>
                void Insert(RichText text, Vector2I start);

                /// <summary>
                /// Inserts a copy of the given <see cref="StringBuilder"/> starting at the specified starting index
                /// </summary>
                void Insert(StringBuilder text, Vector2I start, GlyphFormat? format = null);

                /// <summary>
                /// Inserts a copy of the given <see cref="string"/> starting at the specified starting index
                /// </summary>
                void Insert(string text, Vector2I start, GlyphFormat? format = null);

                /// <summary>
                /// Inserts the given <see cref="char"/> starting at the specified starting index
                /// </summary>
                void Insert(char text, Vector2I start, GlyphFormat? format = null);

                /// <summary>
                /// Changes the formatting for the whole text to the given format.
                /// </summary>
                void SetFormatting(GlyphFormat format);

                /// <summary>
                /// Changes the formatting for the text within the given range to the given format.
                /// </summary>
                void SetFormatting(Vector2I start, Vector2I end, GlyphFormat format);

                /// <summary>
                /// Returns the contents of the text as <see cref="RichText"/>.
                /// </summary>
                RichText GetText();

                /// <summary>
                /// Returns the specified range of characters from the text as <see cref="RichText"/>.
                /// </summary>
                RichText GetTextRange(Vector2I start, Vector2I end);

                /// <summary>
                /// Removes the character at the specified index.
                /// </summary>
                void RemoveAt(Vector2I index);

                /// <summary>
                /// Removes all text within the specified range.
                /// </summary>
                void RemoveRange(Vector2I start, Vector2I end);

                /// <summary>
                /// Clears all existing text.
                /// </summary>
                void Clear();
            }
        }
    }
}﻿using System.Text;
using System;
using System.Collections.Generic;
using VRage;
using VRageMath;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    namespace UI
    {
        using Rendering.Client;
        using Rendering.Server;
        using Rendering;

        /// <summary>
        /// Used to determine text alignment.
        /// </summary>
        public enum TextAlignment : byte
        {
            Left = 0,
            Center = 1,
            Right = 2,
        }

        /// <summary>
        /// Defines the formatting of the characters in rich text types.
        /// </summary>
        public struct GlyphFormat : IEquatable<GlyphFormat>
        {
            public static readonly GlyphFormat 
                Black = new GlyphFormat(),
                White = new GlyphFormat(color: Color.White), 
                Blueish = new GlyphFormat(color: new Color(220, 235, 242)),
                Empty = new GlyphFormat(default(GlyphFormatMembers));

            /// <summary>
            /// Determines the alignment (left, center, right) of a given piece of RichText.
            /// </summary>
            public TextAlignment Alignment => (TextAlignment)Data.Item1;

            /// <summary>
            /// Text size
            /// </summary>
            public float TextSize => Data.Item2;

            /// <summary>
            /// Font specified by the format.
            /// </summary>
            public IFontMin Font => FontManager.GetFont(Data.Item3.X);

            /// <summary>
            /// The font style specifed by the format.
            /// </summary>
            public FontStyles FontStyle => (FontStyles)Data.Item3.Y;

            /// <summary>
            /// The font and style used by the format represented as a pair of integers.
            /// </summary>
            public Vector2I StyleIndex => Data.Item3;

            /// <summary>
            /// Text color
            /// </summary>
            public Color Color => Data.Item4;

            public GlyphFormatMembers Data { get; }

            public GlyphFormat(Color color, TextAlignment alignment, float textSize, Vector2I fontStyle)
            {
                if (color == default(Color))
                    color = Color.Black;

                Data = new GlyphFormatMembers((byte)alignment, textSize, fontStyle, color);
            }

            public GlyphFormat(Color color = default(Color), TextAlignment alignment = TextAlignment.Left, float textSize = 1f, FontStyles style = FontStyles.Regular, IFontMin font = null)
            {
                if (color == default(Color))
                    color = Color.Black;

                if (font == null)
                    font = FontManager.GetFont(FontManager.Default.X);

                Data = new GlyphFormatMembers((byte)alignment, textSize, font.GetStyleIndex(style), color);
            }

            public GlyphFormat(GlyphFormatMembers data)
            {
                this.Data = data;
            }

            public GlyphFormat(GlyphFormat original)
            {
                Data = original.Data;
            }

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the specified <see cref="VRageMath.Color"/>.
            /// </summary>
            public GlyphFormat WithColor(Color color) =>
                new GlyphFormat(color, Alignment, TextSize, StyleIndex);

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the specified <see cref="TextAlignment"/>.
            /// </summary>
            public GlyphFormat WithAlignment(TextAlignment textAlignment) =>
                new GlyphFormat(Color, textAlignment, TextSize, StyleIndex);

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the font associated with the given index.
            /// </summary>
            public GlyphFormat WithFont(int font) =>
                new GlyphFormat(Color, Alignment, TextSize, new Vector2I(font, 0));

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the font style associated with the given index.
            /// </summary>
            public GlyphFormat WithFont(Vector2I fontStyle) =>
                new GlyphFormat(Color, Alignment, TextSize, fontStyle);

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the font style associated with the given enum.
            /// </summary>
            public GlyphFormat WithStyle(FontStyles style)
            {
                if (FontManager.GetFont(StyleIndex.X).IsStyleDefined(style))
                    return new GlyphFormat(Color, Alignment, TextSize, new Vector2I(StyleIndex.X, (int)style));
                else
                    return this;
            }

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the font style associated with the given enum.
            /// </summary>
            public GlyphFormat WithStyle(int style)
            {
                if (FontManager.GetFont(StyleIndex.X).IsStyleDefined(style))
                    return new GlyphFormat(Color, Alignment, TextSize, new Vector2I(StyleIndex.X, style));
                else
                    return this;
            }

            /// <summary>
            /// Returns a copy of the <see cref="GlyphFormat"/> using the given text size.
            /// </summary>
            public GlyphFormat WithSize(float size) =>
                new GlyphFormat(Color, Alignment, size, StyleIndex);

            /// <summary>
            /// Determines whether or not two given <see cref="GlyphFormat"/>s share the same configuration.
            /// </summary>
            public override bool Equals(object obj)
            {
                if (obj == null)
                    return false;

                var format = (GlyphFormat)obj;

                return Data.Item1 == format.Data.Item1
                    && Data.Item2 == format.Data.Item2
                    && Data.Item3 == format.Data.Item3
                    && Data.Item4 == format.Data.Item4;
            }

            /// <summary>
            /// Determines whether or not two given <see cref="GlyphFormat"/>s share the same configuration.
            /// </summary>
            public bool Equals(GlyphFormat format)
            {
                return Data.Item1 == format.Data.Item1
                    && Data.Item2 == format.Data.Item2
                    && Data.Item3 == format.Data.Item3
                    && Data.Item4 == format.Data.Item4;
            }

            public bool DataEqual(GlyphFormatMembers data)
            {
                return Data.Item1 == data.Item1
                    && Data.Item2 == data.Item2
                    && Data.Item3 == data.Item3
                    && Data.Item4 == data.Item4;
            }

            public override int GetHashCode() =>
                Data.GetHashCode();
        }
    }
}﻿using RichHudFramework.UI.Rendering;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using VRage;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using RichStringMembers = MyTuple<StringBuilder, GlyphFormatMembers>;

    namespace UI
    {
        /// <summary>
        /// Reusable rich text builder
        /// </summary>
        public class RichText : IEnumerable<RichStringMembers>, IEquatable<RichText>
        {
            /// <summary>
            /// Default text formatting. Applied to strings with no other formatting given.
            /// Optional.
            /// </summary>
            public GlyphFormat? defaultFormat;

            public readonly List<RichStringMembers> apiData;
            private ObjectPool<StringBuilder> sbPool;

            /// <summary>
            /// Initializes an empty RichText object with the given formatting.
            /// </summary>
            public RichText(GlyphFormat? defaultFormat = null)
            {
                this.defaultFormat = defaultFormat ?? GlyphFormat.Empty;
                apiData = new List<RichStringMembers>();
            }

            /// <summary>
            /// Initializes a new RichText instance backed by the given List.
            /// </summary>
            public RichText(List<RichStringMembers> apiData, bool copy = false)
            {
                this.apiData = copy ? GetDataCopy(apiData) : apiData;
                defaultFormat = GlyphFormat.Empty;
            }

            /// <summary>
            /// Initializes a new RichText object and copies the contents of the one given
            /// </summary>
            public RichText(RichText original)
            {
                apiData = new List<RichStringMembers>();
                defaultFormat = original.defaultFormat;
                Add(original);
            }

            /// <summary>
            /// Initializes a new RichText object with the given text and formatting.
            /// </summary>
            public RichText(string text, GlyphFormat? defaultFormat = null)
            {
                this.defaultFormat = defaultFormat ?? GlyphFormat.Empty;
                apiData = new List<RichStringMembers>();
                apiData.Add(new RichStringMembers(new StringBuilder(text), this.defaultFormat.Value.Data));
            }

            /// <summary>
            /// Initializes a new RichText object with the given text and formatting.
            /// </summary>
            public RichText(StringBuilder text, GlyphFormat? defaultFormat = null)
            {
                this.defaultFormat = defaultFormat ?? GlyphFormat.Empty;
                apiData = new List<RichStringMembers>();
                Add(text);
            }

            public IEnumerator<RichStringMembers> GetEnumerator() =>
                apiData.GetEnumerator();

            IEnumerator IEnumerable.GetEnumerator() =>
                apiData.GetEnumerator();

            /// <summary>
            /// Copies and appends the contents of the given RichText object.
            /// </summary>
            public void Add(RichText text)
            {
                if (sbPool == null)
                    sbPool = new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());

                List<RichStringMembers> currentStrings = apiData,
                    newStrings = text.apiData;

                if (newStrings.Count > 0)
                {
                    int index = 0, end = newStrings.Count - 1;

                    // Attempt to use last StringBuilder if the formatting matches
                    if (currentStrings.Count > 0)
                    {
                        GlyphFormatMembers newFormat = newStrings[0].Item2;
                        StringBuilder sb;
                        bool formatEqual;

                        GetNextStringBuilder(newFormat, out sb, out formatEqual);

                        if (formatEqual)
                        {
                            StringBuilder newSb = newStrings[0].Item1;
                            sb.EnsureCapacity(sb.Length + newSb.Length);

                            for (int i = 0; i < newSb.Length; i++)
                                sb.Append(newSb[i]);

                            index++;
                        }
                    }

                    // Copy the remaining text
                    for (int i = index; i <= end; i++)
                    {
                        StringBuilder sb = sbPool.Get(),
                            newSb = newStrings[i].Item1;

                        sb.EnsureCapacity(sb.Length + newSb.Length);
                        currentStrings.Add(new RichStringMembers(sb, newStrings[i].Item2));

                        for (int j = 0; j < newSb.Length; j++)
                            sb.Append(newSb[j]);
                    }
                }
            }

            /// <summary>
            /// Appends a copy of the given <see cref="StringBuilder"/> to the RichText instance.
            /// </summary>
            public void Add(StringBuilder text, GlyphFormat? newFormat = null)
            {
                if (sbPool == null)
                    sbPool = new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());

                List<RichStringMembers> richStrings = apiData;
                GlyphFormatMembers format = newFormat?.Data ?? defaultFormat?.Data ?? GlyphFormat.Empty.Data;
                StringBuilder sb;
                bool formatEqual;

                GetNextStringBuilder(newFormat?.Data ?? GlyphFormat.Empty.Data, out sb, out formatEqual);

                // If format is equal, reuse last StringBuilder
                if (!formatEqual)
                {
                    var richString = new RichStringMembers(sb, format);
                    richStrings.Add(richString);
                }

                sb.EnsureCapacity(sb.Length + text.Length);

                for (int i = 0; i < text.Length; i++)
                    sb.Append(text[i]);
            }

            /// <summary>
            /// Appends a copy of the given <see cref="StringBuilder"/> to the RichText instance.
            /// </summary>
            public void Add(GlyphFormat newFormat, StringBuilder text) =>
                Add(text, newFormat);

            /// <summary>
            /// Appends a <see cref="string"/> to the end of the text. If the formatting given is equivalent to 
            /// that of the last string appended, then it will use the same StringBuilder.
            /// </summary>
            public void Add(string text, GlyphFormat? newFormat = null)
            {
                if (sbPool == null)
                    sbPool = new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());

                List<RichStringMembers> richStrings = apiData;
                GlyphFormatMembers format = newFormat?.Data ?? defaultFormat?.Data ?? GlyphFormat.Empty.Data;
                StringBuilder sb;
                bool formatEqual;

                GetNextStringBuilder(newFormat?.Data ?? GlyphFormat.Empty.Data, out sb, out formatEqual);

                // If format is equal, reuse last StringBuilder
                if (!formatEqual)
                { 
                    var richString = new RichStringMembers(sb, format);
                    richStrings.Add(richString);
                }

                sb.Append(text);
            }

            /// <summary>
            /// Appends a <see cref="char"/> to the end of the text. If the formatting given is equivalent to 
            /// that of the last string appended, then it will use the same StringBuilder.
            /// </summary>
            public void Add(char ch, GlyphFormat? newFormat = null)
            {
                if (sbPool == null)
                    sbPool = new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());

                List<RichStringMembers> richStrings = apiData;
                GlyphFormatMembers format = newFormat?.Data ?? defaultFormat?.Data ?? GlyphFormat.Empty.Data;
                StringBuilder sb;
                bool formatEqual;

                GetNextStringBuilder(newFormat?.Data ?? GlyphFormat.Empty.Data, out sb, out formatEqual);

                // If format is equal, reuse last StringBuilder
                if (!formatEqual)
                {
                    var richString = new RichStringMembers(sb, format);
                    richStrings.Add(richString);
                }

                sb.Append(ch);
            }

            private void GetNextStringBuilder(GlyphFormatMembers newFormat, out StringBuilder sb, out bool formatEqual)
            {
                List<RichStringMembers> richStrings = apiData;
                int last = richStrings.Count - 1;
                formatEqual = false;

                // Test formatting
                if (richStrings.Count > 0)
                {
                    GlyphFormatMembers lastFormat = richStrings[last].Item2;
                    formatEqual = newFormat.Item1 == lastFormat.Item1
                        && newFormat.Item2 == lastFormat.Item2
                        && newFormat.Item3 == lastFormat.Item3
                        && newFormat.Item4 == lastFormat.Item4;
                }

                sb = formatEqual ? richStrings[last].Item1 : sbPool.Get();
            }

            /// <summary>
            /// Appends a string to the end of the text. If the formatting given is equivalent to 
            /// that of the last string appended, then it will use the same StringBuilder.
            /// </summary>
            public void Add(GlyphFormat newFormat, string text) =>
                Add(text, newFormat);

            /// <summary>
            /// Sets the capacity of the StringBuilders and object pool to match their current
            /// lengths.
            /// </summary>
            public void TrimExcess()
            {
                if (sbPool == null)
                    sbPool = new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());

                List<RichStringMembers> text = apiData;

                for (int n = 0; n < text.Count; n++)
                    text[n].Item1.Capacity = text[n].Item1.Length;

                sbPool.TrimExcess();
                text.TrimExcess();
            }

            /// <summary>
            /// Clears current text
            /// </summary>
            public void Clear()
            {
                if (sbPool == null)
                    sbPool = new ObjectPool<StringBuilder>(new StringBuilderPoolPolicy());

                List<RichStringMembers> text = apiData;
                sbPool.ReturnRange(text, 0, text.Count);
                text.Clear();
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override bool Equals(object obj)
            {
                RichText other = obj as RichText;

                if (apiData == other?.apiData)
                    return true;
                if (other != null)
                    return Equals(other);
                else
                    return false;
            }

            public bool Equals(RichText other)
            {
                bool isFormatEqual = true,
                    isTextEqual = true,
                    isLengthEqual = true;

                if (other == null)
                    return false;
                else if (apiData == other.apiData)
                    return true;
                else if(apiData.Count == other.apiData.Count)
                {
                    for (int i = 0; i < apiData.Count; i++)
                    {
                        if (apiData[i].Item1.Length != other.apiData[i].Item1.Length)
                        {
                            isLengthEqual = false;
                            break;
                        }
                    }

                    if (isLengthEqual)
                    {
                        for (int i = 0; i < apiData.Count; i++)
                        {
                            GlyphFormatMembers fmt = apiData[i].Item2,
                                otherFmt = other.apiData[i].Item2;

                            if (fmt.Item1 != otherFmt.Item1 ||
                                fmt.Item2 != otherFmt.Item2 ||
                                fmt.Item3 != otherFmt.Item3 ||
                                fmt.Item4 != otherFmt.Item4)
                            {
                                isFormatEqual = false;
                                break;
                            }
                        }
                    }
                    else
                        isFormatEqual = false;

                    if (isFormatEqual)
                    {
                        for (int i = 0; i < apiData.Count; i++)
                        {
                            for (int j = 0; j < apiData[i].Item1.Length; j++)
                            {
                                if (apiData[i].Item1[j] != other.apiData[i].Item1[j])
                                {
                                    isTextEqual = false;
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                    isLengthEqual = false;

                return isLengthEqual && isFormatEqual && isTextEqual;
            }

            /// <summary>
            /// Returns a copy of the contents of the <see cref="RichText"/> as an unformatted 
            /// <see cref="string"/>.
            /// </summary>
            public override string ToString()
            {
                StringBuilder rawText = new StringBuilder();
                List<RichStringMembers> richText = apiData;
                int charCount = 0;

                for (int i = 0; i < richText.Count; i++)
                    charCount += richText[i].Item1.Length;

                rawText.EnsureCapacity(charCount);

                for (int i = 0; i < richText.Count; i++)
                {
                    for (int b = 0; b < richText[i].Item1.Length; b++)
                        rawText.Append(richText[i].Item1[b]);
                }
                
                return rawText.ToString();
            }

            /// <summary>
            /// Returns a copy of the rich text object
            /// </summary>
            public RichText GetCopy() =>
                new RichText(GetDataCopy(apiData));

            /// <summary>
            /// Returns a copy of the api data backing the rich text object
            /// <returns></returns>
            public static List<RichStringMembers> GetDataCopy(List<RichStringMembers> original)
            {
                var newData = new List<RichStringMembers>(original.Count);

                for (int i = 0; i < original.Count; i++)
                {
                    StringBuilder oldSb = original[i].Item1, 
                        sb = new StringBuilder(oldSb.Length);

                    for (int j = 0; j < oldSb.Length; j++)
                        sb.Append(oldSb[j]);

                    newData.Add(new RichStringMembers(sb, original[i].Item2));
                }

                return newData;
            }

            /// <summary>
            /// Appends a <see cref="string"/> to the end of the left RichText object. If the formatting given 
            /// is equivalent to that of the last string appended, then it will use the same 
            /// StringBuilder.
            /// </summary>>
            public static RichText operator +(RichText left, string right)
            {
                left.Add(right);
                return left;
            }

            /// <summary>
            /// Appends a <see cref="StringBuilder"/> to the end of the left RichText object. If the formatting given 
            /// is equivalent to that of the last string appended, then it will use the same 
            /// StringBuilder.
            /// </summary>>
            public static RichText operator +(RichText left, StringBuilder right)
            {
                left.Add(right);
                return left;
            }

            /// <summary>
            /// Copies and appends the contents of the right RichText to the left RichText object.
            /// </summary>
            public static RichText operator +(RichText left, RichText right)
            {
                left.Add(right);
                return left;
            }

            public static implicit operator RichText(string text) =>
                new RichText(text);

            public static implicit operator RichText(StringBuilder text) =>
                new RichText(text);

            public static implicit operator RichText(List<RichStringMembers> text) =>
                new RichText(text);
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        using ControlContainerMembers = MyTuple<
            ApiMemberAccessor, // GetOrSetMember,
            MyTuple<object, Func<int>>, // Member List
            object // ID
        >;

        public enum ControlCatAccessors : int
        {
            /// <summary>
            /// IList<RichStringMembers>
            /// </summary>
            HeaderText = 1,

            /// <summary>
            /// IList<RichStringMembers>
            /// </summary>
            SubheaderText = 2,

            /// <summary>
            /// bool
            /// </summary>
            Enabled = 3,

            /// <summary>
            /// out: MemberAccessor
            /// </summary>
            AddMember = 4
        }

        /// <summary>
        /// Horizontally scrolling list of control tiles.
        /// </summary>
        public interface IControlCategory : IControlCategory<ControlTile>
        {
            /// <summary>
            /// Read only collection of <see cref="ControlTile"/>s assigned to this category
            /// </summary>
            IReadOnlyList<ControlTile> Tiles { get; }

            /// <summary>
            /// Used to allow the addition of control tiles to categories using collection-initializer syntax in
            /// conjunction with normal initializers.
            /// </summary>
            IControlCategory TileContainer { get; }
        }

        /// <summary>
        /// Vertically scrolling list of terminal controls
        /// </summary>
        public interface IVertControlCategory : IControlCategory<TerminalControlBase>
        {
            /// <summary>
            /// Read only collection of <see cref="ControlTile"/>s assigned to this category
            /// </summary>
            IReadOnlyList<TerminalControlBase> Controls { get; }

            /// <summary>
            /// Used to allow the addition of control tiles to categories using collection-initializer syntax in
            /// conjunction with normal initializers.
            /// </summary>
            IVertControlCategory ControlContainer { get; }
        }

        public interface IControlCategory<TElementContainer> : IEnumerable<TElementContainer>
        {
            /// <summary>
            /// Category name
            /// </summary>
            string HeaderText { get; set; }

            /// <summary>
            /// Category information
            /// </summary>
            string SubheaderText { get; set; }

            /// <summary>
            /// Determines whether or not the element will be drawn.
            /// </summary>
            bool Enabled { get; set; }

            /// <summary>
            /// Unique identifier.
            /// </summary>
            object ID { get; }

            /// <summary>
            /// Adds members to the category
            /// </summary>
            void Add(TElementContainer tile);

            /// <summary>
            /// Retrieves information used by the Framework API
            /// </summary>
            ControlContainerMembers GetApiData();
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        public enum ControlPageAccessors : int
        {
            /// <summary>
            /// MemberAccessor
            /// </summary>
            AddCategory = 10,

            CategoryData = 11,
        }

        /// <summary>
        /// Interactive list of horizontally scrolling control categories
        /// </summary>
        public interface IControlPage : IControlPage<ControlCategory, ControlTile>
        { }

        public interface IControlPage<TCategory, TMember> : ITerminalPage, IEnumerable<TCategory>
            where TCategory : IControlCategory<TMember>, new()
        {
            /// <summary>
            /// Read only collection of <see cref="IControlCategory"/>s assigned to this object.
            /// </summary>
            IReadOnlyList<TCategory> Categories { get; }

            /// <summary>
            /// Used to allow the addition of category elements using collection-initializer syntax in
            /// conjunction with normal initializers.
            /// </summary>
            IControlPage<TCategory, TMember> CategoryContainer { get; }

            /// <summary>
            /// Adds a given category to the page
            /// </summary>
            void Add(TCategory category);
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        using ControlContainerMembers = MyTuple<
            ApiMemberAccessor, // GetOrSetMember,
            MyTuple<object, Func<int>>, // Member List
            object // ID
        >;

        public enum ControlTileAccessors : int
        {
            /// <summary>
            /// out: MemberAccessor
            /// </summary>
            AddControl = 1,

            /// <summary>
            /// bool
            /// </summary>
            Enabled = 2,
        }

        /// <summary>
        /// Small collection of terminal controls organized into a single block. No more than 1-3
        /// controls should be added to a tile. If a group of controls can't fit on a tile, then they
        /// will be drawn outside its bounds.
        /// </summary>
        public interface IControlTile : IEnumerable<ITerminalControl>
        {
            /// <summary>
            /// Read only collection of <see cref="TerminalControlBase"/>s attached to the tile
            /// </summary>
            IReadOnlyList<TerminalControlBase> Controls { get; }

            /// <summary>
            /// Used to allow the addition of controls to tiles using collection-initializer syntax in
            /// conjunction with normal initializers.
            /// </summary>
            IControlTile ControlContainer { get; }

            /// <summary>
            /// Determines whether or not the tile will be rendered in the list.
            /// </summary>
            bool Enabled { get; set; }

            /// <summary>
            /// Unique identifier
            /// </summary>
            object ID { get; }

            /// <summary>
            /// Adds a <see cref="TerminalControlBase"/> to the tile
            /// </summary>
            void Add(TerminalControlBase control);

            /// <summary>
            /// Retrieves information needed by the Framework API 
            /// </summary>
            ControlContainerMembers GetApiData();
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        using ControlContainerMembers = MyTuple<
            ApiMemberAccessor, // GetOrSetMember,
            MyTuple<object, Func<int>>, // Member List
            object // ID
        >;

        public enum TerminalAccessors : int
        {
            ToggleMenu = 0,
            OpenMenu = 1,
            CloseMenu = 2,
            OpenToPage = 3,
            SetPage = 4,
            GetMenuOpen = 5,

            /// <summary>
            /// out: Func<ControlContainerMembers>
            /// </summary>
            GetNewPageCategoryFunc = 6
        }

        /// <summary>
        /// Used by the API to specify to request a given type of settings menu control
        /// </summary>
        public enum MenuControls : int
        {
            Checkbox = 1,
            ColorPicker = 2,
            OnOffButton = 3,
            SliderSetting = 4,
            TerminalButton = 5,
            TextField = 6,
            DropdownControl = 7,
            ListControl = 8,
            DragBox = 9,
        }

        public enum ControlContainers : int
        {
            Tile = 1,
            Category = 2,
        }

        public enum ModPages : int
        {
            ControlPage = 1,
            RebindPage = 2,
            TextPage = 3,
        }

        public enum ModControlRootAccessors : int
        {
            /// <summary>
            /// Action
            /// </summary>
            GetOrSetCallback = 1,

            /// <summary>
            /// out: MyTuple<object, Func<int>>
            /// </summary>
            GetCategoryAccessors = 7,

            /// <summary>
            /// in: TerminalPageCategory
            /// </summary>
            AddSubcategory = 8
        }

        public interface IModRootMember
        {
            /// <summary>
            /// Name of the member as it appears in the terminal
            /// </summary>
            string Name { get; set; }

            /// <summary>
            /// Determines whether or not the element will appear in the list.
            /// Disabled by default.
            /// </summary>
            bool Enabled { get; set; }

            /// <summary>
            /// Unique identifier
            /// </summary>
            object ID { get; }
        }

        /// <summary>
        /// Indented dropdown list of terminal pages and page categories. Root UI element for all terminal controls
        /// associated with a given mod.
        /// </summary>
        public interface IModControlRoot : ITerminalPageCategory
        {
            /// <summary>
            /// Invoked when a new page is selected
            /// </summary>
            event EventHandler SelectionChanged;

            /// <summary>
            /// Page subcategories attached to the mod root
            /// </summary>
            IReadOnlyList<TerminalPageCategoryBase> Subcategories { get; }

            /// <summary>
            /// Adds a page subcategory to the control root
            /// </summary>
            void Add(TerminalPageCategoryBase subcategory);

            /// <summary>
            /// Adds a range of root members to the control root, either subcategories or pages.
            /// </summary>
            void AddRange(IReadOnlyList<IModRootMember> members);

            /// <summary>
            /// Retrieves data used by the Framework API
            /// </summary>
            ControlContainerMembers GetApiData();
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    namespace UI
    {
        using Client;
        using Server;

        public enum RebindPageAccessors : int
        {
            Add = 10,
        }

        public interface IRebindPage : ITerminalPage, IEnumerable<IBindGroup>
        {
            /// <summary>
            /// Bind groups registered to the rebind page.
            /// </summary>
            IReadOnlyList<IBindGroup> BindGroups { get; }

            /// <summary>
            /// Adds the given bind group to the page.
            /// </summary>
            void Add(IBindGroup bindGroup);

            /// <summary>
            /// Adds the given bind group to the page along with its associated default configuration.
            /// </summary>
            void Add(IBindGroup bindGroup, BindDefinition[] defaultBinds);
        }
    }
}﻿using System;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;

    namespace UI
    {
        using Server;
        using Client;

        public enum TerminalControlAccessors : int
        {
            /// <summary>
            /// Action
            /// </summary>
            GetOrSetControlCallback = 1,

            /// <summary>
            /// string
            /// </summary>
            Name = 2,

            /// <summary>
            /// bool
            /// </summary>
            Enabled = 3,

            /// <summary>
            /// in: Func<ToolTipMembers>
            /// </summary>
            ToolTip = 4,

            /// <summary>
            /// T
            /// </summary>
            Value = 8,

            /// <summary>
            /// Func{T}
            /// </summary>
            ValueGetter = 9,
        }

        /// <summary>
        /// Clickable control used in conjunction by the settings menu.
        /// </summary>
        public interface ITerminalControl
        {
            /// <summary>
            /// Raised whenever the control's value is changed.
            /// </summary>
            event EventHandler ControlChanged;

            /// <summary>
            /// Name of the control as it appears in the menu.
            /// </summary>
            string Name { get; set; }

            /// <summary>
            /// Determines whether or not the control will be visible in the menu.
            /// </summary>
            bool Enabled { get; set; }

            /// <summary>
            /// Optional tooltip for the control
            /// </summary>
            ToolTip ToolTip { get; set; }

            /// <summary>
            /// Unique identifer.
            /// </summary>
            object ID { get; }

            EventHandler ControlChangedHandler { get; set; }

            /// <summary>
            /// Retrieves data used by the Framework API
            /// </summary>
            ControlMembers GetApiData();
        }

        /// <summary>
        /// Settings menu control associated with a value of a given type.
        /// </summary>
        public interface ITerminalValue<TValue> : ITerminalControl
        {
            /// <summary>
            /// Value associated with the control.
            /// </summary>
            TValue Value { get; set; }

            /// <summary>
            /// Delegate used to periodically refresh the control's value. Optional.
            /// </summary>
            Func<TValue> CustomValueGetter { get; set; }
        }
    }
}﻿using System;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;

namespace RichHudFramework
{
    using ControlMembers = MyTuple<
        ApiMemberAccessor, // GetOrSetMember
        object // ID
    >;

    namespace UI
    {
        using Client;
        using Server;

        public enum TerminalPageAccessors : int
        {
            /// <summary>
            /// string
            /// </summary>
            Name = 1,

            /// <summary>
            /// bool
            /// </summary>
            Enabled = 2,
        }

        public interface ITerminalPage : IModRootMember
        {
            /// <summary>
            /// Retrieves information used by the Framework API
            /// </summary>
            ControlMembers GetApiData();
        }
    }
}﻿using System;
using System.Collections.Generic;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;

namespace RichHudFramework
{
    namespace UI
    {
        using Server;
        using Client;

        public enum TerminalPageCategoryAccessors : int
        {
            /// <summary>
            /// string
            /// </summary>
            Name = 2,

            /// <summary>
            /// bool
            /// </summary>
            Enabled = 3,

            /// <summary>
            /// out: ControlMembers
            /// </summary>
            Selection = 4,

            /// <summary>
            /// in: TerminalPageBase
            /// </summary>
            AddPage = 5,

            /// <summary>
            /// in: IReadOnlyList<TerminalPageBase>
            /// </summary>
            AddPageRange = 6,
        }

        /// <summary>
        /// Indented dropdown list of terminal pages.
        /// </summary>
        public interface ITerminalPageCategory : IEnumerable<TerminalPageBase>, IModRootMember
        {
            /// <summary>
            /// Read only collection of <see cref="TerminalPageBase"/>s assigned to this object.
            /// </summary>
            IReadOnlyList<TerminalPageBase> Pages { get; }

            /// <summary>
            /// Used to allow the addition of category elements using collection-initializer syntax in
            /// conjunction with normal initializers.
            /// </summary>
            ITerminalPageCategory PageContainer { get; }

            /// <summary>
            /// Currently selected <see cref="TerminalPageBase"/>.
            /// </summary>
            TerminalPageBase SelectedPage { get; }

            /// <summary>
            /// Adds a terminal page to the category
            /// </summary>
            void Add(TerminalPageBase page);

            /// <summary>
            /// Adds a range of terminal pages to the category
            /// </summary>
            void AddRange(IReadOnlyList<TerminalPageBase> pages);
        }
    }
}﻿using System;
using System.Text;
using VRage;
using ApiMemberAccessor = System.Func<object, int, object>;
using GlyphFormatMembers = VRage.MyTuple<byte, float, VRageMath.Vector2I, VRageMath.Color>;
using RichHudFramework.UI.Rendering;

namespace RichHudFramework
{
    namespace UI
    {
        using Client;
        using Server;

        public enum TextPageAccessors : int
        {
            /// <summary>
            /// in/out: IList(RichStringMembers)
            /// </summary>
            GetOrSetHeader = 10,

            /// <summary>
            /// in/out: IList(RichStringMembers)
            /// </summary>
            GetOrSetSubheader = 11,

            /// <summary>
            /// in/out: IList(RichStringMembers)
            /// </summary>
            GetOrSetText = 12,

            /// <summary>
            /// out: TextBuilderMembers
            /// </summary>
            GetTextBuilder = 13,
        }

        /// <summary>
        /// Scrollable text page used in the terminal.
        /// </summary>
        public interface ITextPage : ITerminalPage
        {
            /// <summary>
            /// Gets/sets header text
            /// </summary>
            RichText HeaderText { get; set; }

            /// <summary>
            /// Gets/sets subheader text
            /// </summary>
            RichText SubHeaderText { get; set; }

            /// <summary>
            /// Contents of the text box.
            /// </summary>
            RichText Text { get; set; }

            /// <summary>
            /// Text builder used to control the contents of the page
            /// </summary>
            ITextBuilder TextBuilder { get; }
        }
    }
}// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]
